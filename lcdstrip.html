<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TimeCast Pro LCD Strip</title>
<script src="/socket.io/socket.io.js"></script>
<style>
body {
  background: transparent;
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* LCD Panel Container */
.lcd-panel {
  display: inline-block;
  padding: 5px;
  background: #284963;
  border-radius: 2px;
  box-shadow:
    inset 0 2px 3px rgba(255,255,255,0.1),
    inset 0 -3px 3px rgba(0,0,0,0.8),
    0 2px 4px rgba(0,0,0,0.6);
}

/* LCD Strip - 450x58 dimensions (7.71:1 ratio) */
.lcdstrip {
  position: relative;
  width: 450px; /* 7.71:1 ratio maintained */
  height: 58px; /* 450 ÷ 7.71 = 58.37 */
  min-height: 58px; /* Match the fixed height */
  background: #193d91;
  border-radius: 2px;
  overflow: visible;
  box-shadow:
    inset 0 1px 2px rgba(255,255,255,0.1),
    inset 0 -1px 2px rgba(0,0,0,0.8);
  
  /* Dot matrix pixel pattern */
  background-image:
    linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px),
    linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
  background-size: 2px 2px;
  display: flex;
}

/* LCD Overlay gloss */
.lcdstrip::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(to bottom, rgba(255,255,255,0.08), rgba(0,0,0,0.05));
  pointer-events: none;
  z-index: 1;
}

/* LCD Segments (4 equal parts) - 112.5px each */
.lcd-segment {
  position: relative;
  flex: 1; /* Equal width segments (112.5px each) */
  height: 100%;
  width: 112.5px; /* Fixed width per segment (450px / 4) */
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-right: 1px solid rgba(255,255,255,0.1);
  z-index: 2;
  transition: background-color 0.2s ease;
  overflow: hidden; /* Prevent text from spilling to next segment */
  box-sizing: border-box;
  padding: 2px; /* Fixed padding for 62px height */
}

.lcd-segment:last-child {
  border-right: none;
}

.lcd-segment:hover {
  background: rgba(255,255,255,0.05);
}

.lcd-segment:active {
  background: rgba(255,255,255,0.1);
}

/* LCD Text - Auto-scaling */
.lcd-text {
  color: #0ff;
  font-family: "Courier New", monospace;
  font-size: 12px; /* Base size - will be adjusted by JavaScript */
  font-weight: bold;
  letter-spacing: 0.3px;
  text-shadow:
    0 0 3px rgba(0,255,255,0.9),
    0 0 6px rgba(0,255,255,0.6),
    0 0 9px rgba(0,255,255,0.3);
  white-space: pre-line;
  word-break: break-word;
  image-rendering: pixelated;
  text-align: center;
  z-index: 3;
  pointer-events: none;
  width: 100%;
  height: 100%;
  line-height: 1.1;
  max-height: 100%;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2px;
  box-sizing: border-box;
}

/* Status Colors - Enhanced glow for larger text */
.status-offline { 
  color: #ff4444 !important; 
  text-shadow: 0 0 3px rgba(255,68,68,0.9), 0 0 6px rgba(255,68,68,0.6), 0 0 9px rgba(255,68,68,0.3) !important; 
}
.status-online { 
  color: #00ddfa !important; 
  text-shadow: 0 0 3px rgba(0,221,250,0.9), 0 0 6px rgba(0,221,250,0.6), 0 0 9px rgba(0,221,250,0.3) !important; 
}
.status-preview { 
  color: #00ff00 !important; 
  text-shadow: 0 0 3px rgba(0,255,0,0.9), 0 0 6px rgba(0,255,0,0.6), 0 0 9px rgba(0,255,0,0.3) !important; 
}
.status-program { 
  color: #ff0000 !important; 
  text-shadow: 0 0 3px rgba(255,0,0,0.9), 0 0 6px rgba(255,0,0,0.6), 0 0 9px rgba(255,0,0,0.3) !important; 
}

/* Status text emphasis for bold status */
.status-bold {
  font-weight: 900 !important;
  text-shadow:
    0 0 4px rgba(0,255,255,1.0),
    0 0 8px rgba(0,255,255,0.8),
    0 0 12px rgba(0,255,255,0.5) !important;
}

.status-program-bold {
  font-weight: 900 !important;
  text-shadow:
    0 0 4px rgba(255,0,0,1.0),
    0 0 8px rgba(255,0,0,0.8),
    0 0 12px rgba(255,0,0,0.5) !important;
}

.status-preview-bold {
  font-weight: 900 !important;
  text-shadow:
    0 0 4px rgba(0,255,0,1.0),
    0 0 8px rgba(0,255,0,0.8),
    0 0 12px rgba(0,255,0,0.5) !important;
}

</style>
</head>
<body>
  <div class="lcd-panel">
    <div class="lcdstrip">
      <!-- Segment 1: vMix Status -->
      <div class="lcd-segment" data-segment="vmix">
        <div class="lcd-text" id="vmix-text">Timer is: OFFLINE\nInput # None</div>
      </div>
      
      <!-- Segment 2: Questions Stats -->
      <div class="lcd-segment" data-segment="questions">
        <div class="lcd-text" id="questions-text">Questions answered:\n0/0</div>
      </div>
      
      <!-- Segment 3: Online Clients -->
      <div class="lcd-segment" data-segment="clients">
        <div class="lcd-text" id="clients-text">Question Forms:\n0 Connected</div>
      </div>
      
      <!-- Segment 4: Video Timer -->
      <div class="lcd-segment" data-segment="video">
        <div class="lcd-text" id="video-text">Video: --:--</div>
      </div>
    </div>
  </div>

<script>
// Global variables for vMix status tracking (same as admin panel)
let currentVMixStatus = "Offline";
let currentTallyState = {
    timerInputOnProgram: false,
    timerInputOnPreview: false,
    currentProgramInput: null,
    currentPreviewInput: null
};

// Socket.IO connection for tally events (same as admin panel)
let socket = null;

// API Functions - Fetch data and update displays
async function fetchVMixData() {
  try {
    const response = await fetch('/api/vmix/status');
    if (response.ok) {
      const data = await response.json();
      
      // ONLY handle video data - vMix status is handled entirely by socket events
      if (data.secondaryTimer) {
        updateVideoDisplay(data.secondaryTimer);
      }
    }
    // Don't handle connection errors here - socket events handle vMix status
  } catch (error) {
    // Don't log errors or set offline status - socket events handle this
    // This is just for getting video data, not connection status
  }
}

async function fetchQuestionsData() {
  try {
    const response = await fetch('/api/questions/list');
    if (response.ok) {
      const data = await response.json();
      // Verbose logging disabled - data updates silently

      if (data.success && data.stats) {
        // Use the correct data from stats object
        const answered = data.stats.addressed || 0; // "addressed" = απαντημένες ερωτήσεις
        const total = data.stats.total || 0;
        
        updateQuestionsDisplay({
          total: total,
          answered: answered
        });
      } else {
        updateQuestionsDisplay({ total: 0, answered: 0 });
      }
    } else {
      updateQuestionsDisplay({ total: 0, answered: 0 });
    }
  } catch (error) {
    console.error('Failed to fetch questions data:', error);
    updateQuestionsDisplay({ total: 0, answered: 0 });
  }
}

// Real client count tracking
let currentQuestionsClientsCount = 0;

async function fetchClientsData() {
  // This function will be updated by socket events
  // Using the real count from socket events
  updateClientsDisplay(currentQuestionsClientsCount);
}


// Update display functions
function updateVMixDisplay() {
  const text = document.getElementById('vmix-text');
  if (!text) return;
  
  let displayText = '';
  let statusClass = 'lcd-text status-offline';
  
  // Get the TIMER input number - πάντα δείχνουμε τον αριθμό του input που έχει το timer
  let inputDisplay = 'NO INPUT';
  
  // ΝΕΑ ΣΩΣΤΗ ΛΟΓΙΚΗ: Χρησιμοποίησε το ACTUAL timer input που έχει το timer text
  if (currentTallyState.timerInput) {
    // Υπάρχει timer input - δείξε ΠΑΝΤΑ αυτό τον αριθμό
    inputDisplay = `INPUT #${currentTallyState.timerInput.number || currentTallyState.timerInput.key}`;
  }
  
  // Create display text based on status - USER REQUESTED FORMAT
  switch(currentVMixStatus) {
    case 'Program':
      displayText = `Timer is: PROGRAM\non vMix. Using ${inputDisplay}`;
      statusClass = 'lcd-text status-program status-program-bold';
      break;
    case 'Preview':
      displayText = `Timer is: PREVIEW\non vMix. Using ${inputDisplay}`;
      statusClass = 'lcd-text status-preview status-preview-bold';
      break;
    case 'Standby':
      displayText = `Timer is: STANDBY\non vMix. Using ${inputDisplay}`;
      statusClass = 'lcd-text status-online status-bold';
      break;
    case 'Offline':
    default:
      displayText = `Timer is: OFFLINE\nInput # None`;
      statusClass = 'lcd-text status-offline status-bold';
      break;
  }
  
  text.textContent = displayText;
  text.className = statusClass;
  
  // Auto-scale after content change
  setTimeout(() => autoScaleText(text), 10);
}

function updateQuestionsDisplay(data) {
  const text = document.getElementById('questions-text');
  if (!text) return;
  
  text.textContent = `Questions answered:\n${data.answered}/${data.total}`;
  text.className = 'lcd-text status-online';
  
  // Auto-scale after content change
  setTimeout(() => autoScaleText(text), 10);
}

function updateClientsDisplay(count) {
  const text = document.getElementById('clients-text');
  if (!text) return;
  
  // Enhanced display with proper labeling - simplified for larger font
  text.textContent = `Question Forms:\n${count} Connected`;
  text.className = count > 0 ? 'lcd-text status-online' : 'lcd-text status-offline';
  
  // Auto-scale after content change
  setTimeout(() => autoScaleText(text), 10);
}

function updateVideoDisplay(secondaryTimer) {
  const text = document.getElementById('video-text');
  if (!text) return;
  
  console.log('🎥 [LCD] Video timer data:', secondaryTimer); // Debug log
  
  if (secondaryTimer && secondaryTimer.active && secondaryTimer.remaining > 0) {
    // Calculate remaining time
    const remainingMins = Math.floor(secondaryTimer.remaining / 60);
    const remainingSecs = secondaryTimer.remaining % 60;
    const remainingTime = `${remainingMins}:${remainingSecs.toString().padStart(2, '0')}`;
    
    // Calculate elapsed time
    const totalTime = secondaryTimer.total || 0;
    const elapsedTime = totalTime - secondaryTimer.remaining;
    const elapsedMins = Math.floor(elapsedTime / 60);
    const elapsedSecs = elapsedTime % 60;
    const elapsedTimeStr = `${elapsedMins}:${elapsedSecs.toString().padStart(2, '0')}`;
    
    // Get filename (without extension for space)
    const filename = secondaryTimer.title || 'Unknown';
    const shortName = filename.length > 20 ? filename.substring(0, 17) + '...' : filename;
    
    // Professional display with proper labels
    text.textContent = `Video on vMix:\n${shortName}\nElapsed: ${elapsedTimeStr}\nRemaining: ${remainingTime}`;
    text.className = 'lcd-text status-online';
    
    console.log(`🎥 [LCD] Video: ${shortName} - Elapsed: ${elapsedTimeStr} - Remaining: ${remainingTime}`);
  } else {
    text.textContent = 'Video: --:--';
    text.className = 'lcd-text status-offline';
  }
  
  // Auto-scale after content change
  setTimeout(() => autoScaleText(text), 10);
}


// Update vMix status using EXACT same logic as admin panel working button
function updateVmixTallyStatus(tallyState) {
    console.log('🚨 [LCD STRIP] Updating vMix tally status:', tallyState);
    
    // Enhanced debug logging for input position changes
    const oldProgramInput = currentTallyState.currentProgramInput;
    const oldPreviewInput = currentTallyState.currentPreviewInput;
    const newProgramInput = tallyState?.currentProgramInput;
    const newPreviewInput = tallyState?.currentPreviewInput;
    
    if (oldProgramInput?.number !== newProgramInput?.number) {
        console.log(`📺 [LCD STRIP] Program input changed: ${oldProgramInput?.number || 'none'} → ${newProgramInput?.number || 'none'}`);
    }
    if (oldPreviewInput?.number !== newPreviewInput?.number) {
        console.log(`🟡 [LCD STRIP] Preview input changed: ${oldPreviewInput?.number || 'none'} → ${newPreviewInput?.number || 'none'}`);
    }
    
    // Store the current tally state
    currentTallyState = tallyState || currentTallyState;
    
    // EXACT COPY from admin.html updateVmixTallyStatus function
    // Check if this is an offline state (all inputs are null and timer states are false)
    const isOffline = !tallyState.currentProgramInput && 
                      !tallyState.currentPreviewInput && 
                      !tallyState.timerInputOnProgram && 
                      !tallyState.timerInputOnPreview;
    
    if (isOffline && (!tallyState.currentProgramInput && !tallyState.currentPreviewInput)) {
        // vMix is likely offline
        currentVMixStatus = 'Offline';
        console.log('⚫ [LCD STRIP] vMix appears to be OFFLINE');
        
    } else if (tallyState.timerInputOnProgram) {
        // Timer is on Program (RED) - highest priority
        currentVMixStatus = 'Program';
        console.log('🔴 [LCD STRIP] Timer is on PROGRAM (live output)');
        
    } else if (tallyState.timerInputOnPreview) {
        // Timer is on Preview only (GREEN) 
        currentVMixStatus = 'Preview';
        console.log('🟢 [LCD STRIP] Timer is on PREVIEW');
        
    } else {
        // Timer is not visible anywhere (BLUE - Standby)
        currentVMixStatus = 'Standby';
        console.log('🔵 [LCD STRIP] Timer is on STANDBY');
    }
    
    // Debug: Check what timer inputs we have
    console.log('🔍 [LCD STRIP] Timer Inputs Debug:', {
        timerInputs: currentTallyState.timerInputs,
        timerInputsLength: currentTallyState.timerInputs?.length,
        firstInput: currentTallyState.timerInputs?.[0]
    });
    
    // Update the LCD display with new status
    updateVMixDisplay();
}

// Initialize Socket.IO connection for tally events
function initializeSocket() {
  try {
    // Connect to the same socket server as admin panel
    socket = io();
    
    // Listen for tally state updates (exact same as admin panel)
    socket.on('tallyStateUpdate', (tallyState) => {
        updateVmixTallyStatus(tallyState);
    });

    // Listen for vMix connection status - EXACT COPY from admin panel
    socket.on('vmixConnectionStatus', (status) => {
        if (!status.connected) {
            currentVMixStatus = 'Offline';
            updateVMixDisplay();
            vmixTallyActive = false;
        } else {
            // Restart tally monitoring
            setTimeout(() => {
                initVmixTally();
            }, 500);
        }
    });

    // Listen for secondary timer updates (video timer)
    socket.on('secondaryTimerUpdate', (secondaryTimer) => {
        updateVideoDisplay(secondaryTimer);
    });
    
    socket.on('connect', () => {
        console.log('✅ [LCD STRIP] Socket.IO connected');
        
        // ΚΡΙΣΙΜΟ: Register as LCD client to receive all socket events
        console.log('📝 [LCD STRIP] Registering as LCD client...');
        socket.emit('registerClient', {
            type: 'lcd-client',
            role: 'display'
        });
        
        // Request current counts on connect
        socket.emit('requestCurrentCounts');
        
        // IMPORTANT: Start vMix tally monitoring immediately
        console.log('🚨 [LCD STRIP] Auto-starting vMix tally monitoring...');
        initVmixTally();
    });
    
    // Listen for questions clients count updates VIA SOCKET (fallback)
    socket.on('questionsClientsCount', (count) => {
        console.log('📡 [LCD STRIP] Received questionsClientsCount event:', count);
        currentQuestionsClientsCount = count || 0;
        updateClientsDisplay(currentQuestionsClientsCount);
    });
    
    socket.on('disconnect', () => {
        console.log('❌ [LCD STRIP] Socket.IO disconnected');
    });
    
    console.log('🔌 [LCD STRIP] Socket.IO initialized');
    
  } catch (error) {
    console.error('❌ [LCD STRIP] Failed to initialize Socket.IO:', error);
  }
}

// Initialize vMix tally monitoring - EXACT COPY from admin panel
let vmixTallyActive = false;

function initVmixTally() {
    console.log('🚨 [LCD STRIP] Initializing vMix tally monitoring...');
    console.log('🔗 [LCD STRIP] Socket connected:', socket && socket.connected);
    
    if (!socket || !socket.connected) {
        console.log('❌ [LCD STRIP] Socket not connected, cannot start tally monitoring');
        currentVMixStatus = 'Offline';
        updateVMixDisplay();
        return;
    }
    
    // Prevent multiple initializations
    if (vmixTallyActive) {
        console.log('⚠️ [LCD STRIP] vMix tally already active, skipping initialization');
        return;
    }
    
    // Use auto-detection instead of hardcoded input key
    console.log('📤 [LCD STRIP] Emitting setTimerInputKeys: [] (auto-detect)');
    socket.emit('setTimerInputKeys', []); // Empty array = auto-detect by title
    
    // Start tally monitoring with faster interval for immediate updates
    console.log('📤 [LCD STRIP] Emitting startTallyMonitoring');
    socket.emit('startTallyMonitoring');
    
    // Request immediate status update
    console.log('📤 [LCD STRIP] Requesting immediate tally status');
    socket.emit('requestTallyStatus');
    
    vmixTallyActive = true;
    console.log('✅ [LCD STRIP] vMix tally auto-started, vmixTallyActive =', vmixTallyActive);
}

// Fetch all data
async function fetchAllData() {
  await Promise.all([
    fetchVMixData(),
    fetchQuestionsData(), 
    fetchClientsData()
  ]);
}

// Initialize LCD Strip
function initializeLCDStrip() {
  console.log('🖥️ LCD Strip initialized');
  
  // Initialize Socket.IO connection
  initializeSocket();
  
  // Initial data fetch
  fetchAllData();
  
  // Initial auto-scale after a brief delay to ensure DOM is ready
  setTimeout(() => {
    console.log('🔧 Initial auto-scaling for all segments');
    autoScaleAllSegments();
  }, 500);
  
  // Additional forced auto-scaling after content loads (for vmix segment)
  setTimeout(() => {
    console.log('🔧 FORCED auto-scaling after content load - fixing vmix segment');
    autoScaleAllSegments();
  }, 3000);
  
  // Start real-time updates every 2 seconds
  setInterval(fetchAllData, 2000);
}

// Listen for postMessage events from parent (admin.html)
window.addEventListener('message', (event) => {
    // Security check - only accept messages from same origin
    if (event.origin !== window.location.origin) return;
    
    console.log('📨 [LCD STRIP] Received postMessage:', event.data);
    
    if (event.data && event.data.type === 'questionsClientsCount') {
        console.log('📡 [LCD STRIP] Received questionsClientsCount via postMessage:', event.data.count);
        currentQuestionsClientsCount = event.data.count || 0;
        updateClientsDisplay(currentQuestionsClientsCount);
    }
});

// Start when page loads
document.addEventListener('DOMContentLoaded', initializeLCDStrip);

// Handle window resize to trigger auto-scaling
window.addEventListener('resize', () => {
  // Debounce resize events to avoid excessive scaling calls
  clearTimeout(window.resizeTimeout);
  window.resizeTimeout = setTimeout(() => {
    console.log('📱 Window resized - triggering auto-scale for all segments');
    autoScaleAllSegments();
  }, 250);
});

// Click on vMix segment to force refresh if needed  
document.addEventListener('click', (e) => {
  const vmixSegment = e.target.closest('[data-segment="vmix"]');
  if (vmixSegment) {
    console.log('🖱️ [LCD STRIP] vMix segment clicked - requesting immediate tally update');
    if (socket && socket.connected && vmixTallyActive) {
      socket.emit('requestTallyStatus');
    }
  }
});

// Auto-scale text to fit within segment boundaries
function autoScaleText(textElement) {
  if (!textElement) return;
  
  const container = textElement.parentElement;
  if (!container) return;
  
  // Get container dimensions
  const containerWidth = container.clientWidth - 4; // Account for padding
  const containerHeight = container.clientHeight - 4;
  
  // Start with minimum size and scale up
  let fontSize = 8;
  textElement.style.fontSize = `${fontSize}px`;
  
  // Scale UP to find maximum size that fits
  let attempts = 0;
  while (fontSize < 30 && attempts < 50) {
    const testSize = fontSize + 0.5;
    textElement.style.fontSize = `${testSize}px`;
    
    if (textElement.scrollWidth > containerWidth || textElement.scrollHeight > containerHeight) {
      // Too big, use previous size
      textElement.style.fontSize = `${fontSize}px`;
      break;
    }
    
    fontSize = testSize;
    attempts++;
  }

  // Verbose logging disabled - scaling happens silently
}

// Apply auto-scaling to all segments
function autoScaleAllSegments() {
  const segments = ['vmix-text', 'questions-text', 'clients-text', 'video-text'];
  segments.forEach(segmentId => {
    const textElement = document.getElementById(segmentId);
    if (textElement) {
      autoScaleText(textElement);
    }
  });
}

// This duplicate function should be REMOVED - already have the correct one above
// Keeping only comment to show this was the duplicate function with old format

// Expose functions for external integration
window.TimeCastLCD = {
  updateVMixStatus: updateVMixDisplay,
  updateQuestionsStats: updateQuestionsDisplay,
  updateClientsCount: updateClientsDisplay,
  updateVideoTimer: updateVideoDisplay,
  refreshAll: fetchAllData,
  autoScaleAll: autoScaleAllSegments
};
</script>
</body>
</html>