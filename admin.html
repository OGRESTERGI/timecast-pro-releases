<!DOCTYPE html>
<html lang="el">
<head>
    <title>Admin Panel - Timer</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: ws: wss: http: https:;">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icon.png">

    <script src="libs/NoSleep.min.js"></script>
    <script src="yeelight.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Timer</title>
    <script>
        // Συνάρτηση για φόρτωση εφεδρικού script
        function loadFallbackScript(url) {
            console.log('Η φόρτωση του CDN απέτυχε, χρήση τοπικού αρχείου:', url);
            var script = document.createElement('script');
            script.src = url;
            document.head.appendChild(script);
            return true;
        }
    </script>

<style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--primary-color);
            color: var(--light-color);
            min-height: 100vh;
            padding: 20px;
        }
        
        /* ------ HEADER STYLES ------ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            gap: 15px;
            min-height: 80px;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 150px;
        }
        
        .header-logo {
            height: 50px;
            width: auto;
            border-radius: 5px;
        }
        
        .header-clock {
            font-family: 'Courier New', monospace;
            font-size: clamp(0.9rem, 2.5vw, 1.5rem);
            font-weight: bold;
            color: #3498db;
            background-color: rgba(0, 0, 0, 0.3);
            padding: clamp(6px, 1.5vw, 8px) clamp(10px, 2.5vw, 15px);
            border-radius: 6px;
            border: 2px solid #3498db;
            text-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
            min-width: clamp(80px, 20vw, 120px);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        /* Live Clock - το ρολόι δίπλα στο Live Event Timeline */
        .live-clock {
            font-size: 1.2rem !important; /* Ίδιο με q-admin Live Clock */
            padding: 6px 10px !important; /* Ίδιο με q-admin Live Clock */
            min-width: 90px !important; /* Ίδιο με q-admin Live Clock */
        }
        
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 120px;
            justify-content: flex-end;
        }
        
        /* ------ EVENT TIMELINE STYLES ------ */
       .timeline-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px; /* Μικρότερο gap για mobile */
    max-width: 95%; /* Ποσοστό αντί pixels */
    margin: 0 auto;
    position: relative;
    width: 100%;
}
        
        .timeline-input {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid #3498db;
            border-radius: 4px;
            background-color: rgba(52, 152, 219, 0.1);
            color: white;
            text-align: center;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }
        
        .timeline-input:focus {
            outline: none;
            border-color: #2980b9;
            background-color: rgba(52, 152, 219, 0.2);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
        }
        
        .timeline-bar-container {
    flex: 1;
    height: 40px;
    position: relative;
    background: linear-gradient(90deg, 
        rgba(113, 219, 52, 0.3) 0%, 
        rgba(155, 89, 182, 0.3) 50%, 
        rgba(231, 76, 60, 0.3) 100%);
    border-radius: 20px;
    border: 2px solid rgba(52, 152, 219, 0.5);
    cursor: pointer;
    overflow: visible;
    min-width: 200px;
    -webkit-user-select: auto !important;
    user-select: auto !important;
    -webkit-app-region: no-drag !important;
    pointer-events: auto !important;
    touch-action: manipulation !important;
    /* HOLD-TO-CREATE FEEDBACK */
    cursor: pointer !important;
}

.timeline-bar-container:active {
    border-color: #2980b9;
    box-shadow: 0 0 15px rgba(41, 128, 185, 0.6);
    transform: scale(1.00);
    transition: all 0.1s ease;
}

.timeline-bar-container:hover {
    border-color: #3498db;
    box-shadow: 0 0 10px rgba(52, 152, 219, 0.4);
}

.timeline-progress {
    height: 100%;
    background-color: #3498db; /* Γαλάζιο γέμισμα */
    border-radius: 18px;
    width: 100%; /* ΠΑΝΤΑ 100% */
    transition: none; /* Χωρίς transition */
    position: relative;
    transform-origin: right;
    float: right; /* ΠΡΟΣΘΗΚΗ: Κολλάει στα δεξιά */
}
.timeline-time-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    min-width: 60px; /* ΑΠΟ fixed width ΣΕ min-width */
    flex-shrink: 0;
}

.timeline-label {
    font-size: 0.8rem;
    font-weight: bold;
    color: #3498db;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
/* QR Tabs Styles */
.qr-tabs {
    justify-content: flex-start;
}

.qr-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.qr-tab {
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #bdc3c7;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.85rem;
}

.qr-tab:hover {
    background: rgba(255, 255, 255, 0.2);
    color: #ecf0f1;
}

.qr-tab.active {
    background: var(--secondary-color);
    color: white;
    border-color: var(--secondary-color);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .timeline-container {
        gap: 10px;
    }
    
    .timeline-time-section {
        min-width: 50px;
    }
    
    .timeline-label {
        font-size: 0.7rem;
    }
    
    .timeline-bar-container {
        height: 35px;
        min-width: 150px;
    }
    
    .qr-tabs {
        flex-direction: column;
        gap: 5px;
    }
    
    .modal-qr-container {
        flex-direction: column;
        align-items: center;
    }
}
        
        .timeline-tooltip {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        
        .timeline-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }
        
        .timeline-tooltip.show {
            opacity: 1;
        }
        .timeline-time-display {
    min-width: 70px;
    text-align: center;
    font-family: 'Courier New', monospace;
    font-size: 1rem;
    color: #3498db;
    font-weight: bold;
    background-color: rgba(52, 152, 219, 0.1);
    padding: 8px 12px;
    border-radius: 6px;
    border: 1px solid rgba(52, 152, 219, 0.3);
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.timeline-time-display:first-child {
    margin-right: 15px;
}

.timeline-time-display:last-child {
    margin-left: 15px;
}
       .event-marker {
    position: absolute;
    top: -45px;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background-color: #3498db;
    border: 3px solid white;
    cursor: pointer;
    z-index: 10;
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    color: white;
    text-shadow: 0 0 3px rgba(0, 0, 0, 0.7);
    transform: translateX(calc(-50% - -2px));
    /* ELECTRON CLICK FIXES */
    -webkit-app-region: no-drag !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    pointer-events: auto !important;
}
/* Marker source colors */
.marker-excel {
    border: 2px solid #4CAF50 !important; /* Πράσινο για Excel */
}

.marker-google {
    border: 2px solid #f44336 !important; /* Κόκκινο για Google Sheets */
}

.event-marker:hover {
    transform: translateX(calc(-50% - 2px)) scale(1.2);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
/* Κάθετη γραμμή κάτω από τον marker με μικρό βελάκι */
.event-marker::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    width: 1px;
    height: 15px;
    background-color: inherit;
    transform: translateX(-50%);
    z-index: 5;
}

/* Μικρό βελάκι στο τέλος της γραμμής */
.event-marker::before {
    content: '';
    position: absolute;
    top: calc(100% + 12px);
    left: 50%;
    width: 0;
    height: 0;
    border-left: 2px solid transparent;
    border-right: 2px solid transparent;
    border-top: 3px solid;
    border-top-color: inherit;
    transform: translateX(-50%);
    z-index: 5;
}

.event-marker:hover::after,
.event-marker:hover::before {
    opacity: 1;
}

/* Διαφορετικά χρώματα για τύπους - ΌΛΑ γαλάζια */
.event-marker.break,
.event-marker.lunch,
.event-marker.questions,
.event-marker.important {
    background-color: #01101a;
}
/* =================================== */
/* Νέα στατική κόκκινη γραμμή */
/* =================================== */
.timeline-progress .current-time-indicator {
    position: absolute;
    left: 0;
    top: 0;
    width: 3px;
    height: 100%;
    background-color: #ff4444;
    border-radius: 3px 0 0 3px;
    z-index: 10;
    box-shadow: 0 0 4px rgba(255, 68, 68, 0.6);
    pointer-events: none;
}

.timeline-progress .current-time-indicator::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -1px;
    width: 5px;
    height: 5px;
    background-color: #ff4444;
    border-radius: 50%;
    box-shadow: 0 0 3px rgba(255, 68, 68, 0.8);
}
        
        .marker-tooltip {
    position: absolute;
    bottom: -1px; /* ΑΛΛΑΓΗ: από -55px σε -75px για να φτάσει την αιχμή */
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(44, 62, 80, 0.95);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.8rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 9999 !important;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.marker-tooltip::after {
    content: '';
    position: absolute;
    bottom: 100%; /* ΑΛΛΑΓΗ: από top σε bottom */
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-bottom-color: rgba(44, 62, 80, 0.95); /* ΑΛΛΑΓΗ: από border-top σε border-bottom */
}
        
        .marker-tooltip.show {
            opacity: 1;
        }
        
        
        
        /* Animation για νέα markers */
        @keyframes markerPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        
        .event-marker.new {
            animation: markerPulse 0.6s ease-in-out;
        }
        
        /* ------ CONNECTION STATUS & LED ------ */
        .connection-status {
            display: flex;
            align-items: center;
            padding: 8px;
        }
        
        .led-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #e74c3c;
            box-shadow: 
                0 0 0 3px rgba(231, 76, 60, 0.2),
                0 0 10px rgba(231, 76, 60, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            position: relative;
            animation: led-pulse-red 2s infinite;
        }
        
        .led-indicator.connected {
            background-color: #27ae60;
            box-shadow: 
                0 0 0 3px rgba(39, 174, 96, 0.2),
                0 0 10px rgba(39, 174, 96, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            animation: led-pulse-green 3s infinite;
        }
        
        .led-indicator.connecting {
            background-color: #f39c12;
            box-shadow: 
                0 0 0 3px rgba(243, 156, 18, 0.2),
                0 0 10px rgba(243, 156, 18, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            animation: led-blink-orange 1s infinite;
        }
        /* Fullscreen Button */
.fullscreen-btn {
    background: linear-gradient(135deg, #34495e, #2c3e50);
    border: 2px solid #3498db;
    color: #3498db;
    width: 35px;
    height: 35px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    margin-left: 10px;
    font-weight: bold;
    position: relative;
    overflow: hidden;
}

.fullscreen-btn:hover {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border-color: #2980b9;
    box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
    transform: scale(1.05);
}

.fullscreen-btn:active {
    transform: scale(0.95);
}

.fullscreen-btn.fullscreen-active {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    border-color: #e74c3c;
    color: white;
    animation: pulse-fullscreen 2s infinite;
}
/* Update connection-status to accommodate fullscreen button */
.connection-status {
    display: flex;
    align-items: center;
    gap: 10px;
}

@keyframes pulse-fullscreen {
    0%, 100% { 
        box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); 
    }
    50% { 
        box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); 
    }
}
        
        /* LED Animation Effects */
        @keyframes led-pulse-green {
            0%, 100% { 
                box-shadow: 
                    0 0 0 3px rgba(39, 174, 96, 0.2),
                    0 0 10px rgba(39, 174, 96, 0.5),
                    inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 
                    0 0 0 3px rgba(39, 174, 96, 0.4),
                    0 0 15px rgba(39, 174, 96, 0.8),
                    inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
        }
        
        @keyframes led-pulse-red {
            0%, 100% { 
                box-shadow: 
                    0 0 0 3px rgba(231, 76, 60, 0.2),
                    0 0 10px rgba(231, 76, 60, 0.5),
                    inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
            50% { 
                box-shadow: 
                    0 0 0 3px rgba(231, 76, 60, 0.4),
                    0 0 15px rgba(231, 76, 60, 0.8),
                    inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
        }
        
        @keyframes led-blink-orange {
            0%, 50% { 
                opacity: 1;
                box-shadow: 
                    0 0 0 3px rgba(243, 156, 18, 0.3),
                    0 0 12px rgba(243, 156, 18, 0.6),
                    inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
            51%, 100% { 
                opacity: 0.3;
                box-shadow: 
                    0 0 0 3px rgba(243, 156, 18, 0.1),
                    0 0 5px rgba(243, 156, 18, 0.2),
                    inset 0 1px 1px rgba(255, 255, 255, 0.1);
            }
        }
        
        /* ========== MOBILE-STYLE MODAL ========== */

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding: 20px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.modal-overlay.show {
    opacity: 1;
}

.modal {
    background-color: var(--primary-color);
    border-radius: 15px;
    width: 90vw;
    max-width: 900px;
    max-height: 90vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
}

.modal-overlay.show .modal {
    transform: scale(1);
    opacity: 1;
}

.modal-header {
    padding: 20px 20px 15px 20px;
    background: linear-gradient(135deg, #34495e, #2c3e50);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    cursor: move;
    user-select: none;
}

.modal-title {
    font-size: 1.3rem;
    font-weight: bold;
    color: white;
}

.modal-close {
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: white;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 8px 12px;
    border-radius: 10px;
    transition: background-color 0.2s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    background: rgba(255, 255, 255, 0.2);
}

.modal-body {
    padding: 15px 20px !important;
    overflow-y: auto;
    flex: 1;
    scrollbar-width: thin;
    scrollbar-color: #3498db transparent;
}

.settings-section {
    margin-bottom: 15px !important;
    padding-bottom: 12px !important;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.settings-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.section-title {
    margin-bottom: 8px !important;
    font-size: 1rem !important;
    color: var(--secondary-color);
    font-weight: bold;
}

.modal .form-group {
    margin-bottom: 10px !important;
}

.modal .form-group label {
    margin-bottom: 4px !important;
    font-weight: bold;
    font-size: 0.9rem;
    display: block;
}

.modal .form-group input,
.modal .form-group textarea {
    padding: 8px !important;
    font-size: 0.9rem;
    border-radius: 8px;
    width: 100%;
    border: 1px solid #555;
    background-color: #34495e;
    color: white;
}

.modal button {
    background-color: var(--secondary-color);
    color: white;
    border: none;
    padding: 12px 16px !important;
    border-radius: 10px !important;
    cursor: pointer;
    font-size: 0.9rem !important;
    transition: all 0.2s;
    font-weight: 500;
}

.modal button:hover {
    background-color: #2980b9;
    transform: translateY(-1px);
}

.modal .button-group {
    display: flex;
    gap: 10px !important;
    margin-top: 12px !important;
    flex-wrap: wrap;
}

/* Timeline labels - αφαίρεση διπλών labels */
.timeline-input-group label {
    display: none;
}

/* Warning threshold - compact με inline button */
.warning-threshold-row {
    display: flex;
    align-items: center;
    gap: 10px;
}

.warning-threshold-row input {
    width: 80px !important;
    flex: none !important;
}

.warning-threshold-row button {
    padding: 8px 12px !important;
    font-size: 0.85rem !important;
}

/* Logo container - σταθερές διαστάσεις */
.logo-preview-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 8px !important;
}

/* Logo container - μικρότερο */
.logo-preview-fixed {
    width: 100px;
    height: 100px; 
    background-color: #27ae60;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    flex-shrink: 0;
}

.logo-preview-fixed img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

/* Position grid - ακόμη μικρότερο */
.position-grid {
    display: inline-block;
    background-color: rgba(0, 0, 0, 0.3);
    padding: 6px; /* Από 8px σε 6px */
    border-radius: 4px;
    transform: scale(0.5); /* Από 0.6 σε 0.5 */
    transform-origin: left top;
    margin: -8px 0;
}

/* Προσθήκη: Περισσότερος χώρος για logo container */
.logo-preview-fixed {
    width: 100px; /* Από 80px σε 100px */
    height: 100px;
    background-color: #27ae60;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    flex-shrink: 0;
}

/* Καλύτερη διάταξη για logo section */
.form-group div[style*="display: flex; align-items: start; gap: 15px;"] {
    gap: 20px !important; /* Περισσότερο κενό μεταξύ logo και positions */
}

/* Sound settings - compact με inline button */
.sound-settings-compact {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
}

.sound-volume-compact {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
    min-width: 200px;
}

.sound-volume-compact input[type="range"] {
    width: 120px !important;
    flex: none;
}

.sound-settings-compact button {
    padding: 8px 12px !important;
    font-size: 0.85rem !important;
}

/* Timeline settings - πιο compact */
.timeline-settings-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    align-items: end;
}

.timeline-input-group {
    display: flex;
    flex-direction: column;
}

.timeline-input-group input {
    padding: 8px !important;
    text-align: center;
    font-size: 1.1rem !important;
    font-weight: bold;
}

/* Timer inputs - μικρότερα */
.time-input-container {
    display: grid !important;
    grid-template-columns: 1fr auto 1fr auto 1fr;
    gap: 8px !important;
    align-items: end !important;
    margin: 12px 0 !important;
}

.time-field {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.time-field label {
    font-size: 0.8rem !important;
    margin-bottom: 3px !important;
}

.time-box {
    width: 60px !important;
    height: 40px !important;
    font-size: 24px !important;
    text-align: center;
    border-radius: 8px;
}

/* Danger Zone Container - Απομόνωση από άλλα backgrounds */
.danger-zone-container {
    border: 3px solid #000 !important;
    background: repeating-linear-gradient(45deg, #ffcc00, #ffcc00 10px, #000 10px, #000 20px) !important;
    border-radius: 8px !important;
    margin: 30px 0 0 0 !important;
    padding: 20px !important;
    position: relative !important;
    z-index: 10 !important;
    display: block !important;
    clear: both !important;
    isolation: isolate !important;
    contain: layout style !important;
}

.time-separator {
    font-size: 24px !important;
    align-self: end;
    margin-bottom: 6px;
}

/* QR Section - πιο compact */
.modal-qr-container {
    display: flex;
    gap: 12px;
    align-items: flex-start;
    flex-wrap: wrap;
}

.modal-qr-code #qrcode-modal {
    width: 80px !important;
    height: 80px !important;
    background-color: white;
    margin: 0 auto;
    border-radius: 6px;
    padding: 4px;
    box-sizing: border-box;
    overflow: hidden;
}

.modal-qr-info {
    flex: 1;
    min-width: 180px;
    text-align: left;
}

.modal-timer-url {
    word-break: break-all;
    background-color: rgba(0, 0, 0, 0.3);
    padding: 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    margin: 10px 0;
}

.modal-open-timer-btn {
    background-color: #27ae60 !important;
    color: white !important;
    padding: 10px 20px !important;
    border: none !important;
    border-radius: 5px !important;
    font-size: 0.9rem !important;
    cursor: pointer !important;
    text-decoration: none !important;
    display: inline-block !important;
    margin-top: 10px;
    transition: background-color 0.2s;
}

.modal-open-timer-btn:hover {
    background-color: #219955 !important;
}

/* Server info - πιο compact */
.modal-server-info {
    margin-top: 10px;
    padding: 8px;
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.modal-server-info h4 {
    margin-bottom: 6px;
    color: #3498db;
    font-size: 0.9rem;
}

.modal-server-addresses {
    font-size: 0.8rem;
    line-height: 1.3;
}

.modal-server-addresses div {
    margin-bottom: 6px;
    padding: 4px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

/* Background color row - compact */
.background-color-compact {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}

.background-color-compact input[type="color"] {
    width: 100px !important;
    height: 50px !important;
}

.background-color-compact input[type="text"] {
    width: 80px !important;
    padding: 6px !important;
}

.background-color-compact div {
    width: 20px !important;
    height: 20px !important;
}

.background-color-compact button {
    padding: 6px 10px !important;
    font-size: 0.8rem !important;
}




/* Mobile responsive */
@media (max-width: 480px) {
    .modal {
        width: 95vw;
        margin: 10px;
        border-radius: 20px;
    }
    
    .modal-header {
        padding: 15px;
    }
    
    .modal-body {
        padding: 12px 15px !important;
    }
    
    .timeline-settings-grid {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .time-input-container {
        grid-template-columns: 1fr auto 1fr auto 1fr;
        gap: 6px;
    }
    
    .time-box {
        width: 50px !important;
        height: 35px !important;
        font-size: 18px !important;
    }
}
        
        /* ------ MAIN CONTENT STYLES ------ */
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .panel {
            flex: 1;
            min-width: 300px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        /* Make the preview panel wider */
        .panel:nth-child(1) {
            flex: 2;
            min-width: 500px;
        }
        
        /* Preview screen styling */
        .preview-container {
          width: 80%;
          margin: 5px auto;
          aspect-ratio: 16/9;
          background: #f0f0f0;
          border: 2px solid #ccc;
          box-sizing: border-box;
          position: relative;
          overflow: hidden;
        }

        #preview-content {
          position: absolute;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
        }

        #preview-screen {
            width: 100%;
            max-width: 600px;
            margin: 0 auto 8px auto;
            background-color: var(--primary-color);
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16 / 9;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }
        
       #title-preview {
    background-color: rgba(0, 0, 0, 0.3);
    text-align: center;
    font-size: 1.2vh;
    font-weight: bold;
    height: 4vh; /* ΠΡΟΣΘΗΚΗ: Σταθερό ύψος */
    display: flex; /* ΠΡΟΣΘΗΚΗ: Flexbox */
    align-items: center; /* ΠΡΟΣΘΗΚΗ: Κάθετο κεντράρισμα */
    justify-content: center; /* ΠΡΟΣΘΗΚΗ: Οριζόντιο κεντράρισμα */
    overflow: hidden; /* ΠΡΟΣΘΗΚΗ: Κρύψιμο περίσσειας */
    padding: 0; /* ΠΡΟΣΘΗΚΗ: Αφαίρεση padding */
}
        
        .preview-main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    padding: 1vh; /* ΜΕΙΩΣΗ από 2vh σε 1vh */
    height: calc(100% - 5vh);
    gap: 1vh; /* ΠΡΟΣΘΗΚΗ: κενό μεταξύ των στοιχείων */
}
        
        .timer-preview {
            font-size: 18vh;
            font-weight: bold;
            text-align: center;
            margin: 2vh 0;
            transition: font-size 0.5s ease-in-out;
            /* Responsive font scaling με clamp για smooth resizing */
            font-size: clamp(8vh, 12vw, 18vh);
        }
        
        
        .timer-preview.warning {
            color: #f39c12;
        }
        
        .timer-preview.danger {
            color: #e74c3c;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes pulsating {
            0% { 
                opacity: 0.6; 
                transform: scale(1);
            }
            50% { 
                opacity: 1; 
                transform: scale(1.05);
            }
            100% { 
                opacity: 0.6; 
                transform: scale(1);
            }
        }

        @keyframes flash-alert {
            0% {
                color: #ffffff;
            }
            50% {
                color: #ff6b6b;
            }
            100% {
                color: #ffffff;
            }
        }

        .timer-preview.flash-alert,
        #message-preview.flash-alert {
            animation: flash-alert 1.2s ease-in-out infinite;
        }


        .timer-preview.overtime {
            color: #e74c3c;
            animation: pulsating 1.5s infinite;
        }

        #preview-screen .timer-section {
    flex: 0 0 auto; /* ΑΛΛΑΓΗ: δεν παίρνει όλο το χώρο */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 100%;
    gap: 0.5vh; /* ΠΡΟΣΘΗΚΗ: μικρό κενό μεταξύ timer και progress */
}
        
       #preview-screen .progress-container {
    width: 80%;
    height: 15px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    margin: 0.5vh auto; /* ΜΕΙΩΣΗ από 2vh σε 0.5vh */
    overflow: hidden;
    flex-shrink: 0; /* ΠΡΟΣΘΗΚΗ: δεν συρρικνώνεται */
}
        
        #preview-screen .progress-bar {
            height: 100%;
            width: 100%;
            background-color: #3498db;
            border-radius: 5px;
            transition: width 1s linear;
        }
        
        #preview-screen .progress-bar.warning {
            background-color: #f39c12;
        }
        
        #preview-screen .progress-bar.danger {
            background-color: #e74c3c;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        #preview-screen .message-section {
            width: 100%;
            flex-shrink: 0;
            max-height: 75%; /* ΑΛΛΑΓΗ: από 80% σε 75% */
            height: 75%; /* ΑΛΛΑΓΗ: από 80% σε 75% */
            overflow: hidden !important; /* ΔΙΟΡΘΩΣΗ: hidden για boundaries */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
       #message-container-preview {
    width: 90%; /* ΑΥΞΗΣΗ από 80% σε 90% */
    height: 100%; /* ΠΡΟΣΘΗΚΗ: παίρνει όλο το ύψος της section */
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0; /* ΑΦΑΙΡΕΣΗ των margins */
    overflow: hidden !important; /* ΔΙΟΡΘΩΣΗ: hidden για boundaries */
}
        
        #message-preview {
            background-color: transparent;
            padding: 5px;
            border-radius: 0;
            font-size: 8vh;
            font-weight: normal;
            height: 100% !important; /* ΔΙΟΡΘΩΣΗ: παίρνει όλο το ύψος του container */
            max-height: 100% !important; /* ΔΙΟΡΘΩΣΗ: περιορισμός στο 100% του container */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: font-size 0.3s ease;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            text-align: center;
            line-height: 1.2;
            overflow: hidden !important; /* ΔΙΟΡΘΩΣΗ: hidden για να μένει εντός ορίων */
            width: 100%;
        }
        
        #message-preview:empty {
            display: none;
        }
        /* Question lines styling για admin preview */
#message-preview .question-from-line,
#message-preview .question-to-line,
#message-preview .question-subject-line,
#message-preview .question-text-content {
    word-wrap: break-word;
    overflow-wrap: break-word;
    display: block;
    width: 100%;
    max-height: none !important;
    overflow: visible !important;
}
        /* ========== MESSAGE INPUT LOCK HEIGHT ========== */

#message-input {
    min-height: 40px !important;
        min-height: 40px !important;

    max-height: 120px !important;
    overflow-y: auto !important;
    line-height: 1.0 !important;
}

/* Πράσινο κουμπί αποθήκευσης με glow */
.save-message-btn {
    background: linear-gradient(135deg, #27ae60, #2ecc71) !important;
    border: none !important;
    color: white !important;
    padding: 10px 15px !important; /* ΙΔΙΟ με τα άλλα κουμπιά */
    border-radius: 5px !important;
    font-size: 1rem !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    box-shadow: 
        0 0 15px rgba(39, 174, 96, 0.4),
        0 4px 12px rgba(0, 0, 0, 0.2) !important;
    
    /* ΟΧΙ width/height - παίρνει το κανονικό μέγεθος */
    flex: none !important;
    white-space: nowrap !important;
}

/* Hover effect */
.save-message-btn:hover {
    background: linear-gradient(135deg, #2ecc71, #27ae60) !important;
    box-shadow: 
        0 0 25px rgba(39, 174, 96, 0.6),
        0 6px 15px rgba(0, 0, 0, 0.3) !important;
    transform: translateY(-1px) !important;
}
/* ========== PULSE BUTTON EFFECTS ========== */
/* ========== 2-COLUMN MESSAGES LAYOUT ========== */
.messages-list {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 6px !important;
    padding: 6px !important;
    max-height: 170px !important;
    overflow-y: auto !important;
}

/* Κάθε message item θα παίρνει το μισό πλάτος */
.message-item {
    width: 100% !important;
    box-sizing: border-box !important;
    margin-bottom: 0 !important; /* Αφαίρεση του κάτω margin */
}

/* Responsive - σε μικρές οθόνες επιστροφή σε 1 στήλη */
@media (max-width: 768px) {
    .messages-list {
        grid-template-columns: 1fr !important;
    }
}

/* Message Toggle Button - Pulse κόκκινο όταν είναι visible */
.message-toggle-btn {
    background-color: var(--secondary-color) !important;
    color: white !important;
    border: none !important;
    padding: 10px 15px !important;
    border-radius: 5px !important;
    cursor: pointer !important;
    font-size: 1rem !important;
    transition: all 0.3s ease !important;
    position: relative !important;
}

.message-toggle-btn.message-visible {
    background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
    animation: red-pulse-glow 1.5s infinite ease-in-out !important;
    box-shadow: 
        0 0 20px rgba(231, 76, 60, 0.6),
        0 4px 15px rgba(0, 0, 0, 0.3) !important;
}

.message-toggle-btn.message-hidden {
    background: linear-gradient(135deg, #27ae60, #2ecc71) !important;
    box-shadow: 
        0 0 12px rgba(39, 174, 96, 0.4),
        0 4px 12px rgba(0, 0, 0, 0.2) !important;
}

/* Pulse animations */
@keyframes red-pulse-glow {
    0% { 
        box-shadow: 
            0 0 15px rgba(231, 76, 60, 0.6),
            0 4px 15px rgba(0, 0, 0, 0.3);
        transform: scale(1);
    }
    50% { 
        box-shadow: 
            0 0 30px rgba(231, 76, 60, 0.9),
            0 6px 20px rgba(0, 0, 0, 0.4);
        transform: scale(1.05);
    }
    100% { 
        box-shadow: 
            0 0 15px rgba(231, 76, 60, 0.6),
            0 4px 15px rgba(0, 0, 0, 0.3);
        transform: scale(1);
    }
}

/* Hover effects */
.message-toggle-btn:hover {
    transform: translateY(-2px) !important;
}

.message-toggle-btn.message-visible:hover {
    background: linear-gradient(135deg, #c0392b, #a93226) !important;
    animation: red-pulse-glow-fast 0.8s infinite ease-in-out !important;
}

.message-toggle-btn.message-hidden:hover {
    background: linear-gradient(135deg, #2ecc71, #27ae60) !important;
    box-shadow: 
        0 0 25px rgba(39, 174, 96, 0.7),
        0 6px 18px rgba(0, 0, 0, 0.3) !important;
}

@keyframes red-pulse-glow-fast {
    0%, 100% { 
        box-shadow: 
            0 0 20px rgba(231, 76, 60, 0.8),
            0 6px 20px rgba(0, 0, 0, 0.4);
    }
    50% { 
        box-shadow: 
            0 0 35px rgba(231, 76, 60, 1),
            0 8px 25px rgba(0, 0, 0, 0.5);
    }
}
/* Active effect */
.save-message-btn:active {
    transform: translateY(0) !important;
    box-shadow: 
        0 0 12px rgba(39, 174, 96, 0.5),
        0 2px 8px rgba(0, 0, 0, 0.2) !important;
}

/* Pulsing glow animation */
@keyframes save-glow {
    0% { 
        box-shadow: 
            0 0 15px rgba(39, 174, 96, 0.4),
            0 4px 12px rgba(0, 0, 0, 0.2);
    }
    50% { 
        box-shadow: 
            0 0 25px rgba(39, 174, 96, 0.7),
            0 4px 12px rgba(0, 0, 0, 0.2);
    }
    100% { 
        box-shadow: 
            0 0 15px rgba(39, 174, 96, 0.4),
            0 4px 12px rgba(0, 0, 0, 0.2);
    }
}

.save-message-btn.saving {
    animation: save-glow 1.5s infinite ease-in-out;
}
        
        /* Στυλ για λογότυπα στην προεπισκόπηση */
        .preview-logo {
            width: 6vh;
            height: 6vh;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
            z-index: 10;
            min-width: 20px;
            min-height: 20px;
            max-width: 80px;
            max-height: 80px;
        }
        
        #preview-logo-tl {
            top: 10px;
            left: 10px;
        }
        
        #preview-logo-tc {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #preview-logo-tr {
            top: 10px;
            right: 10px;
        }
        
        #preview-logo-bl {
            bottom: 10px;
            left: 10px;
        }
        
        #preview-logo-bc {
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #preview-logo-br {
            bottom: 10px;
            right: 10px;
        }
        
        /* Fallback για browsers που δεν υποστηρίζουν aspect-ratio */
        @supports not (aspect-ratio: 16 / 9) {
            #preview-screen {
                position: relative;
                width: 100%;
                max-width: 600px;
            }
            
            #preview-screen::before {
                content: "";
                display: block;
                padding-top: 56.25%; /* 16:9 Aspect Ratio */
            }
            
            #preview-screen > div {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }
        }
        
        .panel-title {
            font-size: 1rem;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 5px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #34495e;
            color: white;
        }
        
        .form-group textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
        }
        
        .checkbox-item input {
            margin-right: 5px;
            width: auto;
        }
        
        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .btn-danger {
            background-color: var(--accent-color);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .btn-success {
            background-color: #27ae60;
        }
        
        .btn-success:hover {
            background-color: #219955;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .time-adjust {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .time-button {
            background-color: var(--dark-color);
            font-size: 0.9rem;
            padding: 8px 12px;
        }
        .time-button.time-minus {
            background-color: #e67e22; /* Πορτοκαλί */
            color: white;
        }
        
        .time-button.time-minus:hover {
            background-color: #d35400; /* Σκούρο πορτοκαλί στο hover */
        }
        
        .time-button.time-plus {
            background-color: #27ae60; /* Πράσινο */
            color: white;
        }
        
        .time-button.time-plus:hover {
            background-color: #219955; /* Σκούρο πράσινο στο hover */
        }
        
        .messages-list {
            max-height: 175px;
            overflow-y: auto;
            margin-top: 15px;
            padding: 5px;
        }
        
        .message-item {
            display: flex;
            font-size: 0.85rem !important;
            justify-content: space-between;
            align-items: center;
            line-height: 1.1 !important;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 4px;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        
        .message-item.editing {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .message-actions {
            display: flex;
            gap: 5px;
        }
        
        .message-actions button {
            padding: 3px 8px;
            font-size: 0.8rem;
            margin-left: 3px;
        }
        
        .message-actions button:nth-child(2) {
            background-color: #3498db;
        }
        
        .message-actions button:nth-child(3) {
            background-color: #e74c3c;
        }
        
        .qr-container {
            text-align: center;
            margin-top: 20px;
        }
        
        .qr-code {
            width: 200px;
            height: 200px;
            background-color: white;
            margin: 0 auto;
            border-radius: 5px;
        }
        
        .timer-url {
            word-break: break-all;
            margin-top: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }
        
        .server-info {
            margin-top: 20px;
        }
        
        .warning {
            color: #f39c12;
        }
        
        .danger {
            color: var(--accent-color);
            animation: blink 1s infinite;
        }
        
        /* UI improvements styles */
        .time-input-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            gap: 10px;
        }
        
        .time-field {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .time-box {
            width: 100px;
            height: 60px;
            text-align: center;
            font-size: 50px;
            background-color: hsl(239, 100%, 21%);
            color: rgb(0, 221, 250);
            border: 1px solid #555;
            border-radius: 10px;
        }
        
        .time-separator {
            font-size: 50px;
            margin: 0 5px;
            align-self: flex-end;
            margin-bottom: 0px;
        }
        
        .title-control, .input-with-controls {
            display: flex;
            align-items: center;
        }
        
        .input-with-controls {
            flex: 1;
            position: relative;
        }
        
        .input-with-controls input {
            flex: 1;
        }
        
        .control-buttons {
            display: flex;
            margin-left: 10px;
        }
        
        .size-button {
            width: 30px;
            height: 30px;
            padding: 0;
            margin: 0 2px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .logo-upload {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .logo-upload input[type="file"] {
            display: none;
        }
        
        .upload-button {
            padding: 8px 12px;
            margin-right: 10px;
        }
        
        .logo-preview-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .logo-positions {
            margin-top: 15px;
        }
        
        .position-grid {
    display: inline-block;
    background-color: rgba(0, 0, 0, 0.3);
    padding: 8px; /* Από 15px σε 8px */
    border-radius: 4px;
    transform: scale(0.6); /* ΠΡΟΣΘΗΚΗ scale */
    transform-origin: left top;
    margin: -5px 0; /* ΠΡΟΣΘΗΚΗ για να μην πιάνει πολύ χώρο */
}

.position-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px; /* Από 35px σε 20px */
}

.position-row:last-child {
    margin-bottom: 0;
}

.position-cell {
    position: relative;
    width: 35px; /* Από 50px σε 35px */
    height: 35px; /* Από 50px σε 35px */
    margin: 0 10px; /* Από 0 15px σε 0 10px */
}

.position-cell input[type="checkbox"],
.position-cell input[type="radio"] {
    position: absolute;
    opacity: 0;
}

.position-label {
    display: block;
    width: 20px; /* Από 24px σε 20px */
    height: 20px; /* Από 24px σε 20px */
    position: absolute;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid #555;
    cursor: pointer;
}

.position-label:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

input[type="checkbox"]:checked + .position-label,
input[type="radio"]:checked + .position-label {
    background-color: var(--secondary-color);
    border-color: var(--secondary-color);
}

.top-left {
    top: 0;
    left: 0;
}

.top-center {
    top: 0;
    left: 50%;
    transform: translateX(-50%);
}

.top-right {
    top: 0;
    right: 0;
}

.bottom-left {
    bottom: 0;
    left: 0;
}

.bottom-center {
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
}

.bottom-right {
    bottom: 0;
    right: 0;
}
        
        /* ------ RESPONSIVE STYLES ------ */
        /* Responsive header */
        @media (max-width: 1024px) {
            .header {
                flex-direction: column;
                text-align: center;
                gap: 20px;
                padding: 20px;
            }
            
            .logo-container {
                justify-content: center;
                min-width: auto;
            }
            
            .timeline-container {
                width: 100%;
                max-width: 500px;
            }
            
            .header-controls {
                justify-content: center;
                min-width: auto;
            }
        }
        
        /* Large screens - μεγάλες οθόνες */
        @media (min-width: 1400px) {
            .timer-preview {
                font-size: clamp(12vh, 15vw, 22vh);
            }
            
            .header-clock {
                font-size: clamp(1.2rem, 3vw, 1.8rem);
                padding: clamp(8px, 2vw, 12px) clamp(15px, 3vw, 20px);
                min-width: clamp(120px, 25vw, 150px);
            }
            
            .live-clock {
                font-size: clamp(1rem, 3.2vw, 1.6rem) !important;
                padding: clamp(8px, 2vw, 10px) clamp(10px, 2.5vw, 15px) !important;
                min-width: clamp(80px, 20vw, 110px) !important;
            }
            
        }
        
        /* Enhanced responsive breakpoints για smooth timer scaling */
        @media (max-width: 1200px) {
            .timer-preview {
                font-size: clamp(6vh, 10vw, 16vh);
            }
            
            .header-clock {
                font-size: clamp(0.85rem, 2.3vw, 1.3rem);
                padding: clamp(5px, 1.3vw, 7px) clamp(8px, 2.2vw, 12px);
                min-width: clamp(75px, 18vw, 110px);
            }
            
            .live-clock {
                font-size: clamp(0.8rem, 2.5vw, 1.2rem) !important;
                padding: clamp(5px, 1.3vw, 7px) clamp(7px, 1.8vw, 10px) !important;
                min-width: clamp(65px, 16vw, 85px) !important;
            }
            
        }
        
        @media (max-width: 992px) {
            .timer-preview {
                font-size: clamp(5vh, 9vw, 14vh);
            }
            
            .header-clock {
                font-size: clamp(0.8rem, 2.1vw, 1.1rem);
                padding: clamp(4px, 1.2vw, 6px) clamp(7px, 2vw, 10px);
                min-width: clamp(70px, 16vw, 95px);
            }
            
            .live-clock {
                font-size: clamp(0.75rem, 2.2vw, 1rem) !important;  
                padding: clamp(4px, 1.2vw, 6px) clamp(6px, 1.6vw, 8px) !important;
                min-width: clamp(60px, 14vw, 75px) !important;
            }
            
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header-clock {
                font-size: clamp(0.75rem, 1.8vw, 1rem);
                padding: clamp(3px, 1vw, 5px) clamp(6px, 1.8vw, 8px);
                min-width: clamp(65px, 14vw, 85px);
            }
            
            .live-clock {
                font-size: clamp(0.7rem, 1.9vw, 0.9rem) !important;
                padding: clamp(3px, 1vw, 5px) clamp(5px, 1.4vw, 7px) !important;
                min-width: clamp(55px, 12vw, 70px) !important;
            }
            
            
            
            .header-logo {
                height: 40px;
            }
            
            .timeline-container {
                flex-direction: column;
                gap: 10px;
                margin: 10px 0;
                max-width: none;
            }
            
            .timeline-input {
                width: 100px;
            }
            
            .timeline-bar-container {
                width: 100%;
                min-width: 200px;

            }
            
            .event-marker {
                width: 14px;
                height: 14px;
                top: -7px;
            }
            
            .header-controls {
                width: 100%;
                justify-content: space-between;
            }
            
            .settings-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .panel {
                padding: 15px;
            }
            
            .timer-preview {
                font-size: clamp(4vh, 8vw, 12vh);
                margin: 1.5vh 0;
            }
            
            .time-box {
                width: 60px;
                height: 40px;
                font-size: 30px;
            }
            
            .time-separator {
                font-size: 30px;
            }
            
            .modal {
                max-width: 100%;
                margin: 10px;
            }
            
            .modal-body {
                padding: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .time-box {
                width: 50px;
                height: 35px;
                font-size: 24px;
            }
            
            .time-separator {
                font-size: 24px;
            }
            
            .timer-preview {
                font-size: clamp(3vh, 7vw, 10vh);
                margin: 1vh 0;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button-group button {
                width: 100%;
            }
            
            #message-preview {
                font-size: 3vh;
                max-height: 15vh;
            }
        }
        
        /* Προσθήκη βελτιωμένης υποστήριξης για κινητά 5.5-6 ιντσών */
        @media (max-width: 400px), (max-height: 700px) {
            #message-preview {
                font-size: 2.8vh;
                max-height: 12vh;
                padding: 2px;
                line-height: 1.1;
            }
            
            .preview-logo {
                width: 4vh;
                height: 4vh;
            }
            
            #preview-logo-tl, #preview-logo-bl {
                left: 5px;
            }
            
            #preview-logo-tr, #preview-logo-br {
                right: 5px;
            }
            
            #preview-logo-bl, #preview-logo-bc, #preview-logo-br {
                bottom: 5px;
            }
            
            .timer-preview {
                font-size: clamp(2.5vh, 6vw, 8vh);
                margin: 0.5vh 0;
            }
        }
        
        /* Small mobile screens */
        @media (max-width: 480px) {
            .header-clock {
                font-size: clamp(0.7rem, 1.6vw, 0.9rem);
                padding: clamp(2px, 0.8vw, 4px) clamp(5px, 1.5vw, 7px);
                min-width: clamp(60px, 12vw, 75px);
            }
            
            .live-clock {
                font-size: clamp(0.65rem, 1.7vw, 0.8rem) !important;
                padding: clamp(2px, 0.8vw, 4px) clamp(4px, 1.2vw, 6px) !important;
                min-width: clamp(50px, 10vw, 65px) !important;
            }
            
            
        }
        
        /* Extra small windows - πολύ μικρά παράθυρα */
        @media (max-width: 320px) {
            .timer-preview {
                font-size: clamp(2vh, 5vw, 6vh);
                margin: 0.3vh 0;
            }
            
            .header-clock {
                font-size: clamp(0.6rem, 1.4vw, 0.8rem);
                padding: clamp(2px, 0.6vw, 3px) clamp(4px, 1.2vw, 6px);
                min-width: clamp(55px, 10vw, 65px);
            }
            
            .live-clock {
                font-size: clamp(0.55rem, 1.5vw, 0.7rem) !important;
                padding: clamp(1px, 0.6vw, 3px) clamp(3px, 1vw, 5px) !important;
                min-width: clamp(45px, 8vw, 55px) !important;
            }
            
            
            
            #preview-screen .progress-container {
                height: 10px;
                margin: 0.5vh auto;
                margin-top: -5px;
            }
            
            #preview-screen .progress-container.has-message {
                margin-top: -5px;
                margin-bottom: 5px;
            }
            
            #title-preview {
                padding: 1vh 0;
                font-size: 2.5vh;
            }
            
            .preview-main-content {
                padding: 1vh;
            }
        }
        /* ========== COMPACT MODAL DESIGN ========== */

/* Μείωση κενών στο modal */
.modal-body {
    padding: 15px !important; /* από 20px */
}

.settings-section {
    margin-bottom: 20px !important; /* από 30px */
    padding-bottom: 15px !important; /* από 30px */
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.settings-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.section-title {
    font-size: 1.1rem !important; /* από 1.2rem */
    margin-bottom: 10px !important; /* από 15px */
    color: var(--secondary-color);
}

/* Compact form groups */
.modal .form-group {
    margin-bottom: 10px !important; /* από 15px */
}

.modal .form-group label {
    margin-bottom: 3px !important; /* από 5px */
    font-weight: bold;
    font-size: 0.9rem;
}

.modal .form-group input,
.modal .form-group textarea {
    padding: 6px !important; /* από 8px */
    font-size: 0.9rem;
}

/* Timeline section - 2 στήλες */
.timeline-settings-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    align-items: end;
}

.timeline-input-group {
    display: flex;
    flex-direction: column;
}

.timeline-input-group label {
    font-size: 0.8rem !important;
    margin-bottom: 3px;
    text-align: center;
    color: #3498db;
    font-weight: bold;
}

.timeline-input-group input {
    padding: 8px !important;
    text-align: center;
    font-size: 1.1rem !important;
    font-weight: bold;
}

/* Timer settings - 3 στήλες για HH:MM:SS */
.time-input-container {
    display: grid !important;
    grid-template-columns: 1fr auto 1fr auto 1fr;
    gap: 5px !important;
    align-items: end !important;
    margin: 10px 0 !important; /* από 20px */
}

.time-field {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.time-field label {
    font-size: 0.8rem !important;
    margin-bottom: 3px !important;
}

.time-box {
    width: 70px !important; /* από 100px */
    height: 45px !important; /* από 60px */
    font-size: 32px !important; /* από 50px */
    text-align: center;
    border-radius: 6px;
}

.time-separator {
    font-size: 32px !important; /* από 50px */
    align-self: end;
    margin-bottom: 8px;
}

/* Logo settings - 2 στήλες */
.logo-settings-grid {
    display: grid;
    grid-template-columns: 1fr 200px;
    gap: 20px;
    align-items: start;
}

.logo-upload-section {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.logo-preview-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 5px !important; /* από 10px */
}

/* Position grid - μικρότερο */
.position-grid {
    transform: scale(0.7) !important; /* από 0.8 */
    transform-origin: left top;
}

/* Background color - inline */
.background-color-row {
    display: flex;
    align-items: center;
    gap: 10px;
}

.background-color-row input[type="color"] {
    width: 50px !important; /* από 60px */
    height: 30px !important; /* από 40px */
}

.background-color-row input[type="text"] {
    width: 90px !important; /* από 100px */
    padding: 4px !important;
}

.background-color-row div {
    width: 25px !important; /* από 30px */
    height: 25px !important; /* από 30px */
}

/* Sound settings - inline */
.sound-settings-row {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
}

.volume-control {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
    min-width: 200px;
}

/* Compact buttons */
.modal .button-group {
    display: flex;
    gap: 8px !important; /* από 10px */
    margin-top: 10px !important; /* από 15px */
    flex-wrap: wrap;
}

.modal button {
    padding: 8px 12px !important; /* από 10px 15px */
    font-size: 0.9rem !important; /* από 1rem */
}

/* Responsive για modal */
@media (max-width: 768px) {
    .timeline-settings-grid,
    .logo-settings-grid {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .time-input-container {
        grid-template-columns: 1fr auto 1fr auto 1fr;
        gap: 3px;
    }
    
    .time-box {
        width: 50px !important;
        height: 35px !important;
        font-size: 20px !important;
    }
    
    .background-color-row,
    .sound-settings-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
}
/* Size buttons - κάθετα */
.size-button {
    width: 28px;
    height: 24px;
    padding: 0;
    margin: 0;
    font-size: 14px;
    font-weight: bold;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}
/* ========== QR & SERVER INFO IN MODAL ========== */

/* QR Section στο Modal */
.modal-qr-section {
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    padding: 15px;
    text-align: center;
}

.modal-qr-container {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    flex-wrap: wrap;
}

.modal-qr-code {
    flex: 0 0 auto;
}

.modal-qr-code #qrcode-modal {
    width: 140px !important; /* ΑΥΞΗΣΗ από 120px σε 140px */
    height: 140px !important;
    background-color: white;
    margin: 0 auto;
    border-radius: 5px;
    padding: 8px; /* ΑΥΞΗΣΗ padding από 5px σε 8px */
    box-sizing: border-box; /* ΠΡΟΣΘΗΚΗ για σωστό sizing */
    overflow: hidden; /* ΠΡΟΣΘΗΚΗ για crop protection */
}

/* ΠΡΟΣΘΗΚΗ: Styling για το QR μέσα στο container */
.modal-qr-code #qrcode-modal img,
.modal-qr-code #qrcode-modal canvas {
    max-width: 100% !important;
    max-height: 100% !important;
    width: auto !important;
    height: auto !important;
    display: block;
    margin: 0 auto;
}

.modal-qr-info {
    flex: 1;
    min-width: 200px;
    text-align: left;
}

.modal-timer-url {
    word-break: break-all;
    background-color: rgba(0, 0, 0, 0.3);
    padding: 8px;
    border-radius: 4px;
    font-size: 0.85rem;
    margin: 10px 0;
}

.modal-open-timer-btn {
    background-color: #1a643b !important;
    color: white !important;
    padding: 10px 20px !important;
    border: none !important;
    border-radius: 5px !important;
    font-size: 0.9rem !important;
    cursor: pointer !important;
    text-decoration: none !important;
    display: inline-block !important;
    margin-top: 10px;
    transition: background-color 0.2s;
}

.modal-open-timer-btn:hover {
    background-color: #219955 !important;
}

/* Server Info στο Modal */
.modal-server-info {
    margin-top: 15px;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 5px;
}

.modal-server-info h4 {
    margin-bottom: 10px;
    color: #3498db;
    font-size: 1rem;
}

.modal-server-addresses {
    font-size: 0.85rem;
    line-height: 1.4;
}

.modal-server-addresses div {
    margin-bottom: 8px;
    padding: 5px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

/* Responsive για QR στο modal */
@media (max-width: 768px) {
    .modal-qr-container {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    
    .modal-qr-info {
        text-align: center;
    }
    
    .modal-qr-code #qrcode-modal {
        width: 100px !important;
        height: 100px !important;
    }
}
/* ========== LIVE EVENT TIMELINE FEED ========== */

.event-timeline-feed {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-bottom: 20px;
}

.timeline-feed-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 8px;
    border-radius: 10px;
    position: relative;
    transition: all 0.3s ease;
    border-left: 4px solid transparent;
}

.timeline-feed-item.current-event {
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.15), rgba(192, 57, 43, 0.1));
    border-left-color: #e74c3c;
    box-shadow: 
        0 0 25px rgba(231, 76, 60, 0.4),
        0 0 50px rgba(231, 76, 60, 0.2),
        inset 0 0 15px rgba(231, 76, 60, 0.1);
    animation: gentle-glow 4s ease-in-out infinite;
}
/* Ελαφρύ glow για τρέχον γεγονός */
@keyframes gentle-glow {
    0%, 100% { 
        box-shadow: 
            0 0 25px rgba(231, 76, 60, 0.4),
            0 0 50px rgba(231, 76, 60, 0.2),
            inset 0 0 15px rgba(231, 76, 60, 0.1);
    }
    50% { 
        box-shadow: 
            0 0 35px rgba(231, 76, 60, 0.6),
            0 0 70px rgba(231, 76, 60, 0.3),
            inset 0 0 20px rgba(231, 76, 60, 0.15);
    }
}

.timeline-feed-item.next-event {
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.15), rgba(230, 126, 34, 0.1));
    border-left-color: #f39c12;
    box-shadow: 0 0 15px rgba(243, 156, 18, 0.15);
}

.timeline-feed-item.after-next-event {
    background: linear-gradient(135deg, rgba(39, 174, 96, 0.15), rgba(22, 160, 133, 0.1));
    border-left-color: #27ae60;
    box-shadow: 0 0 15px rgba(39, 174, 96, 0.15);
}

.feed-status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    position: relative;
    flex-shrink: 0;
}

.feed-status-indicator.current {
    background-color: #e74c3c;
    animation: pulse-red 2s infinite;
}

.feed-status-indicator.next {
    background-color: #f39c12;
    animation: pulse-orange 3s infinite;
}

.feed-status-indicator.after-next {
    background-color: #27ae60;
}

@keyframes pulse-red {
    0%, 100% { 
        box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); 
    }
    50% { 
        box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); 
    }
}

@keyframes pulse-orange {
    0%, 100% { 
        box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.7); 
    }
    50% { 
        box-shadow: 0 0 0 8px rgba(243, 156, 18, 0); 
    }
}

.feed-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 5px;
    line-height: 1.2;
}

.feed-label {
    font-size: 0.75rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.9;
}

.feed-title {
    font-size: 0.9rem;
    font-weight: bold;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.feed-time {
    font-size: 0.9rem;
    font-family: 'Courier New', monospace;
    opacity: 0.8;
    font-weight: bold;
}

/* Live Status Bar */
.live-status-bar {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 12px;
    background: linear-gradient(90deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.1));
    border-radius: 8px;
    margin-bottom: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.live-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
    font-weight: bold;
    color: #e74c3c;
}

.live-dot {
    width: 8px;
    height: 8px;
    background-color: #e74c3c;
    border-radius: 50%;
    animation: pulse-red 1.5s infinite;
}

.timeline-progress-mini {
    flex: 1;
    height: 6px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 3px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #27ae60, #f39c12, #e74c3c);
    border-radius: 3px;
    width: 0%;
    transition: width 1s ease;
}

.event-countdown {
    font-size: 0.85rem;
    font-family: 'Courier New', monospace;
    color: #3498db;
    font-weight: bold;
}

/* Compact Devices List */
.devices-compact {
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    overflow: hidden;
}

.devices-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 12px;
    background-color: rgba(0, 0, 0, 0.2);
    cursor: pointer;
    font-size: 0.9rem;
}

.devices-toggle {
    background: none;
    border: none;
    color: white;
    font-size: 0.8rem;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.devices-toggle.expanded {
    transform: rotate(180deg);
}

.devices-list-hidden {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
}

.devices-list-expanded {
    max-height: 200px;
    overflow-y: auto;
    padding: 8px;
}

/* Responsive */
@media (max-width: 768px) {
    .live-status-bar {
        flex-direction: column;
        gap: 8px;
        text-align: center;
    }
    
    .timeline-progress-mini {
        width: 100%;
    }
    
    .feed-title {
        font-size: 1rem;
    }
    
    .timeline-feed-item {
        padding: 12px;
        gap: 12px;
    }
}
/* ========== MODERN DEVICES SECTION ========== */

.devices-section {
    margin-top: 20px;
}

.devices-status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(41, 128, 185, 0.1));
    border-radius: 8px;
    border-left: 4px solid #3498db;
    margin-bottom: 15px;
}

.devices-count-display {
    display: flex;
    align-items: baseline;
    gap: 8px;
}

.devices-count-number {
    font-size: 1.8rem;
    font-weight: bold;
    color: #3498db;
    font-family: 'Courier New', monospace;
}

.devices-count-label {
    font-size: 0.9rem;
    color: #bdc3c7;
    font-weight: normal;
}

.devices-live-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.8rem;
    font-weight: bold;
    color: #27ae60;
}

.devices-live-dot {
    width: 8px;
    height: 8px;
    background-color: #27ae60;
    border-radius: 50%;
    animation: pulse-green 2s infinite;
}

@keyframes pulse-green {
    0%, 100% { 
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7); 
    }
    50% { 
        box-shadow: 0 0 0 8px rgba(39, 174, 96, 0); 
    }
}

.devices-list-modern {
    max-height: 250px;
    overflow-y: auto;
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: 6px;
    padding: 5px;
}

/* Enhanced device items */
.devices-list-modern > div {
    background-color: rgba(255, 255, 255, 0.05) !important;
    margin-bottom: 6px !important;
    padding: 10px !important;
    border-radius: 6px !important;
    border-left: 3px solid #3498db !important;
    transition: all 0.2s ease !important;
}

.devices-list-modern > div:hover {
    background-color: rgba(255, 255, 255, 0.1) !important;
    transform: translateX(2px);
}

/* Server PC highlighting */
.devices-list-modern > div[style*="231, 76, 60"] {
    border-left-color: #e74c3c !important;
    background-color: rgba(231, 76, 60, 0.1) !important;
}

/* Responsive */
@media (max-width: 768px) {
    .devices-status-bar {
        flex-direction: column;
        gap: 8px;
        text-align: center;
    }
    
    .devices-count-display {
        justify-content: center;
    }
    
    .devices-list-modern {
        max-height: 200px;
    }
}
/* ========== INLINE MESSAGE LAYOUT - ΔΙΑΤΗΡΗΣΗ ΠΛΑΤΟΥΣ ========== */

/* Μήνυμα και textarea στην ίδια γραμμή */
.message-inline-layout {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    width: 100%;
    margin-bottom: 10px;
}

/* Label - ΜΟΝΟ όσο χρειάζεται */
.message-inline-label {
    color: var(--text-color);
    font-size: 1rem;
    font-weight: 500;
    white-space: nowrap;
    flex-shrink: 0;
    margin-top: 8px; /* Align με το textarea */
    min-width: auto; /* Αυτόματο πλάτος */
}

/* Textarea - ΣΧΕΔΟΝ ΤΟ ΙΔΙΟ πλάτος όπως πριν */
.message-inline-layout #message-input {
    flex: 1;
    /* Δεν αλλάζουμε τα υπάρχοντα styles του textarea */
    /* Απλά παίρνει όλο τον υπόλοιπο χώρο */
}

/* Responsive - σε μικρές οθόνες κάθετα */
@media (max-width: 768px) {
    .message-inline-layout {
        flex-direction: column;
        align-items: stretch;
    }
    
    .message-inline-label {
        margin-top: 0;
        margin-bottom: 5px;
    }
}

/* ========== ΣΚΟΥΡΟ TEXTAREA STYLING ========== */

/* Επαναφορά του σκούρου styling για το message textarea */
.message-inline-layout #message-input {
    background-color: #2c3e50 !important;
    color: white !important;
    border: 1px solid #34495e !important;
    border-radius: 8px !important;
    padding: 8px 12px !important;
    font-family: Arial, sans-serif !important;
    font-size: 0.85rem !important;
    line-height: 1.4 !important;
    resize: vertical; /* ← ΝΕΑ ΓΡΑΜΜΗ χωρίς !important */
}

/* Focus state για το textarea */
.message-inline-layout #message-input:focus {
    border-color: #3498db !important; /* Μπλε border στο focus */
    box-shadow: 0 0 5px rgba(52, 152, 219, 0.3) !important; /* Ελαφρύ glow */
    outline: none !important;
}

/* Placeholder styling */
.message-inline-layout #message-input::placeholder {
    color: #95a5a6 !important; /* Ανοιχτό γκρι για placeholder */
    opacity: 1 !important;
}
/* ΒΡΕΙΤΕ αυτό το CSS και ΑΛΛΑΞΤΕ τις γραμμές: */

.inline-edit-textarea {
    flex: 1;
    background-color: #34495e !important;
    color: white !important;
    border: 1px solid #3498db !important;
    border-radius: 4px !important;
    padding: 6px !important;
    font-family: Arial, sans-serif !important;
    font-size: 0.8rem !important;              /* ΑΠΟ 0.9rem → 0.8rem */
    line-height: 1.3 !important;               /* ΑΠΟ 1.4 → 1.3 */
    resize: vertical !important;
    min-height: 25px !important;               /* ΑΠΟ 30px → 25px */
    max-height: 80px !important;               /* ΑΠΟ 120px → 80px */
    overflow-y: auto !important;
}
/* ========== MARKER HOVER Z-INDEX FIX ========== */
.event-marker:hover {
    z-index: 1000 !important;
}

.event-marker:hover .marker-tooltip {
    z-index: 9999 !important;
}

        
        /* ========== SECONDARY TIMER STYLES για ADMIN PREVIEW ========== */
        .secondary-timer-preview {
            position: absolute;
            top: 1px;
            right: 0px;
            background-color: rgba(0, 0, 0, 0.911);
            border: 2px solid #e74c3c;
            border-radius: 10px;
            padding: 15px;
            width: 100%;
            height: 95%;
            min-width: 200px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            animation: slideInRight 0.5s ease;
            display: none;
        }
        
        .secondary-timer-title-preview {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .secondary-timer-subtitle-preview {
            font-size: 2rem;
            font-weight: bold;
            color: #ffc400;
            margin-bottom: 15px;
            text-align: center;
            line-height: 0;
        }
        
        .secondary-timer-time-preview {
            font-size: 4rem;
            font-weight: bold;
            color: #36acca;
            margin-bottom: 15px;
            line-height: 1;
        }
        
        .secondary-timer-progress-preview {
            width: 100%;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .secondary-progress-bar-preview {
            height: 100%;
            background: #00cc44;
            border-radius: 4px;
            transition: width 0.3s ease, background-color 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 204, 68, 0.5);
        }
        
        .secondary-progress-bar-preview.warning {
            background: #ff9500;
            box-shadow: 0 0 10px rgba(255, 149, 0, 0.5);
        }
        
        .secondary-progress-bar-preview.danger {
            background: #ff3b30;
            box-shadow: 0 0 10px rgba(255, 59, 48, 0.5);
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .secondary-timer-preview.slide-out {
            animation: slideOutRight 0.8s ease-in-out forwards;
        }
        
        /* Responsive για mobile preview */
        @media (max-width: 768px) {
            .secondary-timer-preview {
                position: absolute;
                top: 10px;
                left: 10px;
                right: 10px;
                padding: 10px;
                height: 70%;
            }
            
            .secondary-timer-title-preview {
                font-size: 1rem;
            }
            
            .secondary-timer-subtitle-preview {
                font-size: 1.2rem;
            }
            
            .secondary-timer-time-preview {
                font-size: 2rem;
            }
        }

        /* 🎯 Easter Egg Animations */
        .timecast-spinning {
            animation: spin 8s linear infinite !important;
        }

        .timecast-glowing circle:first-of-type {
            animation: slowGlow 4s ease-in-out infinite !important;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to   { transform: rotate(360deg); }
        }

        @keyframes slowGlow {
            0%, 100% { 
                stroke: #F2F0EB; 
                filter: drop-shadow(0 0 5px rgba(242, 240, 235, 0.3));
            }
            50% { 
                stroke: #3498db; 
                filter: drop-shadow(0 0 15px rgba(52, 152, 219, 0.8));
            }
        }

        .admin-waves-active circle {
            opacity: 1 !important;
        }
        
        /* ===== GLOSSY CONTROL BUTTONS ===== */
        .control-panel {
            display: inline-block;
            padding: 4px 1px 6px 1px; /* Top Right Bottom Left - +3px πάνω, -3px κάτω */
            margin: 1px;
            background: #284963;
            border-radius: 5px;
            box-shadow:
                inset 0 1px 1.5px rgba(255,255,255,0.1),
                inset 0 -1.5px 1.5px rgba(0,0,0,0.8),
                0 1px 2px rgba(0,0,0,0.6);
        }

        /* Base glossy button */
        .glossy-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 57px; 
            height: 45px; 
            border-radius: 8px; 
            border: 3px solid #111; 
            text-align: center;
            font-weight: bold;
            font-size: 23px; 
            color: #fff;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow:
                inset 0 3px 5px rgba(255,255,255,0.25),
                inset 0 -3px 5px rgba(0,0,0,0.6),
                0 3px 5px rgba(0,0,0,0.7);
            transition: all 0.12s ease-in-out;
            user-select: none;
            border: none;
        }

        /* Small glossy button */
        .glossy-btn-small {
            width: 54px; 
            height: 44px;
            font-size: 15px;
            /* Inherits display: flex, align-items: center, justify-content: center from .glossy-btn */
        }

        /* Plastic texture */
        .glossy-btn::before {
            content: "";
            position: absolute;
            inset: 0;
            background-image:
                repeating-linear-gradient(0deg, rgba(255,255,255,0.15) 0 1px, transparent 1px 2px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.15) 0 1px, transparent 1px 2px);
            opacity: 0.3;
            pointer-events: none;
        }

        /* Glossy reflection */
        .glossy-btn::after {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            right: 3px;
            height: 30%;
            border-radius: 4px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.35), rgba(255,255,255,0));
            pointer-events: none;
        }

        /* Pressed state */
        .glossy-btn:active {
            filter: brightness(1.2);
            box-shadow:
                inset 0 4px 8px rgba(0,0,0,0.8),
                inset 0 -2px 4px rgba(255,255,255,0.15);
            transform: translateY(1px); /* Μειωμένο από 2px σε 1px */
        }

        .glossy-btn-small:active {
            transform: translateY(1px); /* Ίδιο για small buttons */
        }

        /* Color variants */
        .glossy-blue {
            background: radial-gradient(circle at center, #0991eb 20%, #0991eb 90%);
            text-shadow: 0 0 6px rgba(0,255,100,0.9), 0 0 12px rgba(0,255,100,0.7);
        }

        .glossy-red {
            background: radial-gradient(circle at center, #ff3333 20%, #660000 90%);
            text-shadow: 0 0 8px rgba(255,80,80,1), 0 0 16px rgba(255,0,0,0.8);
        }

        .glossy-grey {
            background: radial-gradient(circle at center, #e6e6e6 20%, #666 90%);
            color: #111;
            text-shadow: 0 0 4px rgba(255,255,255,0.6), 0 0 8px rgba(255,255,255,0.4);
        }

        .glossy-orange {
            background: radial-gradient(circle at center, #d45b0b 20%, #d45b0b 90%);
            color: #fff;
            text-shadow: 0 0 4px rgba(255,255,255,0.6), 0 0 8px rgba(255,255,255,0.4);
        }

        .glossy-green {
            background: radial-gradient(circle at center, #209908 20%, #209908 90%);
            color: #fff;
            text-shadow: 0 0 4px rgba(255,255,255,0.6), 0 0 8px rgba(255,255,255,0.4);
        }

        /* Responsive Glossy Controls Container */
        .glossy-controls-container {
            max-width: 600px !important; /* Same as preview-main-content */
            min-width: 461px !important;
            margin: 5px auto !important; /* Center horizontally */
            width: 100% !important;
        }

        .glossy-controls-row {
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
            width: 100% !important;
        }

        /* LCD Strip Container */
        .lcd-container {
            max-width: 600px !important; /* Same as preview-main-content */
            min-width: 461px !important;
            margin: 5px auto !important; /* Center horizontally */
            width: 100% !important;
            display: flex;
            justify-content: center;
        }

        /* LCD Panel (σασί γύρω από την οθόνη) */
        .lcd-panel {
            display: inline-block;
            padding: 5px;
            background: #284963;
            border-radius: 2px;
            box-shadow:
                inset 0 2px 3px rgba(255,255,255,0.1),
                inset 0 -3px 3px rgba(0,0,0,0.8),
                0 2px 4px rgba(0,0,0,0.6);
        }

        /* LCD Strip */
        .lcdstrip {
            position: relative;
            width: 480px;
            height: 62px;
            background: #193d91;
            border-radius: 2px;
            overflow: hidden;
            box-shadow:
                inset 0 1px 2px rgba(255,255,255,0.1),
                inset 0 -1px 2px rgba(0,0,0,0.8);
            
            /* Dot matrix pixel pattern */
            background-image:
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 2px 2px;
        }

        /* LCD Overlay gloss */
        .lcdstrip::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, rgba(255,255,255,0.08), rgba(0,0,0,0.05));
            pointer-events: none;
        }

        /* LCD Text Items */
        .lcd-item {
            position: absolute;
            color: #0ff;
            font-family: "Courier New", monospace;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow:
                0 0 2px rgba(0,255,255,0.8),
                0 0 4px rgba(0,255,255,0.4);
            white-space: nowrap;
            image-rendering: pixelated;
            top: 50%;
            transform: translateY(-50%);
        }

        /* LCD Item positions */
        .lcd-item.segment1 { left: 20px; }
        .lcd-item.segment2 { left: 140px; }
        .lcd-item.segment3 { left: 260px; }
        .lcd-item.segment4 { right: 20px; }

        
    </style>
</head>
<body>
    <div class="header">
    <div class="logo-container">
        <svg id="timecast-logo" width="40" height="40" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="margin-right: 4px; cursor: pointer;">
            <defs>
                <!-- ClipPath που περιορίζει τα κύματα μέσα στην κλεψύδρα -->
                <clipPath id="hourglassClipAdmin">
                    <path d="M25,20 L75,20 L50,50 L75,80 L25,80 L50,50 Z" />
                </clipPath>
            </defs>
            
            <!-- Περίγραμμα κύκλου -->
            <circle cx="50" cy="50" r="48" fill="none" stroke="#F2F0EB" stroke-width="3" />
            
            <!-- Περίγραμμα κλεψύδρας -->
            <path d="M25,20 L75,20 L50,50 L75,80 L25,80 L50,50 Z"
                  fill="none" stroke="#F2F0EB" stroke-width="1.6" />
            
            <!-- Ομάδα κυμάτων (αρχικά κρυφά) -->
            <g id="admin-waves" clip-path="url(#hourglassClipAdmin)" style="display: none;">
                <!-- Κύμα 1 -->
                <circle cx="50" cy="50" r="2" fill="none" stroke="#F2F0EB" stroke-width="1" opacity="0">
                    <animate attributeName="r" values="2;22" dur="3s" begin="0s" repeatCount="indefinite" />
                    <animate attributeName="opacity" values="1;0" dur="7s" begin="0s" repeatCount="indefinite" />
                </circle>
                <!-- Κύμα 2 -->
                <circle cx="50" cy="50" r="2" fill="none" stroke="#F2F0EB" stroke-width="1" opacity="0">
                    <animate attributeName="r" values="2;22" dur="3s" begin="0.6s" repeatCount="indefinite" />
                    <animate attributeName="opacity" values="1;0" dur="7s" begin="1s" repeatCount="indefinite" />
                </circle>
                <!-- Κύμα 3 -->
                <circle cx="50" cy="50" r="2" fill="none" stroke="#F2F0EB" stroke-width="1" opacity="0">
                    <animate attributeName="r" values="2;22" dur="3s" begin="1.2s" repeatCount="indefinite" />
                    <animate attributeName="opacity" values="1;0" dur="7s" begin="2s" repeatCount="indefinite" />
                </circle>
                <!-- Κύμα 4 -->
                <circle cx="50" cy="50" r="2" fill="none" stroke="#F2F0EB" stroke-width="1" opacity="0">
                    <animate attributeName="r" values="2;22" dur="3s" begin="1.8s" repeatCount="indefinite" />
                    <animate attributeName="opacity" values="1;0" dur="7s" begin="4s" repeatCount="indefinite" />
                </circle>
            </g>
        </svg>
        <span style="color: #F2F0EB; font-size: 16px; font-weight: 500; letter-spacing: 0.5px;">TimeCast™</span>
    </div>
    
    <div class="timeline-container">
    <!-- Κουτάκι Έναρξης - μικρότερο -->
    <div style="display: flex; align-items: center; margin-right: 2px;">
        <div style="background-color: rgba(52, 152, 219, 0.15); border: 1px solid #3498db; border-radius: 4px; padding: 3px 6px; text-align: center; min-width: 45px;">
            <div style="font-size: 0.7rem; font-weight: bold; color: #3498db; text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 1px;">
                <span data-i18n="timeline.start">ΕΝΑΡΞΗ</span>
            </div>
            <div class="timeline-time-display" id="timeline-start-display" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #3498db; font-weight: bold; background: none; border: none; padding: 0; box-shadow: none; line-height: 1;">
                09:00
            </div>
        </div>
    </div>
    
    <!-- Timeline Bar - πιο κοντά -->
<div class="timeline-bar-container" id="timeline-bar" style="flex: 1; height: 20px; position: relative; background: linear-gradient(90deg, rgba(39, 174, 96, 0.2) 0%, rgba(243, 156, 18, 0.2) 80%, rgba(231, 76, 60, 0.3) 100%); border-radius: 10px; border: 2px solid rgba(52, 152, 219, 0.5); cursor: pointer; overflow: visible; min-width: 200px; margin: 0 -10px; margin-top: 20px;">
        <!-- Progress bar -->
        <div class="timeline-progress" id="timeline-progress" style="height: 100%; background-color: #00a123; border-radius: 18px; width: 100%; transition: none; position: relative; transform-origin: right;"></div>
        
        <!-- Tooltip και markers -->
        <div class="timeline-tooltip" id="timeline-tooltip">10:30</div>
        
    </div>
    
    <!-- Κουτάκι Λήξης - μικρότερο -->
    <div style="display: flex; align-items: center; margin-left: 8px;">
        <div style="background-color: rgba(52, 152, 219, 0.15); border: 1px solid #3498db; border-radius: 4px; padding: 3px 6px; text-align: center; min-width: 45px;">
            <div style="font-size: 0.7rem; font-weight: bold; color: #3498db; text-transform: uppercase; letter-spacing: 0.3px; margin-bottom: 1px;">
                <span data-i18n="timeline.end">ΛΗΞΗ</span>
            </div>
            <div class="timeline-time-display" id="timeline-end-display" style="font-family: 'Courier New', monospace; font-size: 0.9rem; color: #3498db; font-weight: bold; background: none; border: none; padding: 0; box-shadow: none; line-height: 1;">
                20:00
            </div>
        </div>
    </div>
</div>
    
    <div class="header-controls">
        <button class="settings-btn" onclick="openSettings()" data-i18n="settings.button">
            ⚙️ Ρυθμίσεις
        </button>
        <div class="connection-status" id="connection-status">
    <div class="led-indicator" id="led-indicator"></div>
    <button class="fullscreen-btn" id="fullscreen-btn" onclick="toggleAdminFullscreen()" title="Εναλλαγή Fullscreen (⛶)">
        ⛶
    </button>
</div>
        </div>
    </div>
</div>
    
    <div class="container">
        <!-- Πάνελ Προεπισκόπησης & Ελέγχου -->
        <div class="panel">
            <div style="display: flex; align-items: center; justify-content: flex-start; gap: 8px; padding: 8px; background-color: rgba(52, 152, 219, 0.1); border: 2px solid #3498db; border-radius: 8px; margin: 0 auto 10px auto; flex-wrap: wrap; max-width: 900px">
    
    <!-- Τίτλος αριστερά -->
    <div style="font-size: 1rem; font-weight: bold; color: #3498db; white-space: nowrap;">
        <span data-translate="timerSettings">Ρυθμίσεις Χρονομέτρου:</span>
    </div>
    
    <!-- ΩΡ -->
    <div style="display: flex; align-items: center; gap: 5px;">
        <label style="font-weight: bold; color: #0099ff; font-size: 0.9rem;" data-translate="hours">ΩΡ</label>
        <input type="number" id="main-timer-hours" min="0" max="99" value="0" 
               style="width: 55px; height: 40px; font-size: 30px; text-align: center; background-color: #001a33; color: #00ddfa; border: 1px solid #555; border-radius: 4px; font-weight: bold;">
    </div>
    
    <!-- Διαχωριστικό : -->
    <span style="font-size: 20px; font-weight: bold; color: #3498db;">:</span>
    
    <!-- ΛΕΠ -->
    <div style="display: flex; align-items: center; gap: 5px;">
        <label style="font-weight: bold; color: #0099ff; font-size: 0.9rem;" data-translate="minutes">ΛΕΠ</label>
        <input type="number" id="main-timer-minutes" min="0" max="59" value="15" 
               style="width: 55px; height: 40px; font-size: 30px; text-align: center; background-color: #001a33; color: #00ddfa; border: 1px solid #555; border-radius: 4px; font-weight: bold;">
    </div>
    
    <!-- Διαχωριστικό : -->
    <span style="font-size: 20px; font-weight: bold; color: #3498db;">:</span>
    
    <!-- ΔΕΥ -->
    <div style="display: flex; align-items: center; gap: 5px;">
        <label style="font-weight: bold; color: #0099ff; font-size: 0.9rem;" data-translate="seconds">ΔΕΥ</label>
        <input type="number" id="main-timer-seconds" min="0" max="59" value="0" 
               style="width: 55px; height: 40px; font-size: 30px; text-align: center; background-color: #001a33; color: #00ddfa; border: 1px solid #555; border-radius: 4px; font-weight: bold;">
    </div>
    
    <!-- Κάθετη γραμμή διαχωρισμού -->
    <div style="width: 1px; height: 25px; background-color: #3498db; margin: 0 5px;"></div>
    
    <!-- Προειδοποίηση -->
    <div style="display: flex; align-items: center; gap: 5px;">
        <label style="font-weight: bold; color: #f39c12; font-size: 0.9rem; white-space: nowrap;" data-translate="warningLabel">Προειδοποίηση (δευτ.):</label>
        <input type="number" id="main-warning-threshold" min="0" value="60" 
               style="width: 50px; height: 32px; font-size: 14px; text-align: center; background-color: #34495e; color: #f39c12; border: 1px solid #f39c12; border-radius: 4px; font-weight: bold;">
    </div>
    
    <!-- Κουμπί Εφαρμογή -->
    <button onclick="applyMainTimerSettings()" 
            style="background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; border: none; padding: 8px 16px; border-radius: 5px; font-size: 0.95rem; font-weight: bold; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;"
           >
        <span data-translate="applyBtn">Εφαρμογή</span>
    </button>
    
</div>
            
            <!-- Preview that looks like the timer screen -->
            <div id="preview-screen">
                <div id="title-preview">TimeCast® Pro Conference Timer</div>
                
                <div class="preview-main-content">
                    <!-- Λογότυπα προεπισκόπησης -->
                    <div id="preview-logo-tl" class="preview-logo"></div>
                    <div id="preview-logo-tc" class="preview-logo"></div>
                    <div id="preview-logo-tr" class="preview-logo"></div>
                    <div id="preview-logo-bl" class="preview-logo"></div>
                    <div id="preview-logo-bc" class="preview-logo"></div>
                    <div id="preview-logo-br" class="preview-logo"></div>
        
                    <!-- Τμήμα χρονομέτρου -->
                    <div class="timer-section">
                        <div class="timer-preview" id="timer-preview">15:00</div>
                        
                        <div class="progress-container">
                            <div class="progress-bar" id="preview-progress-bar"></div>
                        </div>
                    </div>
                    
                    <!-- Τμήμα μηνύματος -->
                    <div class="message-section">
                        <div id="message-container-preview">
                            <div id="message-preview"></div>
                        </div>
                    </div>
                    
                    <!-- vMix Video Timer για Preview -->
                    <div class="secondary-timer-preview" id="secondary-timer-preview" style="display: none;">
                        <div class="secondary-timer-title-preview" id="secondary-timer-title-preview">Video Title</div>
                        <div class="secondary-timer-subtitle-preview">Τέλος Βίντεο σε:</div>
                        <div class="secondary-timer-time-preview" id="secondary-timer-time-preview">00:00</div>
                        <div class="secondary-timer-progress-preview" id="secondary-timer-progress-preview">
                            <div class="secondary-progress-bar-preview" id="secondary-progress-bar-preview"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Glossy Control Buttons Container -->
            <div class="glossy-controls-container" style="
                display: flex; 
                justify-content: center; 
                align-items: center; 
                padding: 1px 5px;
                background: rgba(44, 62, 80, 0.1);
                border-radius: 10px;
                box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            ">
                <div class="glossy-controls-row">
                    <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-orange" onclick="adjustTime(-600)">-10</button></div>
                    <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-orange" onclick="adjustTime(-300)">-5</button></div>
                    <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-orange" onclick="adjustTime(-60)">-1</button></div>
                    <div class="control-panel"><button id="start-pause" class="glossy-btn glossy-blue" onclick="startPauseTimer()">▶</button></div>
                    <div class="control-panel"><button class="glossy-btn glossy-red" onclick="resetTimer()">⏮</button></div>
                    <div class="control-panel"><button id="flash-alert" class="glossy-btn glossy-grey" onclick="triggerFlash()" title="Flash Alert">⚡</button></div>
                    <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-green" onclick="adjustTime(60)">+1</button></div>
                    <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-green" onclick="adjustTime(300)">+5</button></div>
                    <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-green" onclick="adjustTime(600)">+10</button></div>
                </div>
            </div>
            
            <!-- LCD Strip Module (External) -->
            <div style="text-align: center; margin: 5px 0;">
                <iframe src="lcdstrip.html" 
                        width="460" 
                        height="90" 
                        frameborder="0" 
                        scrolling="no"
                        style="border-radius: 4px; background: transparent;">
                </iframe>
            </div>
            
           <!-- Μήνυμα με κουμπιά inline -->
<div style="margin-bottom: 3px;">
    <div style="display: flex; align-items: flex-start; gap: 8px;">
        <textarea id="message-input" placeholder="Εισάγετε μήνυμα προς εμφάνιση" style="
            flex: 1; 
            resize: vertical; 
            min-height: 80px;
            background-color: #2c3e50 !important;
            color: white !important;
            border: 1px solid #34495e !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
        " 
        onfocus="this.style.borderColor='#3498db'; this.style.boxShadow='0 0 5px rgba(52, 152, 219, 0.3)'"
        onblur="this.style.borderColor='#34495e'; this.style.boxShadow='none'"></textarea>
        <div style="display: flex; gap: 5px;">
            <div class="control-panel"><button id="toggle-message-btn" onclick="toggleMessageVisibility()" class="glossy-btn glossy-btn-small glossy-blue message-toggle-btn message-hidden" title="Send Message">📤</button></div>
            <div class="control-panel"><button class="glossy-btn glossy-btn-small glossy-red" onclick="clearMessage()" title="Clear Message">🗑️</button></div>
            <div class="control-panel"><button onclick="saveMessage()" class="glossy-btn glossy-btn-small glossy-green save-message-btn" title="Save Message">💾</button></div>
        </div>
    </div>
</div>

            
            <div class="panel-title" style="margin-top: 10px;" data-i18n="messages.savedMessages">Αποθηκευμένα Μηνύματα</div>
            
            <div class="messages-list" id="messages-list">
                <!-- Saved messages will appear here -->
            </div>
            
        </div>
        
        <!-- Live Event Timeline Feed -->
<div class="panel">
    <!-- ΝΕΟ layout με ρολόι δεξιά: -->
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
    <div class="panel-title" style="margin: 0;">📡 Live Event Timeline</div>
    <div style="display: flex; align-items: center; gap: 10px;">
        <div style="display: flex; align-items: center; gap: 5px; font-size: 0.9rem;">
            <input type="checkbox" id="clock-mode-toggle" style="margin: 0;">
            <label for="clock-mode-toggle" style="margin: 0; color: #666; white-space: nowrap;" data-i18n="clockMode.label">Προβολή ώρας</label>
        </div>
        <div class="header-clock live-clock" style="color: white; font-family: 'Courier New', monospace; font-weight: bold; background: rgba(52, 152, 219, 0.1); border-radius: 6px; border: 1px solid white; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; font-size: 0.9rem; padding: 4px 8px; min-width: 75px; max-width: 80px;">
            <div id="header-time" style="font-size: 0.9rem;">00:00:00</div>
        </div>
    </div>
</div>
    
    <div class="event-timeline-feed">
    <!-- Τρέχον Γεγονός -->
    <div class="timeline-feed-item current-event">
        <div class="feed-status-indicator current"></div>
        <div class="feed-content-inline">
            <span class="feed-label" data-translate="currentEvent"> ΤΡΕΧΟΝ ΓΕΓΟΝΟΣ:</span>
            <span class="feed-time" id="current-event-time">--:--</span>
            <span class="feed-title" id="current-event-title" data-translate="waitingStart">Αναμονή εκκίνησης...</span>
        </div>
    </div>
    
    <!-- Επόμενο Γεγονός -->
    <div class="timeline-feed-item next-event">
        <div class="feed-status-indicator next"></div>
        <div class="feed-content-inline">
            <span class="feed-label" data-translate="nextEvent"> ΕΠΟΜΕΝΟ ΓΕΓΟΝΟΣ:</span>
            <span class="feed-time" id="next-event-time">--:--</span>
            <span class="feed-title" id="next-event-title" data-translate="noNext">Δεν υπάρχει επόμενο</span>
        </div>
    </div>
    
    <!-- Μεθεπόμενο Γεγονός -->
    <div class="timeline-feed-item after-next-event">
        <div class="feed-status-indicator after-next"></div>
        <div class="feed-content-inline">
            <span class="feed-label" data-translate="afterNext"> ΚΑΙ ΜΕΤΑ:</span>
            <span class="feed-time" id="after-next-event-time">--:--</span>
            <span class="feed-title" id="after-next-event-title" data-translate="noAfterNext">Δεν υπάρχει μεθεπόμενο</span>
        </div>
    </div>
</div>
    
   
    
    <!-- Connected Devices - Full με compact header -->
<div class="devices-section">
    <div class="panel-title" style="margin-top: 20px; margin-bottom: 15px;" data-translate="connectedDevices">📱 Συνδεδεμένες Συσκευές</div>
    
    <div class="devices-status-bar">
        <div class="devices-count-display">
            <span class="devices-count-number" id="devices-count">0</span>
            <span class="devices-count-label" data-translate="devicesOnline">συσκευές online</span>
        </div>
        <div class="devices-live-indicator">
            <div class="devices-live-dot"></div>
            <span>LIVE</span>
        </div>
    </div>
    
    <div id="devices-list" class="devices-list-modern">
        <!-- Η λίστα συσκευών θα εμφανιστεί εδώ -->
    </div>
</div>
    
     <!-- Settings Modal -->
<div class="modal-overlay" id="settings-modal">
    <div class="modal">
        <div class="modal-header">
            <h2 class="modal-title" data-i18n="modal.title">Ρυθμίσεις</h2>
            <button class="modal-close" onclick="closeSettings()">×</button>
        </div>
        <div class="modal-body">
            <!-- Event Timeline Settings -->
            <div class="settings-section" style="background-color: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 8px; padding: 15px;">
                <div style="border: 2px solid #3498db; border-radius: 8px; padding: 12px; background-color: rgba(52, 152, 219, 0.1); margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span style="color: #3498db; font-weight: bold;" data-i18n="timeline.startTime">🕘 Έναρξη:</span>
                        <input type="time" id="event-start-time-settings" value="09:00" style="width: 80px;">
                        <span style="color: #3498db; font-weight: bold;" data-i18n="timeline.endTime">🕔 Λήξη:</span>
                        <input type="time" id="event-end-time-settings" value="17:00" style="width: 80px;">
                        <button onclick="applyTimelineSettings()" style="background-color: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-size: 0.9rem; white-space: nowrap;" data-i18n="timeline.apply">Εφαρμογή</button>
                        <span id="event-duration-display" style="color: #3498db; font-weight: bold; font-size: 0.9rem;" data-i18n="timeline.duration">⏱️ Διάρκεια: 8 ώρες</span>
                    </div>
                </div>
            </div>


           <!-- Display Settings -->
<div class="settings-section">
    <h3 class="section-title" data-i18n="settings.displaySettings">Ρυθμίσεις Εμφάνισης</h3>
    
    <!-- Responsive containers για display settings -->
    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
        
        <!-- Container 1: Τίτλος, Χρώμα, Γραμματοσειρά -->
        <div style="flex: 11; min-width: 400px; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
            
            <!-- Τίτλος -->
            <div class="form-group" style="margin-bottom: 15px;">
                <label for="title-input" data-i18n="display.title">Τίτλος:</label>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <input type="text" id="title-input" placeholder="Εισάγετε τίτλο" style="width: 100%; max-width: 350px; background: white; color: black;">
                    <div style="display: flex; flex-direction: column; gap: 3px;">
                        <button class="size-button" onclick="changeTitleSize(1)">+</button>
                        <button class="size-button" onclick="changeTitleSize(-1)">−</button>
                    </div>
                </div>
            </div>
            
            <!-- Χρώμα Φόντου & Γραμματοσειρά -->
            <div class="form-group">
                <div style="display: flex; gap: 20px; align-items: flex-start; flex-wrap: wrap;">
                    <!-- Χρώμα Φόντου -->
                    <div style="flex: 1; min-width: 150px;">
                        <label data-i18n="display.backgroundColor">Χρώμα Φόντου:</label>
                        <div class="background-color-compact">
                            <input type="color" id="background-color" value="#2c3e50">
                        </div>
                    </div>
                    
                    <!-- Γραμματοσειρά Timer -->
                    <div style="flex: 1; min-width: 180px;">
                        <label for="timer-font-family" style="font-size: 0.9rem; color: #bdc3c7; display: block; margin-bottom: 5px;" data-i18n="display.timerFont">Γραμματοσειρά Timer:</label>
                        <select id="timer-font-family" onchange="updateDisplayPreview()" style="width: 100%; padding: 6px; font-size: 0.85rem;">
                            <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">📝 Segoe UI (Κανονικό)</option>
                            <option value="'Courier New', monospace">🕐 Courier New (Ψηφιακό Ρολόι)</option>
                            <option value="Arial, sans-serif">📄 Arial</option>
                            <option value="'Times New Roman', serif">📰 Times New Roman</option>
                            <option value="'Trebuchet MS', sans-serif">🎯 Trebuchet MS</option>
                            <option value="'Verdana', sans-serif">✨ Verdana</option>
                            <option value="'Consolas', monospace">⌨️ Consolas (Monospace)</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Container 2: Λογότυπο -->
        <div style="flex: 9; min-width: 350px; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
            
            <div class="form-group">
                <label data-i18n="display.logo">Λογότυπο:</label>
                
                <!-- Επιλογή αρχείου -->
                <div style="margin-bottom: 12px;">
                    <input type="file" id="logo-file" accept="image/*" onchange="previewLogo(this)" style="display: none;">
                    <button onclick="document.getElementById('logo-file').click()" style="padding: 8px 12px; font-size: 0.9rem; margin-right: 10px;" data-i18n="display.selectFile">Επιλογή Αρχείου</button>
                    <span id="logo-name" style="font-size: 0.85rem; color: #bdc3c7;" data-i18n="display.noFileSelected">Δεν έχει επιλεγεί αρχείο</span>
                </div>
                
                <!-- Logo preview και θέσεις -->
                <div style="display: flex; align-items: flex-start; gap: 30px; flex-wrap: wrap;">
                    <!-- Logo με controls -->
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                        <div class="logo-preview-fixed">
                            <img id="logo-preview" src="" style="display: none;">
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <button class="size-button" onclick="changeLogoSize(1)">+</button>
                            <button class="size-button" onclick="changeLogoSize(-1)">−</button>
                        </div>
                    </div>
                    
                    <!-- Θέσεις λογότυπου -->
                    <div style="flex-shrink: 0;">
                        <label style="font-size: 0.8rem; margin-bottom: 6px; display: block; color: #bdc3c7;" data-i18n="display.logoPositions">Θέσεις λογοτύπου:</label>
                        <div class="position-grid">
                            <div class="position-row">
                                <div class="position-cell">
                                    <input type="radio" name="logo-position" id="logo-tl" value="top-left" checked>
                                    <label for="logo-tl" class="position-label top-left"></label>
                                </div>
                                <div class="position-cell">
                                    <input type="radio" name="logo-position" id="logo-tc" value="top-center">
                                    <label for="logo-tc" class="position-label top-center"></label>
                                </div>
                                <div class="position-cell">
                                    <input type="radio" name="logo-position" id="logo-tr" value="top-right">
                                    <label for="logo-tr" class="position-label top-right"></label>
                                </div>
                            </div>
                            <div class="position-row">
                                <div class="position-cell">
                                    <input type="radio" name="logo-position" id="logo-bl" value="bottom-left">
                                    <label for="logo-bl" class="position-label bottom-left"></label>
                                </div>
                                <div class="position-cell">
                                    <input type="radio" name="logo-position" id="logo-bc" value="bottom-center">
                                    <label for="logo-bc" class="position-label bottom-center"></label>
                                </div>
                                <div class="position-cell">
                                    <input type="radio" name="logo-position" id="logo-br" value="bottom-right">
                                    <label for="logo-br" class="position-label bottom-right"></label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Container 3: Ρυθμίσεις Ήχου -->
    <div style="width: 100%; margin-top: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 15px;">
        <h4 style="margin: 0 0 15px 0; color: #3498db; font-size: 1.1rem;" data-i18n="audio.title">🔊 Ρυθμίσεις Ήχου</h4>
        
        <div class="sound-settings-compact">
            <div class="checkbox-item">
                <input type="checkbox" id="sound-enabled" checked>
                <label data-i18n="audio.sound">Ήχος</label>
            </div>
            <div class="sound-volume-compact">
                <label data-i18n="audio.volume">Ένταση:</label>
                <input type="range" id="sound-volume" min="0" max="1" step="0.1" value="0.7">
            </div>
        </div>
    </div>
    
    <!-- Κεντρικό κουμπί εφαρμογής -->
    <div style="width: 100%; margin-top: 20px; text-align: center;">
        <button onclick="applyDisplaySettings(); applySoundSettings();" 
                style="width: 100%; max-width: 500px; padding: 15px 20px; background: #3498db; color: white; border: none; border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: background 0.3s;">
            <span data-i18n="settings.applyDisplayAudio">🎨 Εφαρμογή Ρυθμίσεων Εμφάνισης και Ήχου</span>
        </button>
    </div>
</div>

            <!-- Timeline Import Tabs -->
<div class="settings-section" style="background-color: rgba(255, 255, 255, 0.06); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 8px; padding: 15px;">
    
    <!-- Tab Headers -->
    <div style="display: flex; margin-bottom: 20px; border-bottom: 2px solid rgba(255,255,255,0.1);">
        <button id="excel-tab" onclick="switchTimelineTab('excel')" 
                style="flex: 1; padding: 12px 20px; background: #27ae60; color: white; border: none; border-radius: 8px 8px 0 0; cursor: pointer; font-weight: bold; margin-right: 2px;">
            <span data-i18n="excel.importTimeline">📊 Εισαγωγή Χρονοσειράς από Excel</span>
        </button>
        <button id="google-tab" onclick="switchTimelineTab('google')" 
                style="flex: 1; padding: 12px 20px; background: rgba(255,255,255,0.1); color: #bdc3c7; border: none; border-radius: 8px 8px 0 0; cursor: pointer; font-weight: bold;">
            <span data-i18n="google.importTimeline">📋 Εισαγωγή Χρονοσειράς από Google Docs</span>
        </button>
    </div>
    
    <!-- Excel Tab Content -->
    <div id="excel-tab-content" style="display: block;">
        <div style="border: 2px solid #27ae60; border-radius: 8px; padding: 15px; background-color: rgba(39, 174, 96, 0.1);">
            <div style="display: flex; justify-content: flex-end; align-items: center; margin-bottom: 15px;">
                <div id="current-file-display" style="display: none;">
                    <span id="current-file-name" style="font-size: 0.9rem; color: #27ae60;"></span>
                    <span id="current-file-path" style="display: none;"></span>
                </div>
            </div>
            
            <input type="file" id="excel-file-input" accept=".xlsx,.xls" style="display: none;">
            
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px; flex-wrap: wrap;">
                <button type="button" onclick="selectExcelFile()" class="btn btn-primary" data-i18n="excel.importButton">📂 Εισαγωγή Χρονοσειράς</button>
                <button type="button" onclick="clearExcelData()" class="btn btn-danger" data-i18n="excel.clearButton">🗑️ Καθαρισμός</button>
                <button type="button" onclick="exportCurrentTimeline()" class="btn btn-primary" data-i18n="excel.exportButton">📤 Εξαγωγή Χρονοσειράς</button>
                <button type="button" onclick="showExcelStatus()" class="btn btn-info" data-i18n="excel.detailsButton">📋 Λεπτομέρειες</button>
            </div>
            
            <div id="excel-status-modal" style="font-size: 0.9rem; color: #27ae60;">❌ Κανένα αρχείο Excel δεν έχει φορτωθεί</div>
        </div>
    </div>
    
    <!-- Google Sheets Tab Content -->
    <div id="google-tab-content" style="display: none;">
        <div style="border: 2px solid #e74c3c; border-radius: 8px; padding: 15px; background-color: rgba(231, 76, 60, 0.1);">
            
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                <input type="url" id="sheets-url-input" placeholder="https://docs.google.com/spreadsheets/d/..." 
                       style="flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #ccc; background-color: white; color: black;">
                <button type="button" onclick="connectToGoogleSheets()" class="btn btn-info" data-i18n="google.connect">🔗 Σύνδεση</button>
                <button type="button" onclick="refreshFromGoogleSheets()" class="btn btn-secondary" data-i18n="google.refresh">🔄 Ανανέωση</button>
                <button type="button" onclick="disconnectFromGoogleSheets()" class="btn btn-danger" data-i18n="google.disconnect">🔌 Αποσύνδεση</button>
            </div>
            
            <!-- Google Sheets Status -->
            <div id="google-sheets-status-display" style="padding: 10px; background-color: rgba(231, 76, 60, 0.15); border-radius: 4px; font-size: 0.9rem; color: #e74c3c;">
                ❓ Κανένα Google Sheets αρχείο συνδεδεμένο
            </div>
        </div>
    </div>
</div>


<style>
/* Current File Display */
.current-file-info {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    padding: 8px 12px;
    margin: 5px 0;
}

.current-file-info.has-file {
    background: rgba(40, 167, 69, 0.1);
    border-color: #28a745;
    color: #28a745;
}

.current-file-info.no-file {
    background: rgba(255, 193, 7, 0.1);
    border-color: #ffc107;
    color: #ffc107;
}

/* Import Controls */
.import-controls, .export-controls {
    display: flex;
    gap: 10px;
    margin: 8px 0;
    flex-wrap: wrap;
}

/* Excel Status στο Modal */
.excel-status {
    margin: 8px 0;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    font-size: 0.85rem;
    color: #bbb;
    border-left: 3px solid #666;
}

.excel-status.active {
    background: rgba(40, 167, 69, 0.1);
    color: #28a745;
    border-left-color: #28a745;
}

.excel-status.error {
    background: rgba(220, 53, 69, 0.1);
    color: #dc3545;
    border-left-color: #dc3545;
}

.excel-status.warning {
    background: rgba(255, 193, 7, 0.1);
    color: #ffc107;
    border-left-color: #ffc107;
}

.excel-status.monitoring {
    background: rgba(23, 162, 184, 0.1);
    color: #17a2b8;
    border-left-color: #17a2b8;
}

/* Button styling για το modal */
.modal .btn {
    background: var(--secondary-color);
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
    margin-right: 8px;
    margin-bottom: 8px;
}

.modal .btn:hover {
    background: #2980b9;
    transform: translateY(-1px);
}

.modal .btn-primary {
    background: #007bff;
}

.modal .btn-primary:hover {
    background: #0056b3;
}

.modal .btn-secondary {
    background: #6c757d;
}

.modal .btn-secondary:hover {
    background: #5a6268;
}

.modal .btn-info {
    background: #17a2b8;
}

.modal .btn-info:hover {
    background: #138496;
}

.modal .btn-success {
    background: #28a745;
}

.modal .btn-success:hover {
    background: #218838;
}

</style>
            
            
            

            <!-- QR & Connection Section -->
            <div class="settings-section">
                <h3 class="section-title" data-i18n="settings.connectionQR">Σύνδεση & QR Code</h3>
                
                <div style="background-color: rgba(0, 0, 0, 0.1); border-radius: 8px; padding: 12px; text-align: center;">
                    
                    <!-- QR Codes Tabs -->
                    <div class="qr-tabs-container" style="margin-bottom: 15px;">
                        <div class="qr-tabs" style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button class="qr-tab active" onclick="switchQRTab('timer')" data-tab="timer">🕒 Timer</button>
                            <button class="qr-tab" onclick="switchQRTab('admin')" data-tab="admin">⚙️ Admin Panel</button>
                            <button class="qr-tab" onclick="switchQRTab('questions-admin')" data-tab="questions-admin">🎛️ Q&A Admin</button>
                            <button class="qr-tab" onclick="switchQRTab('questions-form')" data-tab="questions-form">📝 Q&A Form</button>
                            <button class="qr-tab" onclick="switchQRTab('questions-qr')" data-tab="questions-qr">📱 Q&A QR</button>
                        </div>
                    </div>
                    
                    <!-- MAIN CONTAINER: QR SECTION + SERVER INFO SIDE BY SIDE -->
                    <div style="display: flex; gap: 30px; align-items: flex-start;">
                        
                        <!-- ΑΡΙΣΤΕΡΑ: QR CODE ΚΑΙ ΚΟΥΜΠΙΑ -->
                        <div style="display: flex; flex-direction: column; align-items: flex-start; gap: 15px;">
                            <!-- QR CODE -->
                            <div class="modal-qr-code">
                                <div id="qrcode-modal"></div>
                            </div>
                            
                            <!-- ΚΟΥΜΠΙΑ ΚΑΤΩ ΑΠΟ QR -->
                            <div style="display: flex; flex-direction: column; gap: 10px; align-items: flex-start;">
                                <!-- Timer buttons -->
                                <div id="timer-buttons" class="qr-buttons">
                                    <a href="timer.html" target="_blank" class="modal-open-timer-btn" style="margin: 0; text-align: center;">
                                        <span data-i18n="qr.openTimer">🌐 Άνοιγμα Timer</span>
                                    </a>
                                    <button id="hdmi-timer-btn" class="modal-open-timer-btn" onclick="toggleHDMITimer()" style="margin: 0;">
                                        <span data-i18n="qr.openTimerHDMI">📺 Άνοιγμα Timer HDMI</span>
                                    </button>
                                </div>
                                
                                <!-- Admin Panel buttons -->
                                <div id="admin-buttons" class="qr-buttons" style="display: none;">
                                    <a href="admin.html" target="_blank" class="modal-open-timer-btn" style="margin: 0; text-align: center;">
                                        <span data-i18n="qr.openAdminPanel">⚙️ Άνοιγμα Admin Panel</span>
                                    </a>
                                </div>
                                
                                <!-- Questions Admin buttons -->
                                <div id="questions-admin-buttons" class="qr-buttons" style="display: none;">
                                    <a href="questions-admin.html" target="_blank" class="modal-open-timer-btn" style="margin: 0; text-align: center;">
                                        <span data-i18n="qr.openQAAdmin">🎛️ Άνοιγμα Q&A Admin</span>
                                    </a>
                                </div>
                                
                                <!-- Questions Form buttons -->
                                <div id="questions-form-buttons" class="qr-buttons" style="display: none;">
                                    <a href="questions-form.html" target="_blank" class="modal-open-timer-btn" style="margin: 0; text-align: center;">
                                        📝 Άνοιγμα Q&A Form
                                    </a>
                                </div>
                                
                                <!-- Questions QR Display buttons -->
                                <div id="questions-qr-buttons" class="qr-buttons" style="display: none;">
                                    <a href="questions-qr.html" target="_blank" class="modal-open-timer-btn" style="margin: 0; text-align: center;">
                                        📱 Άνοιγμα Q&A QR Display
                                    </a>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ΔΕΞΙΑ: SERVER INFO BLOCK -->
    <div class="modal-qr-info" style="flex: 1;">
        <div id="modal-timer-url" class="modal-timer-url"></div>
        
        <div class="modal-server-info">
    <div id="modal-server-addresses" class="modal-server-addresses">
        <!-- Server addresses will appear here -->
    </div>
    
    <!-- ΠΡΟΣΘΗΚΗ: VMix Timer API με αυτόματη IP -->
    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
        <div style="color: #e67e22; font-weight: bold; margin-bottom: 8px; font-size: 0.9rem;">
            🎥 VMix Timer API:
        </div>
        <div id="modal-vmix-timer-api-url" style="font-family: 'Courier New', monospace; font-size: 0.8rem; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; color: #2ecc71;">
            <!-- Timer API URL θα εμφανιστεί εδώ -->
        </div>
        <div style="font-size: 0.75rem; color: #95a5a6; margin-top: 8px; line-height: 1.3;">
            💡 Data Source για VMix: Refresh interval 1000ms
        </div>
    </div>
                    </div> <!-- Close main container -->
                </div>
            </div>
            </div> <!-- Close QR & Connection Section -->
            
            <!-- Companion Module Section -->
            <div class="settings-section" style="background: rgba(103, 58, 183, 0.1) !important; border: 2px solid #673ab7 !important; border-radius: 8px; padding: 15px; margin: 15px 0; position: relative;">
                <h3 class="section-title" style="color: #673ab7; text-align: left; margin-bottom: 8px; font-size: 1rem; font-weight: bold;" data-i18n="admin:companion.title">🎮 Companion Module</h3>
                <p style="font-size: 0.85rem; color: #7f8c8d; margin-bottom: 12px;" data-i18n="admin:companion.description">Κατέβασμα module για Bitfocus Companion (Stream Deck control)</p>
                
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                    <div id="companion-module-info" style="font-size: 0.8rem; color: #95a5a6;" data-i18n="admin:companion.loading">
                        Φόρτωση πληροφοριών...
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="downloadCompanionModule()" style="padding: 8px 16px; background: #673ab7; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;" data-i18n="admin:companion.download">
                        📦 Κατέβασμα Module
                    </button>
                    <button onclick="showCompanionInstructions()" style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;" data-i18n="admin:companion.instructions">
                        📖 Οδηγίες Εγκατάστασης
                    </button>
                </div>
            </div>
            
            <!-- License Management Section -->
            <div id="license-management-section" class="settings-section" style="background: rgba(39, 174, 96, 0.1) !important; border: 2px solid #27ae60 !important; border-radius: 8px; padding: 15px; margin: 15px 0; position: relative;">
                <h3 class="section-title" style="color: #27ae60; text-align: left; margin-bottom: 8px; font-size: 1rem; font-weight: bold;">🔑 License Management</h3>
                <p style="font-size: 0.85rem; color: #7f8c8d; margin-bottom: 12px;">Διαχείριση άδειας χρήσης TimeCast Pro</p>
                
                <!-- Machine Information -->
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                    <h4 style="color: #ecf0f1; margin: 0 0 8px 0; font-size: 0.9rem;">🖥️ Machine Information</h4>
                    <div style="display: grid; grid-template-columns: 120px 1fr; gap: 8px; font-size: 0.8rem; color: #bdc3c7;">
                        <div><strong>Computer:</strong></div>
                        <div id="license-computer-name">Loading...</div>
                        <div><strong>Platform:</strong></div>
                        <div id="license-platform-info">Loading...</div>
                        <div><strong>Memory:</strong></div>
                        <div id="license-memory-info">Loading...</div>
                        <div><strong>Machine ID:</strong></div>
                        <div id="license-machine-id" style="font-family: monospace; font-weight: bold; color: #3498db;">Generating...</div>
                        <div><strong>Status:</strong></div>
                        <div id="machine-activation-status" style="font-weight: bold;">
                            <span style="color: #f39c12;">⏳ Checking...</span>
                        </div>
                    </div>
                </div>
                
                <!-- License Key Input -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; color: #ecf0f1; margin-bottom: 6px; font-size: 0.9rem;">License Key:</label>
                    <input type="text" id="license-key-input" 
                           placeholder="TC-2025-XXXXXXXX" 
                           style="width: 100%; padding: 10px; font-family: monospace; font-size: 0.9rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: white;" 
                           maxlength="50">
                </div>
                
                <!-- Current License Status -->
                <div id="license-status-display" style="background: rgba(255, 255, 255, 0.05); border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                    <h4 style="color: #ecf0f1; margin: 0 0 8px 0; font-size: 0.9rem;">📄 Current License Status</h4>
                    <div id="license-status-content" style="font-size: 0.8rem; color: #95a5a6;">
                        Checking license status...
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="activate-license-btn" onclick="activateLicense()" 
                            style="padding: 10px 16px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;" 
                            disabled>
                        🚀 Activate License
                    </button>
                    <button onclick="refreshLicenseStatus()" 
                            style="padding: 10px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">
                        🔄 Refresh Status
                    </button>
                    <button id="deactivate-machine-btn" onclick="deactivateThisMachine()" 
                            style="padding: 10px 16px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; display: none;" 
                            title="Απενεργοποιεί το license από αυτό το machine">
                        🔓 Deactivate Machine
                    </button>
                    <div id="license-loading" style="display: none; color: #3498db; font-size: 0.8rem;">
                        🔄 Processing...
                    </div>
                </div>
            </div> <!-- Close License Management Section -->
            
            <!-- vMix Video Timer Settings -->
            <!-- 📥 vMix INPUT: Video → App (Video Timer Overlay) -->
            <div class="settings-section" style="background: rgba(155, 89, 182, 0.1) !important; border: 2px solid #9b59b6 !important; border-radius: 8px; padding: 15px; margin: 15px 0 10px 0; position: relative; z-index: 10;">
                <h3 class="section-title" style="color: #9b59b6; text-align: left; margin-bottom: 8px; font-size: 1rem; font-weight: bold;" data-i18n="vmix.videoTimer.title">📥 vMix → App (Video Timer)</h3>
                <p style="font-size: 0.85rem; color: #7f8c8d; margin-bottom: 12px;" data-i18n="vmix.videoTimer.description">Εμφανίζει timer overlay από videos που παίζουν στο vMix</p>
                
                <div class="vmix-settings-compact">
                    <div class="checkbox-item" style="display: flex; align-items: center; gap: 15px;">
                        <div>
                            <input type="checkbox" id="vmix-enabled" checked>
                            <label data-i18n="vmix.videoTimer.enabled">Ενεργό vMix Video Timer</label>
                        </div>
                        <div style="font-size: 0.85rem; color: #bdc3c7;">
                            <span data-i18n="vmix.videoTimer.helpText">📹 Εμφανίζει timer για το remaining time των videos που παίζουν στο vMix</span>
                        </div>
                    </div>
                    
                    <div class="vmix-settings-row" style="display: flex; align-items: center; gap: 15px; margin: 10px 0;">
                        <div>
                            <label data-i18n="vmix.host">Host:</label>
                            <input type="text" id="vmix-host" value="" placeholder="192.168.5.123" style="width: 150px; padding: 4px;">
                        </div>
                        <div>
                            <label data-i18n="vmix.port">Port:</label>
                            <input type="number" id="vmix-port" value="8088" min="1" max="65535" style="width: 80px; padding: 4px;">
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="applyVmixConnection()" style="margin-left: 0px; padding: 4px 12px; font-size: 12px; background: #27ae60; color: white; border: none; border-radius: 3px;" data-i18n="vmix.applyIP">📡 Apply IP</button>
                            <button onclick="discoverVmixInstances()" style="margin-left: 5px; padding: 4px 12px; font-size: 12px; background: #3498db; color: white; border: none; border-radius: 3px;" data-i18n="vmix.autoDiscover">🔍 Auto-Discover</button>
                        </div>
                    </div>
                    <div class="vmix-status" id="vmix-status" style="margin: 10px 0; padding: 8px; border-radius: 4px; background-color: rgba(0,0,0,0.1);">
                        <span id="vmix-status-text"></span>
                    </div>
                </div>
            </div>

            <!-- 📤 vMix OUTPUT: App → vMix (Timer Export) -->
            <div class="settings-section" style="background: rgba(52, 152, 219, 0.1) !important; border: 2px solid #3498db !important; border-radius: 8px; padding: 15px; margin: 10px 0 20px 0; position: relative; z-index: 10;">
                <h3 class="section-title" style="color: #3498db; text-align: left; margin-bottom: 8px; font-size: 1rem; font-weight: bold;" data-i18n="vmix.timerExport.title">📤 App → vMix (Timer Export)</h3>
                <p style="font-size: 0.85rem; color: #7f8c8d; margin-bottom: 8px;" data-i18n="vmix.timerExport.description">Στέλνει το timer της εφαρμογής σε vMix Graphics Template</p>
                <p style="font-size: 0.8rem; color: #95a5a6; margin-bottom: 12px;" data-i18n="vmix.timerExport.note">🔗 Χρησιμοποιεί το ίδιο vMix IP από την παραπάνω ενότητα</p>
                
                <div class="vmix-timer-export-settings">
                    <!-- API URL Display -->
                    <div style="background: rgba(46, 204, 113, 0.1); border: 1px solid #2ecc71; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                        <div style="font-size: 0.85rem; color: #2ecc71; font-weight: bold; margin-bottom: 6px;" data-i18n="vmix.timerExport.apiUrl">
                            📡 Timer API URL:
                        </div>
                        <code id="vmix-timer-api-url" style="background: rgba(0,0,0,0.2); padding: 6px 10px; border-radius: 4px; display: block; color: #95a5a6; font-size: 0.9rem; word-break: break-all;">
                            Loading IP address...
                        </code>
                        <div style="font-size: 0.75rem; color: #95a5a6; margin-top: 6px;" data-i18n="vmix.timerExport.apiNote">
                            (Auto-detects TimeCast app IP address)
                        </div>
                    </div>

                    <!-- Instructions -->
                    <div style="background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db; padding: 12px; margin-bottom: 15px; border-radius: 4px;">
                        <div style="font-weight: bold; color: #3498db; margin-bottom: 8px; font-size: 0.9rem;" data-i18n="vmix.timerExport.instructions.title">
                            📝 Setup Instructions:
                        </div>
                        <ol style="margin: 0; padding-left: 20px; font-size: 0.85rem; color: #ecf0f1; line-height: 1.6;">
                            <li data-i18n="vmix.timerExport.instructions.step1">On vMix: Add Input → Title → GT Title (choose a preferred timer look)</li>
                            <li data-i18n="vmix.timerExport.instructions.step2">Right-click this input → Title Editor → Data source → Manage</li>
                            <li data-i18n="vmix.timerExport.instructions.step3">Press (+) symbol on upper left → Choose 'Text' → URL filename: paste the API URL above</li>
                            <li data-i18n="vmix.timerExport.instructions.step4">Press OK → Close the next window</li>
                            <li data-i18n="vmix.timerExport.instructions.step5">On Data source smaller window → Choose Datasource: 'Text' → You will see the timer in your text input</li>
                        </ol>
                    </div>

                    <div class="vmix-export-settings-row" style="display: flex; align-items: center; gap: 15px; margin: 0 0 15px 0;">
                        <div>
                            <label data-i18n="vmix.timerInput">Timer Input:</label>
                            <select id="vmix-timer-export-input" style="width: 200px; padding: 4px; margin-left: 5px;">
                                <option value="" data-i18n="vmix.autoDetect">🔍 Auto-detect (default)</option>
                            </select>
                            <button onclick="loadVmixInputs()" style="margin-left: 5px; padding: 4px 8px; font-size: 12px;" data-i18n="vmix.refresh">🔄 Ανανέωση</button>
                        </div>
                    </div>

                    <div style="font-size: 0.8rem; color: #95a5a6; margin-top: 8px;">
                        <span data-i18n="vmix.tip">💡 <strong>Tip:</strong> Φτιάξε GT template στο vMix με text field 'Time.Text' ή 'Timer.Text'</span>
                    </div>
                </div>
            </div>

            <!-- NEW ISOLATED CONTAINER FOR DANGER ZONE -->  
            <div style="background: transparent !important; padding: 0; margin: 0; position: relative; isolation: isolate; contain: layout style; z-index: 20;">
                <!-- Διαμόρφωση Management - Final Section -->
                <div class="settings-section danger-zone-container" style="background: repeating-linear-gradient(45deg, #ffcc00, #ffcc00 10px, #000 10px, #000 20px) !important; border: 3px solid #000 !important; position: relative; z-index: 21;">
                    <!-- Inner content background -->
                    <div style="background: rgba(44, 62, 80, 0.95); border-radius: 5px; padding: 15px; position: relative; z-index: 1;">
                        <h3 class="section-title" style="color: #ffcc00; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); font-weight: bold;" data-i18n="settings.dangerZone.title">⚠️ ΠΡΟΣΟΧΗ - Διαμόρφωση</h3>
                    
                    <div class="button-group" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="importSettings()" class="btn btn-info" data-i18n="settings.dangerZone.importConfig">📥 Εισαγωγή Διαμόρφωσης</button>
                        <button onclick="exportSettings()" class="btn btn-success" data-i18n="settings.dangerZone.exportConfig">📤 Εξαγωγή Διαμόρφωσης</button>
                        <button onclick="handleClearAllData()" class="btn" style="background-color: #e74c3c; color: white; border: none;" data-i18n="settings.dangerZone.clearAll">🗑️ Ολικός Καθαρισμός</button>
                        <button onclick="handleRestoreAutoBackup()" class="btn" style="background-color: #3498db; color: white; border: none; font-weight: bold;" data-i18n="settings.autoBackup.restore">⏮️ Επαναφορά</button>
                    </div>
                    
                    <input type="file" id="settings-file" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                    </div>
                </div>
            </div>
            
            <!-- Language Settings -->
            <div class="settings-section" style="background-color: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <div style="border: 2px solid #e74c3c; border-radius: 8px; padding: 15px; background-color: rgba(231, 76, 60, 0.1);">
                    <div style="display: flex; align-items: center; gap: 20px;">
                        <span style="color: #e74c3c; font-weight: bold; font-size: 1.1rem;" data-i18n="languageSettings.label">🌐 Γλώσσα:</span>
                        <select id="language-selector" onchange="onLanguageChange()" 
                                style="padding: 8px 12px; border-radius: 6px; border: 2px solid #e74c3c; background: white; color: black; font-size: 0.95rem; min-width: 140px;">
                            <option value="el">🇬🇷 Ελληνικά</option>
                            <option value="en">🇬🇧 English</option>
                        </select>
                        <span style="color: #e74c3c; font-weight: bold; font-size: 0.9rem;" data-i18n="languageSettings.appliedImmediately">
                            💡 Οι αλλαγές εφαρμόζονται αμέσως
                        </span>
                    </div>
                </div>
            </div>

            <!-- Yeelight RGB Bulbs -->
            <div class="settings-section" style="background: rgba(255, 105, 180, 0.1) !important; border: 2px solid #ff69b4 !important; border-radius: 8px; padding: 15px; margin: 15px 0; position: relative;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                    <span style="color: #ff69b4; font-weight: bold; font-size: 1.1rem;">💡 Yeelight RGB Λάμπες</span>
                    <button onclick="manualYeelightSearch()" style="
                        background: linear-gradient(135deg, #ff69b4, #ff1493);
                        color: white;
                        border: none;
                        padding: 6px 12px;
                        border-radius: 6px;
                        font-size: 0.85rem;
                        font-weight: bold;
                        cursor: pointer;
                        box-shadow: 0 2px 8px rgba(255, 105, 180, 0.3);
                        transition: all 0.3s;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        ♻️ Manual Search
                    </button>
                    <div id="yeelight-status" style="color: #ff69b4; font-size: 0.9rem; margin-left: auto;">●●● Αυτόματη αναζήτηση...</div>
                </div>

                <!-- Bulb Table -->
                <div id="yeelight-bulb-table" style="background: rgba(255,255,255,0.05); border-radius: 6px; padding: 10px; margin-bottom: 15px; max-height: 200px; overflow-y: auto;">
                    <div style="color: #fff; text-align: center; padding: 20px;">🔍 Αναζήτηση λαμπών...</div>
                </div>

                <!-- Brightness Control -->
                <div style="display: flex; align-items: center; gap: 15px; background: rgba(255,255,255,0.05); border-radius: 6px; padding: 12px;">
                    <span style="color: #ff69b4; font-weight: bold; min-width: 80px;">🔆 Φωτεινότητα:</span>

                    <!-- Universal On/Off Toggle -->
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label class="switch" style="margin: 0;">
                            <input type="checkbox" id="yeelight-universal-toggle" onchange="yeelightUniversalToggle(this.checked)" checked>
                            <span class="switch-slider"></span>
                        </label>
                        <span style="color: #ff69b4; font-size: 0.9rem; font-weight: bold;">ON/OFF</span>
                    </div>

                    <input type="range" id="yeelight-brightness-slider" class="slider" min="1" max="100" value="100"
                           oninput="yeelightUpdateBrightness(this.value)"
                           style="flex: 1; height: 6px; background: linear-gradient(90deg, #ff69b4, #ffb4d6); border-radius: 3px; outline: none;">
                    <span id="yeelight-brightness-value" style="color: #fff; font-weight: bold; min-width: 40px;">100%</span>
                </div>
            </div>

        </div>
    </div>
</div>
   
   <script>
    
       document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" onerror="loadFallbackScript(\'libs/qrcode.min.js\')"><\/script>');
   </script>
   <script>
       document.write('<script src="/socket.io/socket.io.js" onerror="loadFallbackScript(\'libs/socket.io.min.js\')"><\/script>');
   </script>
   <script>
       // ------ VARIABLES ------
       // Timer
       let timeLeft = 900; // 5 minutes default
       let originalTime = 900;
       let isRunning = false;
       let warningThreshold = 60; // 1 minute warning
       
       // Timer state object for admin preview
       let timerState = {
           clockMode: false // false = timer display, true = current time display
       };
       
       // Sound
       const audioContext = new (window.AudioContext || window.webkitAudioContext)();
       let soundEnabled = true;
       let soundVolume = 0.7;

       // ------ LANGUAGE-AWARE END TIME MESSAGE ------
       function getEndTimeMessage() {
           // ΚΡΙΣΙΜΟ: Διάβασε τη γλώσσα από τον dropdown, ΟΧΙ από localStorage
           const languageDropdown = document.getElementById('language-selector');
           const currentLanguage = languageDropdown ? languageDropdown.value : 'el';

           console.log(`🔍 [getEndTimeMessage] Dropdown value: "${languageDropdown?.value}", returning: ${currentLanguage === 'en' ? 'TIME UP' : 'ΤΕΛΟΣ ΧΡΟΝΟΥ'}`);

           return currentLanguage === 'en' ? 'TIME UP' : 'ΤΕΛΟΣ ΧΡΟΝΟΥ';
       }

       // ------ CUSTOM NOTIFICATION DIALOG ------
       function showCustomNotification(title, message, type = 'info') {
           // Create overlay
           const overlay = document.createElement('div');
           overlay.style.cssText = `
               position: fixed;
               top: 0;
               left: 0;
               width: 100%;
               height: 100%;
               background: rgba(0, 0, 0, 0.7);
               backdrop-filter: blur(5px);
               z-index: 99999;
               display: flex;
               align-items: center;
               justify-content: center;
               animation: fadeIn 0.2s ease;
           `;

           // Create dialog
           const dialog = document.createElement('div');
           const bgColor = type === 'success' ? 'linear-gradient(135deg, #2ecc71, #27ae60)'
                         : type === 'error' ? 'linear-gradient(135deg, #e74c3c, #c0392b)'
                         : 'linear-gradient(135deg, #3498db, #2980b9)';

           dialog.style.cssText = `
               background: ${bgColor};
               padding: 30px;
               border-radius: 15px;
               box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
               max-width: 450px;
               width: 90%;
               color: white;
               animation: slideDown 0.3s ease;
           `;

           dialog.innerHTML = `
               <div style="text-align: center;">
                   <h2 style="margin: 0 0 15px 0; font-size: 24px; font-weight: 300;">${title}</h2>
                   <p style="margin: 0 0 25px 0; font-size: 16px; line-height: 1.5; white-space: pre-line;">${message}</p>
                   <button id="notificationOkBtn" style="
                       background: rgba(255, 255, 255, 0.2);
                       border: 2px solid rgba(255, 255, 255, 0.5);
                       color: white;
                       padding: 12px 40px;
                       border-radius: 8px;
                       font-size: 16px;
                       font-weight: 500;
                       cursor: pointer;
                       transition: all 0.3s ease;
                   ">OK</button>
               </div>
           `;

           overlay.appendChild(dialog);
           document.body.appendChild(overlay);

           // Close on OK button click
           const okBtn = document.getElementById('notificationOkBtn');
           okBtn.addEventListener('click', () => {
               overlay.style.animation = 'fadeOut 0.2s ease';
               setTimeout(() => overlay.remove(), 200);
           });

           // Close on overlay click
           overlay.addEventListener('click', (e) => {
               if (e.target === overlay) {
                   overlay.style.animation = 'fadeOut 0.2s ease';
                   setTimeout(() => overlay.remove(), 200);
               }
           });

           // Close on ESC key
           const escHandler = (e) => {
               if (e.key === 'Escape') {
                   overlay.style.animation = 'fadeOut 0.2s ease';
                   setTimeout(() => overlay.remove(), 200);
                   document.removeEventListener('keydown', escHandler);
               }
           };
           document.addEventListener('keydown', escHandler);

           // Focus OK button
           okBtn.focus();

           // Add animations CSS if not exists
           if (!document.getElementById('notificationAnimations')) {
               const style = document.createElement('style');
               style.id = 'notificationAnimations';
               style.textContent = `
                   @keyframes fadeIn {
                       from { opacity: 0; }
                       to { opacity: 1; }
                   }
                   @keyframes fadeOut {
                       from { opacity: 1; }
                       to { opacity: 0; }
                   }
                   @keyframes slideDown {
                       from { transform: translateY(-50px); opacity: 0; }
                       to { transform: translateY(0); opacity: 1; }
                   }
                   #notificationOkBtn:hover {
                       background: rgba(255, 255, 255, 0.3) !important;
                       border-color: rgba(255, 255, 255, 0.8) !important;
                       transform: translateY(-2px);
                   }
               `;
               document.head.appendChild(style);
           }
       }

       // ------ PROFESSIONAL ERROR REPORTING SYSTEM ------
       const ErrorReporter = {
           errorBuffer: [],
           contextBuffer: [],
           maxErrors: 500,
           maxContext: 500,
           sessionStartTime: new Date(),

           // Capture console errors/warnings
           init() {
               const self = this;

               // Override console.error
               const originalError = console.error;
               console.error = function(...args) {
                   self.addError('ERROR', args.join(' '));
                   originalError.apply(console, args);
               };

               // Override console.warn
               const originalWarn = console.warn;
               console.warn = function(...args) {
                   self.addError('WARNING', args.join(' '));
                   originalWarn.apply(console, args);
               };

               // Capture unhandled errors
               window.addEventListener('error', (event) => {
                   self.addError('UNCAUGHT_ERROR', `${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, event.error?.stack);
               });

               // Capture unhandled promise rejections
               window.addEventListener('unhandledrejection', (event) => {
                   self.addError('UNHANDLED_REJECTION', event.reason?.message || event.reason, event.reason?.stack);
               });

               // Log all console.log for context
               const originalLog = console.log;
               console.log = function(...args) {
                   self.addContext('LOG', args.join(' '));
                   originalLog.apply(console, args);
               };

               console.log('✅ Error Reporter initialized');
           },

           addError(level, message, stack = '') {
               const entry = {
                   timestamp: new Date().toISOString(),
                   level,
                   message,
                   stack,
                   sessionAge: Math.floor((Date.now() - this.sessionStartTime) / 1000) + 's'
               };

               this.errorBuffer.push(entry);
               if (this.errorBuffer.length > this.maxErrors) {
                   this.errorBuffer.shift(); // Remove oldest
               }
           },

           addContext(level, message) {
               const entry = {
                   timestamp: new Date().toISOString(),
                   level,
                   message
               };

               this.contextBuffer.push(entry);
               if (this.contextBuffer.length > this.maxContext) {
                   this.contextBuffer.shift(); // Remove oldest
               }
           },

           async collectDiagnostics() {
               // Get license info from Electron API
               let licenseKey = 'No license';
               try {
                   if (window.electronAPI?.validateCurrentLicense) {
                       const licenseStatus = await window.electronAPI.validateCurrentLicense();
                       if (licenseStatus?.license?.key) {
                           licenseKey = licenseStatus.license.key;
                       }
                   }
               } catch (e) {
                   console.warn('Could not retrieve license key for error report:', e);
               }

               // Get app version via electronAPI
               let appVersion = 'Unknown';
               try {
                   if (window.electronAPI?.getAppVersion) {
                       appVersion = await window.electronAPI.getAppVersion();
                   }
               } catch (e) {
                   console.error('❌ Failed to get app version:', e);
               }

               const diagnostics = {
                   // Report metadata
                   reportGenerated: new Date().toISOString(),
                   sessionDuration: Math.floor((Date.now() - this.sessionStartTime) / 1000) + 's',

                   // App info
                   appVersion: appVersion,
                   environment: typeof window.electronAPI !== 'undefined' ? 'Electron' : 'Browser',

                   // License info
                   licenseKey: licenseKey,

                   // System info
                   platform: navigator.platform,
                   userAgent: navigator.userAgent,
                   language: navigator.language,
                   screenResolution: `${screen.width}x${screen.height}`,
                   windowSize: `${window.innerWidth}x${window.innerHeight}`,

                   // Memory (if available)
                   memory: performance.memory ? {
                       usedJSHeapSize: Math.floor(performance.memory.usedJSHeapSize / 1024 / 1024) + ' MB',
                       totalJSHeapSize: Math.floor(performance.memory.totalJSHeapSize / 1024 / 1024) + ' MB',
                       jsHeapSizeLimit: Math.floor(performance.memory.jsHeapSizeLimit / 1024 / 1024) + ' MB'
                   } : 'Not available',

                   // Network state
                   online: navigator.onLine,

                   // Timer state
                   timerState: {
                       timeLeft,
                       isRunning,
                       clockMode: timerState?.clockMode
                   },

                   // Socket connection
                   socketConnected: isConnected,

                   // Error counts
                   totalErrors: this.errorBuffer.filter(e => e.level === 'ERROR' || e.level === 'UNCAUGHT_ERROR').length,
                   totalWarnings: this.errorBuffer.filter(e => e.level === 'WARNING').length,

                   // Buffers
                   errors: this.errorBuffer,
                   contextLogs: this.contextBuffer
               };

               return diagnostics;
           },

           async sendReport() {
               try {
                   console.log('📧 Collecting diagnostic data...');
                   const diagnostics = await this.collectDiagnostics();

                   // Calculate size
                   const reportJSON = JSON.stringify(diagnostics, null, 2);
                   const sizeKB = Math.floor(reportJSON.length / 1024);

                   console.log(`📊 Report size: ${sizeKB} KB`);

                   if (sizeKB > 450) {
                       console.warn('⚠️ Report too large, truncating context...');
                       diagnostics.contextLogs = diagnostics.contextLogs.slice(-200); // Keep last 200
                   }

                   // Send to licensing API
                   console.log('📤 Sending error report to API...');
                   console.log('License Key:', diagnostics.licenseKey);

                   const response = await fetch('https://timecast.eu/licensing/api.php', {
                       method: 'POST',
                       headers: { 'Content-Type': 'application/json' },
                       body: JSON.stringify({
                           action: 'submit_error_report',
                           license_key: diagnostics.licenseKey,
                           report: diagnostics
                       })
                   });

                   console.log('📥 API Response status:', response.status);

                   if (response.ok) {
                       const result = await response.json();
                       console.log('✅ API Response:', result);
                       return { success: true, message: 'Report sent to support@timecast.eu' };
                   } else {
                       const errorText = await response.text();
                       console.error('❌ API Error Response:', errorText);
                       throw new Error('Server returned error: ' + response.status);
                   }
               } catch (error) {
                   console.error('❌ Failed to send error report:', error);
                   return { success: false, message: 'Failed to send report: ' + error.message };
               }
           }
       };

       // Initialize on load
       ErrorReporter.init();

       // Socket.IO
       let socket;
       let isConnected = false;
       
       // Saved messages
       let savedMessages = []; // Θα φορτωθεί από server
       let eventMarkers = []; // Server-synced markers
       
       // UI variables
       let titleFontSize = 32; // Initial size in px
       let logoSize = 80; // Initial size in px
       let logoDataUrl = ''; // To store logo as data URL
       
       // Sync variable
       let lastSyncTime = 0;

       // Message visibility management
       let isMessageVisible = false;
       
       // Flash Alert functionality
       let isFlashAlertActive = false;
       let flashTimer = null;

       let isHdmiToggling = false;
       
       // DOM elements
       const timerPreview = document.getElementById('timer-preview');
       const startPauseButton = document.getElementById('start-pause');
       const messagePreview = document.getElementById('message-preview');
       const titlePreview = document.getElementById('title-preview');
       const connectionStatus = document.getElementById('connection-status');
       const statusDot = document.getElementById('status-dot');
       const statusText = document.getElementById('status-text');
       const syncStatus = document.getElementById('sync-status');
       const devicesCount = document.getElementById('devices-count');
       const previewProgressBar = document.getElementById('preview-progress-bar');
       
       // ------ INITIALIZATION ------
       document.addEventListener('DOMContentLoaded', () => {
    // PREVENT MULTIPLE INITIALIZATION - ΔΙΟΡΘΩΣΗ CONFLICT
    if (window.adminDOMInitialized) {
        console.log('🛑 MAIN DOM already initialized, preventing duplicate');
        return;
    }
    window.adminDOMInitialized = true;
    
    console.log('🧹 MAIN: Starting CLEAN admin initialization...');
    
    // Initialize Language System
    
    // CLEANUP - ΑΠΕΝΕΡΓΟΠΟΙΗΜΕΝΟ λόγω προβλημάτων με inputs
// const allInputs = document.querySelectorAll('input, textarea, select');
// allInputs.forEach(input => {
//     const newInput = input.cloneNode(true);
//     input.parentNode.replaceChild(newInput, input);
// });
console.log('🧹 MAIN: Cleanup skipped to preserve input functionality');
    
    // ΚΑΘΑΡΙΣΜΟΣ ΜΟΝΟ παλιών localStorage items (NOT auto-save!)
    console.log('🧹 Clearing old localStorage items on admin startup...');
    localStorage.removeItem('timerSettings');
    localStorage.removeItem('savedMessages'); // Αν υπάρχει
    // localStorage.removeItem('timerAutoSave'); // ΣΧΟΛΙΟ: ΜΗΝ διαγράψεις το auto-save!
    console.log('✅ Old localStorage items cleared (auto-save preserved)');
    
    console.log('DOM loaded - initializing admin panel');
    
    // Initial timer size adjustment
    
    // Initial timer size adjustment
// Complete state initialization after refresh
// Simple initialization after refresh
setTimeout(() => {
    const messagePreview = document.getElementById('message-preview');

    // Fix message font size if there's content
    if (messagePreview && messagePreview.textContent.trim() !== '') {
        const text = messagePreview.textContent.trim();

        // ΕΙΔΙΚΗ ΠΕΡΙΠΤΩΣΗ: "ΤΕΛΟΣ ΧΡΟΝΟΥ" / "TIME UP" - μεγάλο responsive font με vh units
        if (text === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || text === 'TIME UP') {
            messagePreview.style.setProperty('font-size', 'clamp(2rem, 8vh, 10vh)', 'important');
            messagePreview.style.setProperty('font-weight', 'bold', 'important');
            messagePreview.style.setProperty('text-align', 'center', 'important');
            messagePreview.style.setProperty('white-space', 'normal', 'important');
            messagePreview.style.setProperty('word-wrap', 'break-word', 'important');
        } else {
            adjustMessageFontSize(messagePreview, text);
        }
    }
    
    console.log('Basic UI initialization complete');
}, 200);

    // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" μετά από language restore
    setTimeout(() => {
        const messageInput = document.getElementById('message-input');
        const messagePreview = document.getElementById('message-preview');
        if (messageInput && messagePreview) {
            const currentMsg = messageInput.value.trim();
            const savedLang = localStorage.getItem('preferredLanguage') || 'el';
            const expectedMsg = savedLang === 'en' ? 'TIME UP' : 'ΤΕΛΟΣ ΧΡΟΝΟΥ';

            if ((currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') && currentMsg !== expectedMsg) {
                messageInput.value = expectedMsg;
                messagePreview.textContent = expectedMsg;
                console.log(`🔄 [Startup] Fixed message from "${currentMsg}" to "${expectedMsg}" based on language: ${savedLang}`);

                // Broadcast το διορθωμένο μήνυμα
                if (typeof socket !== 'undefined' && socket && socket.connected) {
                    socket.emit('updateMessage', {
                        message: expectedMsg,
                        visible: true
                    });
                    console.log(`📡 Broadcasted corrected message: ${expectedMsg}`);
                }
            }
        }
    }, 2000); // 2 sec - Αφήνουμε χρόνο για language restore

    // Start clock mode interval for preview real-time updates
    let clockModeInterval = setInterval(() => {
        if (timerState.clockMode) {
            updateTimerDisplay(); // This will show current time in preview
        }
    }, 1000);
    
    console.log('🕐 Clock mode interval started for preview updates');

    // Prevent multiple initializations
    if (window.adminInitialized) {
        console.log('Admin already initialized, skipping');
        return;
    }
    window.adminInitialized = true;
    
    // Load display settings
    loadSettings();
    
    // Load saved vMix connection
    loadVmixConnection(); // Load saved vMix connection for better UX
    
    // Auto-connect to last successful vMix connection on startup
    setTimeout(() => {
        const vmixHost = document.getElementById('vmix-host').value;
        const vmixPort = document.getElementById('vmix-port').value;
        
        if (vmixHost && vmixHost.trim() !== '') {
            console.log(`🚀 Auto-connecting to last vMix connection: ${vmixHost}:${vmixPort}`);
            
            // Auto-apply the saved connection
            applyVmixConnection().then(() => {
                console.log('✅ Auto-connection completed');
                
                // Auto-refresh inputs after successful connection
                setTimeout(() => {
                    console.log('🔄 Auto-refreshing vMix inputs after connection...');
                    loadVmixInputs();
                }, 1000);
            }).catch(error => {
                console.log('⚠️ Auto-connection failed, trying manual refresh...', error);
                // Fallback: just refresh inputs even if connection failed
                loadVmixInputs();
            });
        } else {
            console.log('ℹ️ No saved vMix connection found - skipping auto-connect');
        }
    }, 2000); // Wait 2 seconds for UI to fully load
    
    // ΠΡΟΣΘΗΚΗ: Αρχική προσαρμογή για default τίτλο
    adjustTitleFontSize('TimeCast® Pro Conference Timer');

    // Display saved messages
    loadSavedMessagesFromServer();
    
    // Display IP addresses and create QR
    fetchServerInfo();
    
    // Connect to Socket.IO ONLY ONCE
    connectToServer();

           // Initialize logo preview after a small delay
           setTimeout(() => {
               if (logoDataUrl) {
                   updatePreviewLogos();
               }
               
               // Logo position checkboxes με instant sync
function addLogoPositionSyncListener(elementId) {
    const element = document.getElementById(elementId);
    if (element) {
        element.addEventListener('change', function() {
            // Τοπική ενημέρωση preview
            updatePreviewLogos();
            
            // === ΠΡΟΣΘΗΚΗ: Άμεσο position sync ===
            if (socket && socket.connected) {
                // Get selected radio button value
                const selectedPosition = document.querySelector('input[name="logo-position"]:checked');
                const position = selectedPosition ? selectedPosition.value : 'top-left';
                
                const logoPositions = {
                    tl: position === 'top-left',
                    tc: position === 'top-center',
                    tr: position === 'top-right',
                    bl: position === 'bottom-left',
                    bc: position === 'bottom-center',
                    br: position === 'bottom-right'
                };
                
                socket.emit('logoSync', {
                    logoDataUrl: logoDataUrl,
                    logoSize: logoSize,
                    logoPositions: logoPositions
                });
                console.log('🖼️ Logo position changed - instant sync sent');
            }
        });
    }
}

// Προσθήκη listeners σε όλα τα checkboxes
addLogoPositionSyncListener('logo-tl');
addLogoPositionSyncListener('logo-tc');
addLogoPositionSyncListener('logo-tr');
addLogoPositionSyncListener('logo-bl');
addLogoPositionSyncListener('logo-bc');
addLogoPositionSyncListener('logo-br');

               // Event listener for title immediate update με αυτόματη προσαρμογή
document.getElementById('title-input').addEventListener('input', function() {
    const titleText = this.value || 'TimeCast® Pro Conference Timer';
    document.getElementById('title-preview').textContent = titleText;
    
    // ΠΡΟΣΘΗΚΗ: Αυτόματη προσαρμογή μεγέθους
    adjustTitleFontSize(titleText);
});
}, 100);
// ΠΡΟΣΘΗΚΗ: Αυτόματη αποστολή στον server όταν αλλάζει ο τίτλος
document.getElementById('title-input').addEventListener('blur', function() {
    // Όταν φεύγει το focus από το title input - μόνο preview
    updateDisplayPreview();
});

document.getElementById('title-input').addEventListener('keydown', function(e) {
    // Όταν πατηθεί Enter στο title input - μόνο preview
    if (e.key === 'Enter') {
        this.blur(); // Trigger το blur event
        updateDisplayPreview();
    }
});


          // Color picker event listeners με instant sync
document.getElementById('background-color').addEventListener('input', function() {
    var color = this.value;
    document.querySelector('#preview-screen').style.backgroundColor = color;
    
    // === ΠΡΟΣΘΗΚΗ: Άμεσο background color sync ===
    if (socket && socket.connected) {
        socket.emit('backgroundColorSync', {
            backgroundColor: color
        });
        console.log('🎨 Background color changed - instant sync sent:', color);
    }
});

       });
       
       // ------ SOCKET.IO FUNCTIONS ------
      function connectToServer() {
    // Electron detection και connection URL
    const isElectron = typeof window !== 'undefined' && window.process && window.process.type;
    let serverURL;
    
    if (isElectron) {
        serverURL = 'http://localhost:3000';
        console.log('🔌 Electron mode: Connecting to localhost server');
    } else {
        serverURL = window.location.origin;
        console.log('🌐 Web mode: Connecting to current origin');
    }
    
    // Prevent multiple connections
    if (socket && socket.connected) {
        console.log('Already connected to server');
        return;
    }
    
    updateConnectionStatus('connecting');
    
    socket = io(serverURL, {
    reconnection: true,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 5000,
    maxReconnectionAttempts: 10, // Περισσότερες προσπάθειες για Electron
    timeout: 15000, // Περισσότερος χρόνος
    forceNew: false,
    transports: ['websocket', 'polling']
});
           
           socket.on('connect', () => {
    console.log('Connected to server:', socket.id);
    isConnected = true;
    updateConnectionStatus('connected');

    console.log('Registering as admin client...');
    socket.emit('registerClient', {
        type: 'admin',
        role: 'controller'
    });

    console.log('Admin client registered with server');

    // ΚΡΙΣΙΜΟ: Στείλε την τρέχουσα γλώσσα στον server αμέσως μόλις συνδεθείς
    const languageDropdown = document.getElementById('language-selector');
    const currentLang = languageDropdown ? languageDropdown.value : (localStorage.getItem('preferredLanguage') || 'el');
    socket.emit('languageChange', { language: currentLang });
    console.log(`📡 Sent initial language to server: "${currentLang}"`);

    // Setup socket listeners first
    setupVmixTallyListeners();

    // Auto-start vMix tally monitoring
    setTimeout(() => {
        console.log('⏰ [CLIENT] Auto-starting vMix tally after 1 second delay...');
        initVmixTally();
    }, 1000); // Delay to ensure socket is fully ready

    // Φόρτωση ερώτησης και αυτόματη αποστολή
if (socket) {
    socket.on('loadQuestionAndSend', (data) => {
    console.log('📝 Loading question and auto-sending:', data.source);
    
    const messageInput = document.getElementById('message-input');
    const messagePreview = document.getElementById('message-preview');
    const messageContainer = document.getElementById('message-container-preview');
    
    if (messageInput) {
        // 1. Φόρτωση στο textarea
        messageInput.value = data.message;
        
        // 2. Άμεση ενημέρωση preview - ΝΕΟΣ ΧΡΩΜΑΤΙΣΤΟΣ ΤΡΟΠΟΣ
if (messagePreview) {
    // Έλεγχος αν είναι ερώτηση (περιέχει HTML structure)
    if (data.message.includes('Ερώτηση από:') && data.message.includes('Θέμα:')) {
        
        // ΠΑΡΣΙΝΓΚ της ερώτησης από το plain text
        const lines = data.message.split('\n').filter(line => line.trim());
        
        // Εξαγωγή στοιχείων (με fallbacks για ασφάλεια)
        const fromLine = lines.find(line => line.includes('Ερώτηση από:')) || 'Ερώτηση από: -';
        const toLine = lines.find(line => line.includes('Ερώτηση προς:')) || 'Ερώτηση προς: -';
        const subjectLine = lines.find(line => line.includes('Θέμα:')) || 'Θέμα: -';
        
        // Το κύριο κείμενο είναι όλα τα υπόλοιπα μετά τη γραμμή θέματος
        const subjectIndex = lines.findIndex(line => line.includes('Θέμα:'));
        const questionText = subjectIndex >= 0 && subjectIndex < lines.length - 1 
            ? lines.slice(subjectIndex + 1).join(' ').trim() 
            : 'Κείμενο ερώτησης';
        
        // Δημιουργία ΧΡΩΜΑΤΙΣΤΟΥ HTML - ΙΔΙΟ ΜΕ TIMER.HTML
        const questionHTML = `
            <div class="question-from-line" style="font-size: 2.5vh; color: #3498db; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                ${fromLine}
            </div>
            <div class="question-to-line" style="font-size: 2.5vh; color: #2ecc71; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                ${toLine}
            </div>
            <div class="question-subject-line" style="font-size: 3vh; color: #f39c12; font-weight: bold; margin-bottom: 2vh; text-align: center;">
                ${subjectLine}
            </div>
            <div class="question-text-content" style="font-size: 3.5vh; color: #ffffff; line-height: 1.4; text-align: center;">
                ${questionText}
            </div>
        `;
        
        // Εμφάνιση με το νέο χρωματιστό layout
        messagePreview.innerHTML = questionHTML;
        
        // Ειδικό styling για ερωτήσεις στο admin preview - ΙΔΙΟ ΜΕ TIMER
        messagePreview.style.textAlign = 'center';
        messagePreview.style.lineHeight = '1.5';
        messagePreview.style.display = 'flex';
        messagePreview.style.flexDirection = 'column';
        messagePreview.style.alignItems = 'center';
        messagePreview.style.justifyContent = 'center';
        messagePreview.style.width = '100%';
        messagePreview.style.height = 'auto';
        messagePreview.style.padding = '0';
        messagePreview.style.margin = '0';
        
        // ΠΡΟΣΘΗΚΗ: Smart font scaling για ερωτήσεις στο admin
        adjustQuestionFontSize(messagePreview, questionHTML);
        
        console.log('📋 Question preview with COLORED LAYOUT and smart scaling');
    } else {
        // Είναι κανονικό μήνυμα
        messagePreview.textContent = data.message;

        // ΕΙΔΙΚΗ ΠΕΡΙΠΤΩΣΗ: "ΤΕΛΟΣ ΧΡΟΝΟΥ" / "TIME UP" - μεγάλο responsive font με vh units
        if (data.message.trim() === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || data.message.trim() === 'TIME UP') {
            messagePreview.style.setProperty('font-size', 'clamp(2rem, 8vh, 10vh)', 'important');
            messagePreview.style.setProperty('font-weight', 'bold', 'important');
            messagePreview.style.setProperty('text-align', 'center', 'important');
            messagePreview.style.setProperty('white-space', 'normal', 'important');
            messagePreview.style.setProperty('word-wrap', 'break-word', 'important');
            console.log('🚨 "ΤΕΛΟΣ ΧΡΟΝΟΥ" με μεγάλο responsive font (8vh)');
        } else {
            adjustMessageFontSize(messagePreview, data.message);
            console.log('💬 Regular message with auto font size');
        }
    }
}
        
        // 3. Εμφάνιση container
        if (messageContainer) {
            messageContainer.style.display = 'flex';
        }
        
        // 4. Εμφάνιση μηνύματος (μόνο αν δεν είναι ήδη ορατό)
        if (!isMessageVisible) {
            toggleMessageVisibility();
        }
        
        // 5. Μίκρανση του timer στο preview
        adjustPreviewTimerAndMessageSize(true);
        
        console.log('✅ Question loaded, displayed in preview, and timer adjusted');
    }
});
} else {
    console.warn('Socket not available for loadQuestionAndSend listener');
}
    // ΝΕΟΣ HANDLER: displayQuestion event για ερωτήσεις από questions-admin
socket.on('displayQuestion', (data) => {
    console.log('📺 Display Question event received in admin:', data);
    
    if (data.question) {
        const messageInput = document.getElementById('message-input');
        const messagePreview = document.getElementById('message-preview');
        const messageContainer = document.getElementById('message-container-preview');
        
        // Δημιουργία formatted κειμένου
        const questionText = `Ερώτηση από: ${data.question.submitter.name} (${data.question.submitter.company})
Ερώτηση προς: ${data.question.question.targetSpeaker}
Θέμα: ${data.question.question.subject}

${data.question.question.text}`;
        
        // 1. Φόρτωση στο textarea
        if (messageInput) {
            messageInput.value = questionText;
        }
        
        // 2. Άμεση ενημέρωση preview με ΧΡΩΜΑΤΙΣΤΟ HTML
        if (messagePreview) {
            const lines = questionText.split('\n').filter(line => line.trim());
            
            const fromLine = lines.find(line => line.includes('Ερώτηση από:')) || 'Ερώτηση από: -';
            const toLine = lines.find(line => line.includes('Ερώτηση προς:')) || 'Ερώτηση προς: -';
            const subjectLine = lines.find(line => line.includes('Θέμα:')) || 'Θέμα: -';
            
            const subjectIndex = lines.findIndex(line => line.includes('Θέμα:'));
            const questionTextContent = subjectIndex >= 0 && subjectIndex < lines.length - 1 
                ? lines.slice(subjectIndex + 1).join(' ').trim() 
                : 'Κείμενο ερώτησης';
            
            // Δημιουργία ΧΡΩΜΑΤΙΣΤΟΥ HTML
            const questionHTML = `
                <div class="question-from-line" style="font-size: 2.5vh; color: #3498db; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                    ${fromLine}
                </div>
                <div class="question-to-line" style="font-size: 2.5vh; color: #2ecc71; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                    ${toLine}
                </div>
                <div class="question-subject-line" style="font-size: 3vh; color: #f39c12; font-weight: bold; margin-bottom: 2vh; text-align: center;">
                    ${subjectLine}
                </div>
                <div class="question-text-content" style="font-size: 3.5vh; color: #ffffff; line-height: 1.4; text-align: center;">
                    ${questionTextContent}
                </div>
            `;
            
            messagePreview.innerHTML = questionHTML;
            
            // Ειδικό styling για ερωτήσεις
            messagePreview.style.textAlign = 'center';
            messagePreview.style.lineHeight = '1.5';
            messagePreview.style.display = 'flex';
            messagePreview.style.flexDirection = 'column';
            messagePreview.style.alignItems = 'center';
            messagePreview.style.justifyContent = 'center';
            messagePreview.style.width = '100%';
            messagePreview.style.height = 'auto';
            messagePreview.style.padding = '0';
            messagePreview.style.margin = '0';
            
            adjustQuestionFontSize(messagePreview, questionHTML);
            console.log('📋 ADMIN: Question preview with COLORED LAYOUT via displayQuestion');
        }
        
        // 3. Εμφάνιση container
        if (messageContainer) {
            messageContainer.style.display = 'flex';
        }
        
        // 4. Αυτόματη αποστολή (εμφάνιση μηνύματος)
        if (!isMessageVisible) {
            toggleMessageVisibility();
        }
        
        adjustPreviewTimerAndMessageSize(true);
        console.log('✅ ADMIN: Question displayed with colored layout via displayQuestion event');
    }
});
    // ΠΡΩΤΑ φέρε όλα τα γενικά δεδομένα
    requestSyncFromServer();
    
    // ΕΛΕΓΧΟΣ αν υπάρχει Excel πριν το refresh
    setTimeout(async () => {
        try {
            const statusResponse = await fetch('/api/markers/excel-status');
            if (statusResponse.ok) {
                const status = await statusResponse.json();
                
               if (status.currentFile && status.excelFileExists && !window.disableExcelAutoCheck) {
                    console.log('🔄 Excel file found - refreshing timeline settings');
                    refreshFromExcel();
                } else {
                    console.log('📋 No Excel file loaded - keeping server timeline settings');
                }
            }
        } catch (error) {
            console.log('📋 Excel check failed - keeping server timeline settings');
        }
    }, 2000);
});

// Λήψη timeline update
socket.on('timelineUpdate', (data) => {
    document.getElementById('event-start-time-settings').value = data.startTime;
    document.getElementById('event-end-time-settings').value = data.endTime;
    document.getElementById('timeline-start-display').textContent = data.startTime;
    document.getElementById('timeline-end-display').textContent = data.endTime;
    updateEventDuration();
    console.log('📅 Timeline updated from other admin');
});
// === ΠΡΟΣΘΗΚΗ: Title update listener ===
socket.on('titleUpdate', (data) => {
    console.log('📝 Title updated from other admin:', data);
    
    // Ενημέρωση input field
    document.getElementById('title-input').value = data.title;
    
    // Ενημέρωση preview
    document.getElementById('title-preview').textContent = data.title;
    
    // Αυτόματη προσαρμογή μεγέθους
    adjustTitleFontSize(data.title);
    
    console.log('✅ Title UI updated from sync');
});
// Logo update listener
socket.on('logoUpdate', (data) => {
    console.log('🖼️ Logo updated from other admin:', data);
    
    // Ενημέρωση logoDataUrl
    if (data.logoDataUrl !== undefined) {
        logoDataUrl = data.logoDataUrl;
        const preview = document.getElementById('logo-preview');
        if (data.logoDataUrl) {
            preview.src = logoDataUrl;
            preview.style.display = 'block';
            document.getElementById('logo-name').textContent = 'Συγχρονισμένο λογότυπο';
        } else {
            preview.style.display = 'none';
            document.getElementById('logo-name').textContent = 'Δεν έχει επιλεγεί αρχείο';
        }
    }
    
    // Ενημέρωση logoSize
    if (data.logoSize !== undefined) {
        logoSize = data.logoSize;
        const preview = document.getElementById('logo-preview');
        if (preview.style.display !== 'none') {
            preview.style.width = `${logoSize}px`;
            preview.style.height = `${logoSize}px`;
        }
    }
    
    // ΚΡΙΣΙΜΟ FIX: Ενημέρωση logoPositions ΜΟΝΟ αν δεν έχουμε ήδη επιλογή
    // Αυτό αποφεύγει το "κατέβασμα" του logo όταν αλλάζουμε μέγεθος
    const currentlySelectedPosition = document.querySelector('input[name="logo-position"]:checked');
    if (data.logoPositions && !currentlySelectedPosition) {
        // Δεν έχουμε επιλεγμένη θέση - κάνε set από server
        setLogoPosition(data.logoPositions);
    }

    // Ενημέρωση preview
    updatePreviewLogos();
    console.log('✅ Logo UI updated');
});
// Listen for event markers updates
socket.on('eventMarkersUpdate', (data) => {
    console.log('Event markers update received:', data);
    
    // Ενημέρωση του local array
    if (data.allMarkers && Array.isArray(data.allMarkers)) {
        eventMarkers = data.allMarkers;
        renderEventMarkers();
        console.log('Event markers updated. Total count:', eventMarkers.length);
    }
});
// Background color update listener
socket.on('backgroundColorUpdate', (data) => {
    console.log('🎨 Background color updated from other admin:', data);
    
    // Ενημέρωση color input
    document.getElementById('background-color').value = data.backgroundColor;
    document.querySelector('#preview-screen').style.backgroundColor = data.backgroundColor;
    
    console.log('✅ Background color UI updated');
});
       // Listen for settings updates από Google Sheets
socket.on('settingsUpdate', function(data) {
    console.log('📊 Settings update received:', data);
    
    if (data.timeline) {
        // Update timeline settings
        if (data.timeline.startTime) {
            const startField = document.getElementById('timeline-start');
            if (startField) {
                startField.value = data.timeline.startTime;
                console.log('📊 Timeline start updated to:', data.timeline.startTime);
            }
        }
        if (data.timeline.endTime) {
            const endField = document.getElementById('timeline-end');
            if (endField) {
                endField.value = data.timeline.endTime;
                console.log('📊 Timeline end updated to:', data.timeline.endTime);
            }
        }
    }
    
    if (data.display && data.display.title) {
        // Update project title
        const titleField = document.getElementById('project-title');
        if (titleField) {
            titleField.value = data.display.title;
            console.log('📊 Project title updated to:', data.display.title);
        }
    }
    
    console.log('📊 ✅ Admin panel settings updated');
});    
           socket.on('confirmation', (data) => {
               console.log('Connection confirmation:', data);
           });
           
           socket.on('clientsCount', (count) => {
               devicesCount.textContent = count;
           });
           socket.on('connectedDevicesList', (devices) => {
            console.log('Connected devices list received:', devices);
            
            const devicesList = document.getElementById('devices-list');
            const devicesCount = document.getElementById('devices-count');
            
            if (!devicesList || !devicesCount) return;
            
            devicesCount.textContent = devices.length;
            
            if (devices.length === 0) {
                devicesList.innerHTML = '<p style="color: #7f8c8d; font-style: italic; text-align: center; padding: 20px;">Δεν υπάρχουν συνδεδεμένες συσκευές</p>';
                return;
            }
            
            devicesList.innerHTML = devices.map(device => {
                const borderColor = device.isServerPC ? '#e74c3c' : '#3498db';
                const bgColor = device.isServerPC ? 'rgba(231, 76, 60, 0.1)' : 'rgba(255,255,255,0.1)';
                
                // Έξυπνη εμφάνιση IP
                let ipDisplay = device.ipAddress || 'Unknown';
                if (device.ipAddress && device.ipAddress !== 'Unknown') {
                    if (device.ipAddress.startsWith('192.168.') || 
                        device.ipAddress.startsWith('10.') || 
                        (device.ipAddress.startsWith('172.') && 
                         parseInt(device.ipAddress.split('.')[1]) >= 16 && 
                         parseInt(device.ipAddress.split('.')[1]) <= 31)) {
                        
                        // Για τοπικές IPs: δείχνουμε τα τελευταία 2 νούμερα
                        const parts = device.ipAddress.split('.');
                        if (parts.length === 4) {
                            ipDisplay = `${parts[0]}.${parts[1]}.${parts[2]}.${parts[3]}`;
                        }
                    }
                }
                
                return `
                <div style="background-color: ${bgColor}; padding: 8px 10px; margin-bottom: 4px; border-radius: 4px; border-left: 3px solid ${borderColor}; transition: all 0.2s ease;">
                    <!-- Γραμμή 1: Role και Computer Name -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                        <span style="font-weight: bold; color: ${borderColor}; font-size: 0.9rem;">
                            ${device.role}
                        </span>
                        <span style="font-size: 0.85rem; color: #ecf0f1; font-weight: bold;">
                            💻 ${device.computerName}
                        </span>
                    </div>
                    
                    <!-- Γραμμή 2: IP Address και Device Type -->
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; color: #95a5a6;">
                        <span style="color: #2ecc71; font-family: 'Courier New', monospace; font-weight: bold;">
                            🌐 ${ipDisplay}
                        </span>
                        <span>
                            ${device.deviceType} • ${device.browser}
                        </span>
                    </div>
                </div>`;
            }).join('');
        });
           
           socket.on('disconnect', () => {
               console.log('Disconnected from server');
               isConnected = false;
               updateConnectionStatus('disconnected');
           });
           
           socket.on('connect_error', (error) => {
               console.error('Connection error:', error);
               updateConnectionStatus('error');
           });
           
           socket.on('command', (data) => {
               console.log('Command received:', data);
               handleCommand(data);
           });
           
           socket.on('timerUpdate', (data) => {
               console.log('Timer update received:', data);
               handleTimerUpdate(data);
               
           });

           // Listen for questions clients count updates και στείλε στο LCD iframe
           socket.on('questionsClientsCount', (count) => {
               console.log('📊 [ADMIN] Questions clients count received:', count);
               
               // Στείλε το count στην LCD strip μέσω postMessage
               const lcdIframe = document.querySelector('iframe[src="lcdstrip.html"]');
               if (lcdIframe && lcdIframe.contentWindow) {
                   lcdIframe.contentWindow.postMessage({
                       type: 'questionsClientsCount',
                       count: count || 0
                   }, '*');
                   console.log('📡 [ADMIN] Sent questionsClientsCount to LCD iframe:', count);
               }
           });
           
           // Listen for clock mode updates
           socket.on('clockModeUpdate', (data) => {
               console.log('🕐 Clock mode update received in admin:', data);
               if (data.clockMode !== undefined) {
                   timerState.clockMode = data.clockMode;
                   
                   // Update checkbox state
                   const clockModeCheckbox = document.getElementById('clock-mode-toggle');
                   if (clockModeCheckbox) {
                       clockModeCheckbox.checked = data.clockMode;
                   }
                   
                   // Update preview display
                   updateTimerDisplay();
               }
           });
           
           // Listen for auto-timer events
           socket.on('autoTimerTriggered', (data) => {
               console.log('⏱️ Auto-timer triggered event received in admin:', data);
               console.log(`ℹ️ Auto-timer ξεκίνησε: ${data.minutes} λεπτά για ερώτηση`);
               
               // Optional: Update some UI indicator
               const statusElement = document.getElementById('auto-timer-status');
               if (statusElement) {
                   statusElement.textContent = `Auto-timer ενεργός (${data.minutes}min)`;
                   statusElement.style.color = '#e67e22'; // Orange during active
               }
           });
           
           socket.on('autoTimerStarted', (data) => {
               console.log('⏱️ Auto-timer started event received in admin:', data);
               console.log(`✅ Timer ξεκίνησε αυτόματα (${data.minutes} λεπτά)`);
           });
           
           socket.on('autoTimerCanceled', (data) => {
               console.log('🚫 Auto-timer canceled event received in admin:', data);
               
               const statusElement = document.getElementById('auto-timer-status');
               if (statusElement) {
                   statusElement.textContent = 'Auto-timer ακυρώθηκε';
                   statusElement.style.color = '#95a5a6'; // Gray when canceled
               }
           });
           
           socket.on('messageVisibilityUpdate', (data) => {
               console.log('Message visibility update received:', data);

               isMessageVisible = data.visible;

               const toggleButton = document.getElementById('toggle-message-btn');
               const messageContainer = document.getElementById('message-container-preview');
               const messagePreview = document.getElementById('message-preview');

               // Ενημέρωση button text και classes
               if (toggleButton) {
                   toggleButton.textContent = isMessageVisible ? '👁️' : '📤';
                   if (isMessageVisible) {
                       toggleButton.classList.remove('message-hidden');
                       toggleButton.classList.add('message-visible');
                   } else {
                       toggleButton.classList.remove('message-visible');
                       toggleButton.classList.add('message-hidden');
                   }
               }

               // Ενημέρωση message container visibility
               if (messageContainer) {
                   messageContainer.style.display = isMessageVisible ? 'flex' : 'none';
               }

               // Ενημέρωση message preview
               if (messagePreview) {
                   messagePreview.style.display = isMessageVisible ? 'block' : 'none';
               }

               // ΚΡΙΣΙΜΗ ΔΙΟΡΘΩΣΗ: Αν το message είναι ερώτηση, ξανακάλεσε το font sizing ΜΕ ΟΡΑΤΟ container
               // ΜΑ ΜΟΝΟ ΑΝ το container ΔΕΝ ΗΤΑΝ ήδη ορατό (για να αποφύγουμε duplicate calls στο local admin)
               const wasContainerVisible = messageContainer && messageContainer.style.display === 'flex';
               if (isMessageVisible && !wasContainerVisible && messagePreview && messagePreview.querySelector('.question-from-line')) {
                   // Το container ΜΟΛΙΣ έγινε ορατό, οπότε το getBoundingClientRect() θα δώσει σωστές διαστάσεις
                   // QUANTUM FIX: setTimeout αντί για RAF για να αποφύγουμε layout thrashing όταν το window είναι focused
                   setTimeout(() => {
                       const questionHTML = messagePreview.innerHTML;
                       adjustQuestionFontSize(messagePreview, questionHTML);
                       console.log('🔧 Question font size re-adjusted after container became visible (remote admin)');
                   }, 100); // 100ms delay για σιγουριά
               }

               // Προσαρμογή μεγέθους timer preview - με force update για socket events
               setTimeout(() => {
                   const messageContent = messagePreview ? messagePreview.textContent.trim() : '';
                   const hasMessageContent = messageContent !== '';
                   adjustPreviewTimerAndMessageSize(hasMessageContent && isMessageVisible, true); // Force update
                   console.log(`🔧 Timer resize after visibility update: hasContent=${hasMessageContent}, visible=${isMessageVisible}`);
               }, 50);
           });
           
           socket.on('settingsUpdate', (data) => {
               console.log('Settings received:', data);
               if (data.timer) {
                   updateTimerSettings(data.timer);
               }
               if (data.display) {
                   updateDisplaySettings(data.display);
               }
               if (data.sound) {
                   updateSoundSettings(data.sound);
               }
           });

           // Language change sync for remote admin pages
           socket.on('languageChange', async (data) => {
               console.log('🌐 Language change received from other client:', data.language);

               const selectedLang = data.language;

               // Update localStorage
               localStorage.setItem('preferredLanguage', selectedLang);

               // Update dropdown
               const languageSelector = document.getElementById('language-selector');
               if (languageSelector) {
                   languageSelector.value = selectedLang;
               }

               // UNIFIED: Works for both Electron and Browser modes
               if (typeof window.electronAPI !== 'undefined' && isI18nReady) {
                   // Electron mode
                   try {
                       await window.electronAPI.changeLanguage(selectedLang);
                       updateUITranslations();
                       updateStaticTranslations();
                       refreshEventDisplays();

                       // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" message αν εμφανίζεται
                       const messageInput = document.getElementById('message-input');
                       const messagePreview = document.getElementById('message-preview');
                       if (messageInput && messagePreview) {
                           const currentMsg = messageInput.value.trim();
                           if (currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') {
                               const newEndTimeMsg = getEndTimeMessage();
                               messageInput.value = newEndTimeMsg;
                               messagePreview.textContent = newEndTimeMsg;
                               console.log(`🔄 [Socket-Electron] Updated end time message to: ${newEndTimeMsg}`);
                           }
                       }

                       console.log(`✅ [Electron] Language changed to: ${selectedLang}`);
                   } catch (error) {
                       console.error('❌ [Electron] Failed to change language:', error);
                   }
               } else if (typeof i18next !== 'undefined' && i18next.isInitialized) {
                   // Browser mode
                   await i18next.changeLanguage(selectedLang);
                   console.log('✅ [Browser] Language changed to:', selectedLang);

                   // Update UI functions (will be defined later in the file)
                   if (typeof updateBrowserTranslations === 'function') {
                       updateBrowserTranslations();
                   }
                   if (typeof updateStaticTranslations === 'function') {
                       updateStaticTranslations();
                   }
                   if (typeof refreshEventDisplays === 'function') {
                       refreshEventDisplays();
                   }

                   // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" message αν εμφανίζεται
                   const messageInput = document.getElementById('message-input');
                   const messagePreview = document.getElementById('message-preview');
                   if (messageInput && messagePreview) {
                       const currentMsg = messageInput.value.trim();
                       if (currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') {
                           const newEndTimeMsg = getEndTimeMessage();
                           messageInput.value = newEndTimeMsg;
                           messagePreview.textContent = newEndTimeMsg;
                           console.log(`🔄 [Socket-Browser] Updated end time message to: ${newEndTimeMsg}`);
                       }
                   }
               }
           });
           
           socket.on('fullStateUpdate', (state) => {
               console.log('Full state received:', state);
               
               // Update timer
               timeLeft = state.timeLeft;
               originalTime = state.originalTime;
               warningThreshold = state.warningThreshold;
               isRunning = state.isRunning;
               
               // Update display
               updateTimerDisplay();
               updatePreviewProgressBar();
               
               // Update message με έξυπνο formatting (όπως messageUpdate)
               if (state.message) {
                   document.getElementById('message-input').value = state.message;
                   
                   // ΔΙΟΡΘΩΣΗ: Εφαρμογή σωστού formatting για ερωτήσεις
                   if (state.message.includes('Ερώτηση από:') && state.message.includes('Θέμα:')) {
                       // Εφαρμογή χρωματιστού layout για ερώτηση - ΙΔΙΟ ΜΕ toggleMessageVisibility
                       const lines = state.message.split('\n').filter(line => line.trim());
                       
                       const fromLine = lines.find(line => line.includes('Ερώτηση από:')) || 'Ερώτηση από: -';
                       const toLine = lines.find(line => line.includes('Ερώτηση προς:')) || 'Ερώτηση προς: -';
                       const subjectLine = lines.find(line => line.includes('Θέμα:')) || 'Θέμα: -';
                       
                       const subjectIndex = lines.findIndex(line => line.includes('Θέμα:'));
                       const questionText = subjectIndex >= 0 && subjectIndex < lines.length - 1 
                           ? lines.slice(subjectIndex + 1).join(' ').trim() 
                           : 'Κείμενο ερώτησης';
                       
                       const questionHTML = `
                           <div class="question-from-line" style="font-size: 2.5vh; color: #3498db; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                               ${fromLine}
                           </div>
                           <div class="question-to-line" style="font-size: 2.5vh; color: #2ecc71; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                               ${toLine}
                           </div>
                           <div class="question-subject-line" style="font-size: 3vh; color: #f39c12; font-weight: bold; margin-bottom: 2vh; text-align: center;">
                               ${subjectLine}
                           </div>
                           <div class="question-text-content" style="font-size: 3.5vh; color: #ffffff; line-height: 1.4; text-align: center;">
                               ${questionText}
                           </div>
                       `;
                       
                       messagePreview.innerHTML = questionHTML;

                       // Styling για ερωτήσεις - ΙΔΙΟ ΜΕ toggleMessageVisibility
                       messagePreview.style.textAlign = 'center';
                       messagePreview.style.lineHeight = '1.5';
                       messagePreview.style.display = 'flex';
                       messagePreview.style.flexDirection = 'column';
                       messagePreview.style.alignItems = 'center';
                       messagePreview.style.justifyContent = 'center';
                       messagePreview.style.width = '100%';
                       messagePreview.style.height = 'auto';
                       messagePreview.style.padding = '0';
                       messagePreview.style.margin = '0';

                       // ΔΙΟΡΘΩΣΗ: Περίμενε το DOM update πριν το font sizing
                       // QUANTUM FIX: setTimeout για να αποφύγουμε layout thrashing
                       setTimeout(() => {
                           adjustQuestionFontSize(messagePreview, questionHTML);
                           console.log('📋 REFRESH: Question formatting preserved with colors');
                       }, 100);

                   } else {
                       // Κανονικό μήνυμα
                       messagePreview.textContent = state.message;

                       // ΕΙΔΙΚΗ ΠΕΡΙΠΤΩΣΗ: "ΤΕΛΟΣ ΧΡΟΝΟΥ" / "TIME UP" - μεγάλο responsive font με vh units
                       if (state.message.trim() === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || state.message.trim() === 'TIME UP') {
                           messagePreview.style.setProperty('font-size', 'clamp(2rem, 8vh, 10vh)', 'important');
                           messagePreview.style.setProperty('font-weight', 'bold', 'important');
                           messagePreview.style.setProperty('text-align', 'center', 'important');
                           messagePreview.style.setProperty('white-space', 'normal', 'important');
                           messagePreview.style.setProperty('word-wrap', 'break-word', 'important');
                           console.log('🚨 "ΤΕΛΟΣ ΧΡΟΝΟΥ" με μεγάλο responsive font (8vh)');
                       } else {
                           adjustMessageFontSize(messagePreview, state.message);
                           console.log('💬 REFRESH: Regular message formatting applied');
                       }
                   }
               }
               
               // Update message visibility
if (state.messageVisible !== undefined) {
    isMessageVisible = state.messageVisible;
    const toggleButton = document.getElementById('toggle-message-btn');
    const messageContainer = document.getElementById('message-container-preview');

    toggleButton.textContent = isMessageVisible ? '👁️' : '📤';

    // Προσθήκη σωστών CSS classes
    if (isMessageVisible) {
        toggleButton.classList.remove('message-hidden');
        toggleButton.classList.add('message-visible');
    } else {
        toggleButton.classList.remove('message-visible');
        toggleButton.classList.add('message-hidden');
    }

    messagePreview.style.display = isMessageVisible ? 'block' : 'none';

    // ΚΡΙΣΙΜΟ: Εμφάνιση message container αν υπάρχει μήνυμα
    if (messageContainer && state.message && state.message.trim() !== '') {
        messageContainer.style.display = isMessageVisible ? 'flex' : 'none';
        console.log('📦 Message container visibility updated:', isMessageVisible);
    }
}
                // ΜΟΝΟ ΠΡΟΣΘΗΚΗ - μην αλλάξετε τίποτα άλλο
        if (state.timelineSettings) {
            document.getElementById('event-start-time-settings').value = state.timelineSettings.startTime || '09:00';
            document.getElementById('event-end-time-settings').value = state.timelineSettings.endTime || '17:00';
            document.getElementById('timeline-start-display').textContent = state.timelineSettings.startTime || '09:00';
            document.getElementById('timeline-end-display').textContent = state.timelineSettings.endTime || '17:00';
            updateTimelineProgress();
            console.log('Timeline settings updated from server:', state.timelineSettings);
        }
               
               
               // Update start/pause button
               if (isRunning) {
                   startPauseButton.textContent = '⏸︎';
               } else {
                   startPauseButton.textContent = '▶︎';
               }
               
               // Update clock mode checkbox and state
               if (state.clockMode !== undefined) {
                   timerState.clockMode = state.clockMode;
                   const clockModeCheckbox = document.getElementById('clock-mode-toggle');
                   if (clockModeCheckbox) {
                       clockModeCheckbox.checked = state.clockMode;
                   }
                   console.log('🕐 Clock mode state updated from server:', state.clockMode);
               }
               
               // Update title
if (state.title) {
    document.getElementById('title-input').value = state.title;
    titlePreview.textContent = state.title;
    document.title = "Admin - " + state.title;
    
    // ΠΡΟΣΘΗΚΗ: Προσαρμογή μεγέθους μετά από refresh
    adjustTitleFontSize(state.title);
}
               
               // Update display settings
               if (state.displaySettings) {
                   if (state.displaySettings.titleFontSize) {
                       titleFontSize = state.displaySettings.titleFontSize;
                       titlePreview.style.fontSize = `${titleFontSize}px`;
                   }
                   
                   if (state.displaySettings.logoDataUrl) {
                       logoDataUrl = state.displaySettings.logoDataUrl;
                       const preview = document.getElementById('logo-preview');
                       preview.src = logoDataUrl;
                       preview.style.display = 'block';
                       document.getElementById('logo-name').textContent = 'Αποθηκευμένο λογότυπο';
                   }
                   
                   if (state.displaySettings.logoSize) {
                       logoSize = state.displaySettings.logoSize;
                       const preview = document.getElementById('logo-preview');
                       if (preview && preview.style.display !== 'none') {
                           preview.style.width = `${logoSize}px`;
                       }
                   }
                   
                   if (state.displaySettings.logoPositions) {
                       setLogoPosition(state.displaySettings.logoPositions);
                   }
                   
                   if (state.displaySettings.backgroundColor) {
                       document.getElementById('background-color').value = state.displaySettings.backgroundColor;
                       
                       // Safe background preview update (element might not exist)
                       const backgroundPreview = document.getElementById('background-preview');
                       if (backgroundPreview) {
                           backgroundPreview.style.backgroundColor = state.displaySettings.backgroundColor;
                       }
                       
                       const previewScreen = document.querySelector('#preview-screen');
                       if (previewScreen) {
                           previewScreen.style.backgroundColor = state.displaySettings.backgroundColor;
                       }
                   }
               }
               
               // Update sound settings
               if (state.soundSettings) {
                   soundEnabled = state.soundSettings.enabled;
                   soundVolume = state.soundSettings.volume;
                   document.getElementById('sound-enabled').checked = soundEnabled;
                   document.getElementById('sound-volume').value = soundVolume;
               }
               
               // Update preview logos
               updatePreviewLogos();
               
               // Update sync time
               // Update vMix settings
               if (state.vmixSettings) {
                   console.log('📹 vMix settings restored from server:', state.vmixSettings);
                   
                   if (state.vmixSettings.enabled !== undefined) {
                       document.getElementById('vmix-enabled').checked = state.vmixSettings.enabled;
                   }
                   
                   // Only restore host/port from server if no localStorage exists
                   const hasLocalStorage = localStorage.getItem('vmixConnection');
                   if (!hasLocalStorage) {
                       if (state.vmixSettings.host) {
                           document.getElementById('vmix-host').value = state.vmixSettings.host;
                       }
                       if (state.vmixSettings.port) {
                           document.getElementById('vmix-port').value = state.vmixSettings.port;
                       }
                       console.log('📡 Used server vMix settings (no localStorage)');
                   } else {
                       console.log('📡 Skipped server vMix host/port (localStorage exists)');
                   }
                   if (state.vmixSettings.manualTimerInput !== undefined) {
                       const dropdown = document.getElementById('vmix-timer-input');
                       if (dropdown) {
                           // Load vMix inputs first, then set selection
                           loadVmixInputs().then(() => {
                               dropdown.value = state.vmixSettings.manualTimerInput;
                           }).catch(error => {
                               console.warn('Could not load vMix inputs for restoration:', error);
                               dropdown.value = state.vmixSettings.manualTimerInput;
                           });
                       }
                   }
               }

               lastSyncTime = Date.now();
               updateSyncStatus();

               
               
           });

           socket.on('messageUpdate', (data) => {
               console.log('Message update received from server:', data);
               const messageInput = document.getElementById('message-input');
               const messagePreview = document.getElementById('message-preview');
               const messageContainer = document.getElementById('message-container-preview');
               
               // Ενημέρωση του textarea
               if (messageInput) {
                   messageInput.value = data.message;
               }
               
               // ΔΙΟΡΘΩΣΗ: Ενημέρωση της προεπισκόπησης με έξυπνο formatting (όπως toggleMessageVisibility)
               if (messagePreview && data.message) {
                   // Έλεγχος αν είναι ερώτηση και εφαρμογή του σωστού formatting
                   if (data.message.includes('Ερώτηση από:') && data.message.includes('Θέμα:')) {
                       // Εφαρμογή χρωματιστού layout για ερώτηση - ΙΔΙΟ ΜΕ toggleMessageVisibility
                       const lines = data.message.split('\n').filter(line => line.trim());
                       
                       const fromLine = lines.find(line => line.includes('Ερώτηση από:')) || 'Ερώτηση από: -';
                       const toLine = lines.find(line => line.includes('Ερώτηση προς:')) || 'Ερώτηση προς: -';
                       const subjectLine = lines.find(line => line.includes('Θέμα:')) || 'Θέμα: -';
                       
                       const subjectIndex = lines.findIndex(line => line.includes('Θέμα:'));
                       const questionText = subjectIndex >= 0 && subjectIndex < lines.length - 1 
                           ? lines.slice(subjectIndex + 1).join(' ').trim() 
                           : 'Κείμενο ερώτησης';
                       
                       const questionHTML = `
                           <div class="question-from-line" style="font-size: 2.5vh; color: #3498db; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                               ${fromLine}
                           </div>
                           <div class="question-to-line" style="font-size: 2.5vh; color: #2ecc71; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                               ${toLine}
                           </div>
                           <div class="question-subject-line" style="font-size: 3vh; color: #f39c12; font-weight: bold; margin-bottom: 2vh; text-align: center;">
                               ${subjectLine}
                           </div>
                           <div class="question-text-content" style="font-size: 3.5vh; color: #ffffff; line-height: 1.4; text-align: center;">
                               ${questionText}
                           </div>
                       `;
                       
                       messagePreview.innerHTML = questionHTML;

                       // Styling για ερωτήσεις - ΙΔΙΟ ΜΕ toggleMessageVisibility
                       messagePreview.style.textAlign = 'center';
                       messagePreview.style.lineHeight = '1.5';
                       messagePreview.style.display = 'flex';
                       messagePreview.style.flexDirection = 'column';
                       messagePreview.style.alignItems = 'center';
                       messagePreview.style.justifyContent = 'center';
                       messagePreview.style.width = '100%';
                       messagePreview.style.height = 'auto';
                       messagePreview.style.padding = '0';
                       messagePreview.style.margin = '0';

                       // ΔΙΟΡΘΩΣΗ: Περίμενε το DOM update πριν το font sizing
                       // QUANTUM FIX: setTimeout για να αποφύγουμε layout thrashing
                       setTimeout(() => {
                           adjustQuestionFontSize(messagePreview, questionHTML);
                           console.log('📋 SERVER UPDATE: Question formatting preserved with colors');
                       }, 100);
                       
                   } else {
                       // Κανονικό μήνυμα
                       messagePreview.textContent = data.message;

                       // ΕΙΔΙΚΗ ΠΕΡΙΠΤΩΣΗ: "ΤΕΛΟΣ ΧΡΟΝΟΥ" / "TIME UP" - μεγάλο responsive font με vh units
                       if (data.message.trim() === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || data.message.trim() === 'TIME UP') {
                           messagePreview.style.setProperty('font-size', 'clamp(2rem, 8vh, 10vh)', 'important');
                           messagePreview.style.setProperty('font-weight', 'bold', 'important');
                           messagePreview.style.setProperty('text-align', 'center', 'important');
                           messagePreview.style.setProperty('white-space', 'normal', 'important');
                           messagePreview.style.setProperty('word-wrap', 'break-word', 'important');
                           console.log('🚨 "ΤΕΛΟΣ ΧΡΟΝΟΥ" με μεγάλο responsive font (8vh)');
                       } else {
                           // Όλα τα άλλα μηνύματα με auto-fit
                           adjustMessageFontSize(messagePreview, data.message);
                           console.log('💬 SERVER UPDATE: Regular message formatting applied');
                       }
                   }
               }
               
               // Εμφάνιση container αν υπάρχει μήνυμα
               if (messageContainer) {
                   if (data.message.trim() !== '') {
                       messageContainer.style.display = 'flex';
                       console.log('Message container shown for server message');
                   } else {
                       messageContainer.style.display = 'none';
                       console.log('Message container hidden - empty message');
                   }
               }
               
               // Προσαρμογή μεγέθους χρονομέτρου
               adjustPreviewTimerAndMessageSize(data.message.trim() !== '');
           });

           socket.on('flashAlert', (data) => {
               console.log('Flash alert received from server:', data);
               
               if (data.active) {
                   // ΔΙΟΡΘΩΣΗ: Μόνο local flash χωρίς socket emit για να αποφύγουμε loops
                   startFlashLocal(data.isAutomatic || false);
               } else {
                   stopFlashLocal();
               }
           });

           // Listen for secondary timer updates (vMix) - Admin Preview
           socket.on('secondaryTimerUpdate', (data) => {
               // Μόνο σημαντικές αλλαγές, όχι κάθε δευτερόλεπτο
               if (data.state === 'started' || data.state === 'stopped' || data.state === 'completed' || data.remaining === data.total) {
                   console.log('📹 Secondary timer state change:', data.state, data.title);
               }
               updateSecondaryTimerPreview(data);
           });

           // Listen for vMix settings updates - Admin Preview
           socket.on('vmixSettingsUpdate', (data) => {
               console.log('📹 vMix settings update received in admin preview:', data);
               
               // Αν απενεργοποιηθεί το vMix secondary timer, κρύψε το preview
               if (data.enabled === false) {
                   const secondaryTimerPreview = document.getElementById('secondary-timer-preview');
                   if (secondaryTimerPreview) {
                       secondaryTimerPreview.style.display = 'none';
                   }
                   console.log('🔴 vMix secondary timer preview disabled');
               }
           });
           // Listen for saved messages updates
socket.on('savedMessagesUpdate', (data) => {
    console.log('Saved messages update received:', data);
    console.log('Event data:', JSON.stringify(data, null, 2));

    // Listen for load message to textarea from Companion
// Listen for load message to textarea from Companion  
socket.on('loadMessageToTextarea', (data) => {
    console.log('Load message to textarea received:', data);
    
    const messageInput = document.getElementById('message-input');
    if (messageInput && data.message) {
        messageInput.value = data.message;
        
        // ΝΕΟ: Ενημέρωση tracking
        if (socket && socket.connected) {
            socket.emit('textareaContentChanged', { content: data.message });
        }
        
        console.log(`Message loaded to textarea from Companion: "${data.message}"`);
        
        // Visual feedback - highlight the save button briefly
        const saveBtn = document.querySelector('.save-message-btn');
        if (saveBtn) {
            saveBtn.style.boxShadow = '0 0 20px rgba(39, 174, 96, 0.8)';
            setTimeout(() => {
                saveBtn.style.boxShadow = '';
            }, 2000);
        }
    } else {
        console.error('Failed to load message - element not found or no message data');
    }
});

    // Ενημέρωση του local array
    if (data.allMessages && Array.isArray(data.allMessages)) {
        savedMessages = data.allMessages;
        console.log('Updated savedMessages array:', savedMessages);
        renderSavedMessages();
        console.log('renderSavedMessages() called. Total count:', savedMessages.length);
    } else {
        console.error('Invalid data received:', data);
    }
});
// Listen for timeline settings updates
socket.on('settingsUpdate', (data) => {
    console.log('Settings received:', data);
    
    // ... existing code for timer, display, sound ...
    
    // ΠΡΟΣΘΗΚΗ: Timeline settings update
    if (data.timeline) {
        document.getElementById('event-start-time-settings').value = data.timeline.startTime || '09:00';
        document.getElementById('event-end-time-settings').value = data.timeline.endTime || '17:00';
        
        document.getElementById('timeline-start-display').textContent = data.timeline.startTime || '09:00';
        document.getElementById('timeline-end-display').textContent = data.timeline.endTime || '17:00';
        
        updateTimelineProgress();
        console.log('Timeline settings updated from server');
    }
});
// Listen for HDMI toggle from Companion
socket.on('companionHDMIToggle', (data) => {
    console.log('HDMI Toggle received from Companion:', data);
    
    // Καλούμε απευθείας την ίδια function που καλεί το κουμπί στο admin
    toggleHDMITimer();
    
    // Optional: Visual feedback - flash του κουμπιού
    const hdmiBtn = document.getElementById('hdmi-timer-btn');
    if (hdmiBtn) {
        hdmiBtn.style.boxShadow = '0 0 20px rgba(52, 152, 219, 0.8)';
        setTimeout(() => {
            hdmiBtn.style.boxShadow = '';
        }, 1500);
    }
});
socket.on('companionMessageToggle', (data) => {
    console.log('Message Toggle received from Companion:', data);
    
    // ΜΟΝΟ toggle visibility - ΟΧΙ update μηνύματος
    toggleMessageVisibility();
    
    // Visual feedback
    const toggleBtn = document.getElementById('toggle-message-btn');
    if (toggleBtn) {
        toggleBtn.style.boxShadow = '0 0 20px rgba(52, 152, 219, 0.8)';
        setTimeout(() => {
            toggleBtn.style.boxShadow = '';
        }, 1500);
    }
});
// Listen for message update from Companion (no toggle)
socket.on('companionMessageUpdate', (data) => {
    console.log('Message Update received from Companion:', data);
    
    // ΜΟΝΟ update μηνύματος - ΟΧΙ toggle visibility
    updateMessage();
    
    // Visual feedback για το update button
    const updateBtn = document.querySelector('button[onclick="updateMessage()"]');
    if (updateBtn) {
        updateBtn.style.boxShadow = '0 0 20px rgba(52, 152, 219, 0.8)';
        setTimeout(() => {
            updateBtn.style.boxShadow = '';
        }, 1500);
    }
});
       }
       
       // ------ TIMER FUNCTIONS ------
       function startPauseTimer() {
           if (isRunning) {
               // Pause - Στέλνουμε εντολή στον server
               if (isConnected) {
                   socket.emit('command', { type: 'timer', action: 'pause' });
               } else {
                   console.log('Δεν υπάρχει σύνδεση με τον server');
               }
           } else {
               // Start - Στέλνουμε εντολή στον server
               if (isConnected) {
                   socket.emit('command', { type: 'timer', action: 'start' });
               } else {
                   console.log('Δεν υπάρχει σύνδεση με τον server');
               }
           }
       }
       
       function resetTimer() {
           console.log('resetTimer called');
           
           // Σταμάτημα του flash αν τρέχει
           if (isFlashAlertActive) {
               stopFlash();
           }
           
           // Καθαρισμός μηνύματος ΜΟΝΟ στο textarea
           document.getElementById('message-input').value = '';
           
           // Στέλνουμε εντολή reset στον server
           if (isConnected) {
               socket.emit('command', { type: 'timer', action: 'reset' });
           } else {
               console.log('Δεν υπάρχει σύνδεση με τον server');
           }
           
           console.log('Reset sent to server - waiting for server response');
       }
       
       function adjustTime(seconds) {
           if (isConnected) {
               socket.emit('adjustTime', { seconds: seconds });
           } else {
               timeLeft += seconds;
               if (timeLeft < 0) timeLeft = 0;
               updateTimerDisplay();
               updatePreviewProgressBar();
           }
       }
       
       function updateTimerDisplay() {
   const timerElement = document.getElementById('timer-preview');
   
   // Check if clock mode is enabled
   if (timerState.clockMode) {
       // Display current time instead of countdown
       const now = new Date();
       const hours = now.getHours();
       const minutes = now.getMinutes();
       const seconds = now.getSeconds();
       
       timerElement.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
       timerElement.className = 'timer-preview'; // Normal styling for clock mode
       
       // Fix preview timer size
       const messagePreview = document.getElementById('message-preview');
       const hasMessage = messagePreview && messagePreview.textContent.trim() !== '';
       adjustPreviewTimerAndMessageSize(hasMessage && isMessageVisible);
       return;
   }
   
   if (timeLeft < 0) {
       // Αρνητικός χρόνος - OVERTIME με pulsating
       const overtimeSeconds = Math.abs(timeLeft);
       const hours = Math.floor(overtimeSeconds / 3600);
       const minutes = Math.floor((overtimeSeconds % 3600) / 60);
       const seconds = overtimeSeconds % 60;
       
       if (hours > 0) {
           timerElement.textContent = `+${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
       } else {
           timerElement.textContent = `+${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
       }
       timerElement.className = 'timer-preview overtime';
       
       // Fix preview timer size after overtime display
       const messagePreview = document.getElementById('message-preview');
       const hasMessage = messagePreview && messagePreview.textContent.trim() !== '';
       return;
   }
   
   // Θετικός χρόνος ή μηδέν
   const hours = Math.floor(timeLeft / 3600);
   const minutes = Math.floor((timeLeft % 3600) / 60);
   const seconds = Math.max(0, timeLeft % 60);
   
   if (hours > 0) {
       timerElement.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
   } else {
       timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
   }
   
   // Καθαρισμός classes
   timerElement.className = 'timer-preview';
   
   if (timeLeft <= warningThreshold && timeLeft > 0) {
       timerElement.classList.add('warning');
   } else if (timeLeft === 0) {
       timerElement.classList.add('danger');
   }
   
   // Fix preview timer size after normal display
   const messagePreview = document.getElementById('message-preview');
   const hasMessage = messagePreview && messagePreview.textContent.trim() !== '';
   adjustPreviewTimerAndMessageSize(hasMessage && isMessageVisible);
}
       
       function updatePreviewProgressBar() {
           const percentage = (timeLeft / originalTime) * 100;
           previewProgressBar.style.width = `${percentage}%`;
           
           previewProgressBar.classList.remove('warning', 'danger');
           
           if (timeLeft <= warningThreshold && timeLeft > 0) {
               previewProgressBar.classList.add('warning');
           } else if (timeLeft === 0) {
               previewProgressBar.classList.add('danger');
           }
       }
       
       // ------ MESSAGE FUNCTIONS ------
      

       function clearMessage() {
    // Καθαρισμός του textarea
    document.getElementById('message-input').value = '';
    
    // ΣΗΜΑΝΤΙΚΟ: Επαναφορά του κουμπιού σε "Αποστολή"
    const toggleButton = document.getElementById('toggle-message-btn');
    
    if (toggleButton) {
        toggleButton.textContent = '📤';
        toggleButton.classList.remove('message-visible');
        toggleButton.classList.add('message-hidden');
    }
    
    // Επαναφορά της κατάστασης ορατότητας
    isMessageVisible = false;
    
    // Απόκρυψη του preview container
    const messageContainer = document.getElementById('message-container-preview');
    if (messageContainer) {
        messageContainer.style.display = 'none';
    }
    
    // Καθαρισμός του preview
    const messagePreview = document.getElementById('message-preview');
    if (messagePreview) {
        messagePreview.textContent = '';
    }
    
    // Αποστολή κενού μηνύματος στον server (για καθαρισμό)
    if (isConnected) {
        socket.emit('messageUpdate', {
            message: ''
        });
        
        // Στέλνουμε και messageVisibilityUpdate για να ενημερωθεί το questions-admin.html
        socket.emit('messageVisibilityUpdate', {
            visible: false
        });
    }
    
    // Προσαρμογή μεγέθους timer (επιστροφή σε μεγάλο)
    adjustPreviewTimerAndMessageSize(false);
    
    console.log('✅ Message cleared - Button reset to "Αποστολή"');
}

      function adjustPreviewTimerAndMessageSize(hasMessage, forceUpdate = false) {
    // THROTTLING: Μέγιστο 1 φορά κάθε 200ms (εκτός αν force)
    const now = Date.now();
    if (!forceUpdate && now - (adjustPreviewTimerAndMessageSize.lastCall || 0) < 200) {
        return; // ΣΤΑΜΑΤΑ - πολύ νωρίς για νέα κλήση
    }
    adjustPreviewTimerAndMessageSize.lastCall = now;
    
    const timerPreviewElement = document.getElementById('timer-preview');
    const messageContainer = document.getElementById('message-container-preview');
    const messageSection = document.querySelector('#preview-screen .message-section'); // ΠΡΟΣΘΗΚΗ
    const previewMainContent = document.querySelector('#preview-screen .preview-main-content');

    if (!timerPreviewElement || !previewMainContent) return;
    
    if (hasMessage && isMessageVisible) {
        // COMPACT MODE: timer μικρότερος και ανεβάζουμε τη main-content
        timerPreviewElement.style.fontSize = '3vh';
        timerPreviewElement.style.margin = '0.3vh 0';
        
        // ΚΛΕΙΔΙ: Αλλάζουμε τη justify-content για να ανεβάσουμε το περιεχόμενο
        previewMainContent.style.justifyContent = 'flex-start';
        previewMainContent.style.paddingTop = '0.5vh';  // Μικρό padding από πάνω
        previewMainContent.style.gap = '0.5vh';         // Μικρότερο gap
        
        if (messageContainer) messageContainer.style.display = 'flex';
        if (messageSection) messageSection.style.display = 'flex'; // ΠΡΟΣΘΗΚΗ: εμφάνιση section

        console.log('🔧 Admin preview: COMPACT mode - content moved UP');
        
    } else {
        // FULL MODE: timer στο κανονικό μέγεθος και κεντραρισμένο
        timerPreviewElement.style.fontSize = '10vh';
        timerPreviewElement.style.margin = '2vh 0';
        
        // ΕΠΑΝΑΦΟΡΑ: Κεντραρισμένο περιεχόμενο
        previewMainContent.style.justifyContent = 'center';
        previewMainContent.style.paddingTop = '1vh';    // Επαναφορά padding
        previewMainContent.style.gap = '1vh';           // Επαναφορά gap
        
        if (messageContainer && !isMessageVisible) {
            messageContainer.style.display = 'none';
        }
        if (messageSection && !isMessageVisible) {
            messageSection.style.display = 'none'; // ΠΡΟΣΘΗΚΗ: απόκρυψη ολόκληρης section
        }

        console.log('🔧 Admin preview: FULL mode - content centered');
    }
    
    console.log('Timer positioning adjusted:', {
        hasMessage: hasMessage,
        isVisible: isMessageVisible,
        fontSize: timerPreviewElement.style.fontSize,
        justifyContent: previewMainContent.style.justifyContent
    });
}

       function adjustMessageFontSize(element, text) {
           if (!element) return;

           if (!text || text.trim() === '') {
               element.style.fontSize = '';
               element.style.lineHeight = '';
               return;
           }

           // AUTO-FIT ALGORITHM: Βρίσκει το μέγιστο font size που χωράει όλο το κείμενο

           // 1. Πάρε τον πραγματικό χώρο του container
           const container = element.parentElement; // #message-container-preview
           if (!container) return;

           // ΝΕΟ: Skip AUTO-FIT αν το container είναι κρυφό
           if (container.style.display === 'none' || !container.offsetHeight) {
               console.log('⏭️ AUTO-FIT skipped: Container is hidden');
               return;
           }

           const containerRect = container.getBoundingClientRect();
           const availableWidth = containerRect.width - 20; // -20px για padding
           const availableHeight = containerRect.height - 20; // -20px για padding

           // ΝΕΟ: Extra validation - αν το height είναι αρνητικό ή μηδέν, skip
           if (availableHeight <= 0) {
               console.log('⏭️ AUTO-FIT skipped: Invalid available height (' + availableHeight + 'px)');
               return;
           }

           // 2. Λίστα font sizes για δοκιμή (από μεγάλο προς μικρό)
           const testSizes = [20, 18, 16, 14, 12, 10, 8, 6, 5, 4, 3.5, 3, 2.5, 2, 1.5, 1];

           let bestFontSize = 1; // fallback

           // 3. Δοκίμασε κάθε μέγεθος και δες αν χωράει
           for (let fontSize of testSizes) {
               // Δημιούργησε temporary element για μέτρηση
               const tempElement = document.createElement('div');
               tempElement.style.position = 'absolute';
               tempElement.style.visibility = 'hidden';
               tempElement.style.fontSize = fontSize + 'vh';
               tempElement.style.lineHeight = '1.1';
               tempElement.style.fontFamily = getComputedStyle(element).fontFamily;
               tempElement.style.fontWeight = getComputedStyle(element).fontWeight;
               tempElement.style.width = availableWidth + 'px';
               tempElement.style.wordWrap = 'break-word';
               tempElement.style.overflowWrap = 'break-word';
               tempElement.textContent = text;

               document.body.appendChild(tempElement);

               // Μέτρησε το πραγματικό ύψος που καταλαμβάνει
               const actualHeight = tempElement.offsetHeight;

               document.body.removeChild(tempElement);

               // Αν χωράει στον διαθέσιμο χώρο, αυτό είναι το μέγεθός μας!
               if (actualHeight <= availableHeight) {
                   bestFontSize = fontSize;
                   console.log(`✅ AUTO-FIT: ${fontSize}vh χωράει (${actualHeight}px <= ${availableHeight}px)`);
                   break;
               } else {
                   console.log(`❌ AUTO-FIT: ${fontSize}vh δεν χωράει (${actualHeight}px > ${availableHeight}px)`);
               }
           }

           // 4. Εφάρμοσε το βέλτιστο μέγεθος
           element.style.setProperty('font-size', bestFontSize + 'vh', 'important');
           element.style.setProperty('line-height', '1.1', 'important');
           element.style.setProperty('word-wrap', 'break-word', 'important');
           element.style.setProperty('overflow-wrap', 'break-word', 'important');

           console.log(`🎯 AUTO-FIT FINAL: "${text.substring(0, 50)}..." → ${bestFontSize}vh`);
       }
       
      async function saveMessage() {
    console.log('saveMessage() called!'); // ΠΡΟΣΘΗΚΗ
    const messageContent = document.getElementById('message-input').value;
    console.log('Message content:', messageContent); // ΠΡΟΣΘΗΚΗ
    
    if (messageContent.trim()) {
        console.log('Sending to server...'); // ΠΡΟΣΘΗΚΗ
        try {
            // Αποστολή στον server
            const response = await fetch('/api/saved-messages/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: messageContent.trim()
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                console.log('Message saved to server:', data.message.content);
                // Το renderSavedMessages θα καλεστεί αυτόματα από το WebSocket event
                
                // 💾 EVENT-DRIVEN SAVE: Αποθήκευση όταν δημιουργείται message
                triggerEventDrivenSave('message created');
            } else {
                console.error('Failed to save message');
                const currentLang = localStorage.getItem('preferredLanguage') || 'el';
                const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
                const message = currentLang === 'en' ? 'Error saving message' : 'Σφάλμα κατά την αποθήκευση του μηνύματος';
                showCustomAlert(title, message);
            }
        } catch (error) {
            console.error('Error saving message:', error);
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Server connection error' : 'Σφάλμα σύνδεσης με τον server';
            showCustomAlert(title, message);
        }
    }
}
// AUTO-FIT αλγόριθμος για ερωτήσεις με διατήρηση πολύχρωμων styles
function adjustQuestionFontSize(messageElement, questionHTML) {
    if (!messageElement) return;

    // Εξαγωγή του συνολικού κειμένου
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = questionHTML;
    const text = tempDiv.textContent || tempDiv.innerText || '';

    if (!text || text.trim() === '') {
        return;
    }

    console.log(`🎨 AUTO-FIT Questions: "${text.substring(0, 50)}..." (${text.length} chars)`);

    // 1. Πάρε τον πραγματικό χώρο του container
    const container = messageElement.parentElement; // #message-container-preview
    if (!container) return;

    const containerRect = container.getBoundingClientRect();
    const availableWidth = containerRect.width - 20; // -20px για padding
    const availableHeight = containerRect.height - 20; // -20px για padding

    // 2. Λίστα font sizes για δοκιμή (ΜΕΓΑΛΎΤΕΡΑ μεγέθη για καλύτερη εκμετάλλευση)
    const testSizes = [25, 22, 20, 18, 16, 14, 12, 10, 8, 6, 5, 4, 3.5, 3, 2.5, 2, 1.5, 1];

    let bestFontSize = 1; // fallback

    // 3. Δοκίμασε κάθε μέγεθος με ΑΚΡΙΒΗ μέτρηση (όπως τα messages)
    for (let fontSize of testSizes) {
        // Δημιούργησε temporary element με την ΑΚΡΙΒΗ δομή της ερώτησης
        const tempElement = document.createElement('div');
        tempElement.style.position = 'absolute';
        tempElement.style.visibility = 'hidden';
        tempElement.style.width = availableWidth + 'px';
        tempElement.style.fontFamily = getComputedStyle(messageElement).fontFamily;
        tempElement.style.fontWeight = getComputedStyle(messageElement).fontWeight;
        tempElement.style.display = 'flex';
        tempElement.style.flexDirection = 'column';
        tempElement.style.alignItems = 'center';
        tempElement.style.justifyContent = 'center'; // ΠΡΟΣΘΗΚΗ: κεντραρισμένο
        tempElement.style.padding = '5px'; // ΠΡΟΣΘΗΚΗ: ίδιο padding με το πραγματικό

        // Δημιούργησε τα styled elements ακριβώς όπως στην πραγματικότητα
        tempElement.innerHTML = questionHTML;

        // Εφάρμοσε τα ΑΚΡΙΒΗ μεγέθη που θα χρησιμοποιηθούν
        const fromLine = tempElement.querySelector('.question-from-line');
        const toLine = tempElement.querySelector('.question-to-line');
        const subjectLine = tempElement.querySelector('.question-subject-line');
        const textContent = tempElement.querySelector('.question-text-content');

        // ΙΔΙΑ αναλογία με την τελική εφαρμογή
        if (fromLine) {
            fromLine.style.fontSize = (fontSize * 0.6) + 'vh';
            fromLine.style.lineHeight = '1.1';
            fromLine.style.marginBottom = '1vh';
        }
        if (toLine) {
            toLine.style.fontSize = (fontSize * 0.6) + 'vh';
            toLine.style.lineHeight = '1.1';
            toLine.style.marginBottom = '1vh';
        }
        if (subjectLine) {
            subjectLine.style.fontSize = (fontSize * 0.7) + 'vh';
            subjectLine.style.lineHeight = '1.1';
            subjectLine.style.marginBottom = '2vh';
        }
        if (textContent) {
            textContent.style.fontSize = fontSize + 'vh';
            textContent.style.lineHeight = '1.1';
        }

        document.body.appendChild(tempElement);

        // Μέτρησε το πραγματικό ύψος που καταλαμβάνει
        const actualHeight = tempElement.offsetHeight;

        document.body.removeChild(tempElement);

        // Αν χωράει στον διαθέσιμο χώρο, αυτό είναι το μέγεθός μας!
        if (actualHeight <= availableHeight) {
            bestFontSize = fontSize;
            console.log(`✅ AUTO-FIT Questions: ${fontSize}vh χωράει (${actualHeight}px <= ${availableHeight}px)`);
            break;
        } else {
            console.log(`❌ AUTO-FIT Questions: ${fontSize}vh δεν χωράει (${actualHeight}px > ${availableHeight}px)`);
        }
    }

    // Υπολογισμός αναλογικών μεγεθών για κάθε τμήμα της ερώτησης
    const fromSize = bestFontSize * 0.6;     // 60% για "Από"
    const toSize = bestFontSize * 0.6;       // 60% για "Προς"
    const subjectSize = bestFontSize * 0.7;  // 70% για "Θέμα"
    const textSize = bestFontSize;           // 100% για κύριο κείμενο

    // Εφαρμογή των νέων μεγεθών με διατήρηση πολύχρωμων styles
    const fromLine = messageElement.querySelector('.question-from-line');
    const toLine = messageElement.querySelector('.question-to-line');
    const subjectLine = messageElement.querySelector('.question-subject-line');
    const textContent = messageElement.querySelector('.question-text-content');

    if (fromLine) {
        fromLine.style.setProperty('font-size', fromSize + 'vh', 'important');
        fromLine.style.setProperty('line-height', '1.1', 'important');
        fromLine.style.setProperty('color', '#3498db', 'important'); // Μπλε χρώμα
        fromLine.style.setProperty('font-weight', 'bold', 'important');
        fromLine.style.setProperty('text-align', 'center', 'important');
    }
    if (toLine) {
        toLine.style.setProperty('font-size', toSize + 'vh', 'important');
        toLine.style.setProperty('line-height', '1.1', 'important');
        toLine.style.setProperty('color', '#2ecc71', 'important'); // Πράσινο χρώμα
        toLine.style.setProperty('font-weight', 'bold', 'important');
        toLine.style.setProperty('text-align', 'center', 'important');
    }
    if (subjectLine) {
        subjectLine.style.setProperty('font-size', subjectSize + 'vh', 'important');
        subjectLine.style.setProperty('line-height', '1.1', 'important');
        subjectLine.style.setProperty('color', '#f39c12', 'important'); // Πορτοκαλί χρώμα
        subjectLine.style.setProperty('font-weight', 'bold', 'important');
        subjectLine.style.setProperty('text-align', 'center', 'important');
    }
    if (textContent) {
        textContent.style.setProperty('font-size', textSize + 'vh', 'important');
        textContent.style.setProperty('line-height', '1.1', 'important');
        textContent.style.setProperty('color', '#ffffff', 'important'); // Λευκό χρώμα
        textContent.style.setProperty('font-weight', 'normal', 'important');
        textContent.style.setProperty('text-align', 'center', 'important');
    }

    console.log(`🎯 AUTO-FIT Questions FINAL: από=${fromSize.toFixed(1)}vh, προς=${toSize.toFixed(1)}vh, θέμα=${subjectSize.toFixed(1)}vh, κείμενο=${textSize.toFixed(1)}vh`);
}
       
       function renderSavedMessages() {
    const messagesList = document.getElementById('messages-list');
    
    if (!messagesList) return;
    
    if (savedMessages.length === 0) {
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const noMessagesText = currentLang === 'en' ? 'No saved messages' : 'Δεν υπάρχουν αποθηκευμένα μηνύματα';
        messagesList.innerHTML = `<p>${noMessagesText}</p>`;
        return;
    }
    
    messagesList.innerHTML = '';
    
    savedMessages.forEach((messageObj, index) => {
        const messageItem = document.createElement('div');
        messageItem.className = 'message-item';
        
        messageItem.innerHTML = `
            <div>${messageObj.content}</div>
            <div class="message-actions">
                <button onclick="loadMessage(${index})">Φόρτωση</button>
                <button onclick="editMessage(${index})">Επεξ.</button>
                <button onclick="deleteMessage('${messageObj.id}')">Διαγραφή</button>
            </div>
        `;
        
        messagesList.appendChild(messageItem);
    });
}

       function loadMessage(index) {
           const message = savedMessages[index];
           // ΜΟΝΟ στο textarea - ΔΕΝ στέλνουμε στο timer
           document.getElementById('message-input').value = message.content;
           
           console.log('Μήνυμα φορτώθηκε στο textarea (δεν στάλθηκε στο timer):', message.content);
       }

       function editMessage(index) {
    const message = savedMessages[index];
    const messageItems = document.querySelectorAll('.message-item');
    
    if (index >= messageItems.length) return;
    
    const messageItem = messageItems[index];
    
    // Απλή αντικατάσταση - όχι περίπλοκα escaping
    messageItem.innerHTML = `
        <textarea class="inline-edit-textarea">${message.content}</textarea>
        <div class="message-actions">
            <button onclick="loadMessage(${index})">Φόρτωση</button>
            <button onclick="saveEditedMessage(${index})" class="save-edit-inline">ΟΚ</button>
            <button onclick="renderSavedMessages()">Ακύρωση</button>
        </div>
    `;
    
    // Editing class
    messageItem.classList.add('editing-inline');
    
    // Focus
    const textarea = messageItem.querySelector('.inline-edit-textarea');
    setTimeout(() => {
        textarea.focus();
        textarea.select();
    }, 50);
    
    // Keyboard shortcuts
    textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
            saveEditedMessage(index);
        } else if (e.key === 'Escape') {
            renderSavedMessages(); // ΑΠΛΟ!
        }
    });
}

function saveEditedMessage(index) {
    const messageItems = document.querySelectorAll('.message-item');
    const messageItem = messageItems[index];
    const textarea = messageItem.querySelector('.inline-edit-textarea');
    const newContent = textarea.value.trim();
    const messageId = savedMessages[index].id;
    
    if (!newContent) {
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
        const message = currentLang === 'en' ? 'Message cannot be empty!' : 'Το μήνυμα δεν μπορεί να είναι κενό!';
        showCustomAlert(title, message);
        return;
    }
    
    fetch('/api/saved-messages/edit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            id: messageId, 
            newContent: newContent 
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('✅ Message edited successfully');
            
            // 🔥 Event-driven save: Message edited
            triggerEventDrivenSave('saved message edited');
        } else {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Error during edit operation' : 'Σφάλμα κατά την επεξεργασία';
            showCustomAlert(title, message);
            renderSavedMessages();
        }
    })
    .catch(error => {
       const currentLang = localStorage.getItem('preferredLanguage') || 'el';
       const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
       const message = currentLang === 'en' ? 'Connection error' : 'Σφάλμα σύνδεσης';
       showCustomAlert(title, message);
        renderSavedMessages();
    });
}

       function toggleMessageVisibility() {
    // ΑΝ δεν είναι ορατό, πρώτα στέλνουμε το μήνυμα
    if (!isMessageVisible) {
        const messageContent = document.getElementById('message-input').value.trim();
        
        if (messageContent === '') {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Please enter a message before sending' : 'Παρακαλώ εισάγετε μήνυμα πριν την αποστολή';
            showCustomAlert(title, message);
            return;
        }
        
        // ΝΕΟΣ ΤΡΟΠΟΣ: Ενημέρωση preview με SMART FORMATTING
        const messagePreview = document.getElementById('message-preview');
        
        // Έλεγχος αν είναι ερώτηση και εφαρμογή του σωστού formatting
        if (messageContent.includes('Ερώτηση από:') && messageContent.includes('Θέμα:')) {
            // Εφαρμογή χρωματιστού layout για ερώτηση
            const lines = messageContent.split('\n').filter(line => line.trim());
            
            const fromLine = lines.find(line => line.includes('Ερώτηση από:')) || 'Ερώτηση από: -';
            const toLine = lines.find(line => line.includes('Ερώτηση προς:')) || 'Ερώτηση προς: -';
            const subjectLine = lines.find(line => line.includes('Θέμα:')) || 'Θέμα: -';
            
            const subjectIndex = lines.findIndex(line => line.includes('Θέμα:'));
            const questionText = subjectIndex >= 0 && subjectIndex < lines.length - 1 
                ? lines.slice(subjectIndex + 1).join(' ').trim() 
                : 'Κείμενο ερώτησης';
            
            const questionHTML = `
                <div class="question-from-line" style="font-size: 2.5vh; color: #3498db; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                    ${fromLine}
                </div>
                <div class="question-to-line" style="font-size: 2.5vh; color: #2ecc71; font-weight: bold; margin-bottom: 1vh; text-align: center;">
                    ${toLine}
                </div>
                <div class="question-subject-line" style="font-size: 3vh; color: #f39c12; font-weight: bold; margin-bottom: 2vh; text-align: center;">
                    ${subjectLine}
                </div>
                <div class="question-text-content" style="font-size: 3.5vh; color: #ffffff; line-height: 1.4; text-align: center;">
                    ${questionText}
                </div>
            `;
            
            messagePreview.innerHTML = questionHTML;
            
            // Styling για ερωτήσεις
            messagePreview.style.textAlign = 'center';
            messagePreview.style.lineHeight = '1.5';
            messagePreview.style.display = 'flex';
            messagePreview.style.flexDirection = 'column';
            messagePreview.style.alignItems = 'center';
            messagePreview.style.justifyContent = 'center';
            messagePreview.style.width = '100%';
            messagePreview.style.height = 'auto';
            messagePreview.style.padding = '0';
            messagePreview.style.margin = '0';
            
            adjustQuestionFontSize(messagePreview, questionHTML);
            console.log('📋 TOGGLE: Question formatting applied');

        } else {
            // Κανονικό μήνυμα
            messagePreview.textContent = messageContent;

            // ΕΙΔΙΚΗ ΠΕΡΙΠΤΩΣΗ: "ΤΕΛΟΣ ΧΡΟΝΟΥ" / "TIME UP" - μεγάλο responsive font με vh units
            if (messageContent.trim() === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || messageContent.trim() === 'TIME UP') {
                messagePreview.style.setProperty('font-size', 'clamp(2rem, 8vh, 10vh)', 'important');
                messagePreview.style.setProperty('font-weight', 'bold', 'important');
                messagePreview.style.setProperty('text-align', 'center', 'important');
                messagePreview.style.setProperty('white-space', 'normal', 'important');
                messagePreview.style.setProperty('word-wrap', 'break-word', 'important');
                console.log('🚨 "ΤΕΛΟΣ ΧΡΟΝΟΥ" με μεγάλο responsive font (8vh)');
            } else {
                adjustMessageFontSize(messagePreview, messageContent);
                console.log('💬 TOGGLE: Regular message formatting applied');
            }
        }
        
        // Στέλνουμε μήνυμα στον server
        if (isConnected) {
            console.log('Στέλνουμε μήνυμα στον server:', messageContent);
            socket.emit('messageUpdate', {
                message: messageContent
            });
        }
    }
    
    // Τώρα κάνουμε toggle της ορατότητας
    isMessageVisible = !isMessageVisible;
    
    console.log('toggleMessageVisibility called, isMessageVisible:', isMessageVisible);
    
    const toggleButton = document.getElementById('toggle-message-btn');
    
    // Dynamic styling
    if (isMessageVisible) {
        toggleButton.textContent = '👁️';
        toggleButton.classList.remove('message-hidden');
        toggleButton.classList.add('message-visible');
    } else {
        toggleButton.textContent = '📤';
        toggleButton.classList.remove('message-visible');
        toggleButton.classList.add('message-hidden');
    }
    
    const messagePreview = document.getElementById('message-preview');
    const messageContainer = document.getElementById('message-container-preview');
    
    // Ενημέρωση της προεπισκόπησης
    if (messageContainer) {
        messageContainer.style.display = isMessageVisible ? 'flex' : 'none';
    }
    
    // ΠΡΟΣΘΗΚΗ: Προσαρμογή μεγέθους timer - έλεγχος για περιεχόμενο
    const messageContent = messagePreview ? messagePreview.textContent.trim() : '';
    const hasMessageContent = messageContent !== '';
    adjustPreviewTimerAndMessageSize(hasMessageContent && isMessageVisible);
    
    // Στέλνουμε την ενημέρωση ορατότητας στον server
    if (isConnected) {
        socket.emit('messageVisibilityUpdate', {
            visible: isMessageVisible
        });
    }
}
       // ΣΟΒΑΡΗ ΛΥΣΗ: Custom HTML dialog που δουλεύει πάντα σε fullscreen
function showCustomConfirm(title, message) {
    return new Promise((resolve) => {
        // Δημιουργία modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        `;
        
        // Δημιουργία dialog box
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: #2c3e50;
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        `;
        
        dialog.innerHTML = `
            <h3 style="margin: 0 0 15px 0; color: #3498db;">${title}</h3>
            <p style="margin: 0 0 25px 0; line-height: 1.5;">${message}</p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="custom-cancel" style="background: #95a5a6; color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 1rem;">
                    Άκυρο
                </button>
                <button id="custom-ok" style="background: #e74c3c; color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 1rem;">
                    OK
                </button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Focus στο OK button
        const okBtn = document.getElementById('custom-ok');
        const cancelBtn = document.getElementById('custom-cancel');
        
        setTimeout(() => okBtn.focus(), 100);
        
        // Event handlers
        okBtn.onclick = () => {
            document.body.removeChild(overlay);
            resolve(true);
        };
        
        cancelBtn.onclick = () => {
            document.body.removeChild(overlay);
            resolve(false);
        };
        
        // ESC key support
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(overlay);
                document.removeEventListener('keydown', escHandler);
                resolve(false);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        // Enter key support
        const enterHandler = (e) => {
            if (e.key === 'Enter') {
                document.body.removeChild(overlay);
                document.removeEventListener('keydown', enterHandler);
                resolve(true);
            }
        };
        document.addEventListener('keydown', enterHandler);
    });
}
// Custom alert dialog που δουλεύει σε fullscreen
function showCustomAlert(title, message) {
    return new Promise((resolve) => {
        // Δημιουργία modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        `;
        
        // Δημιουργία dialog box
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: #2c3e50;
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        `;
        
        dialog.innerHTML = `
            <h3 style="margin: 0 0 15px 0; color: #f39c12;">⚠️ ${title}</h3>
            <p style="margin: 0 0 25px 0; line-height: 1.5;">${message}</p>
            <div style="display: flex; justify-content: center;">
                <button id="custom-alert-ok" style="background: #3498db; color: white; border: none; padding: 12px 30px; border-radius: 5px; cursor: pointer; font-size: 1rem;">
                    OK
                </button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Focus στο OK button
        const okBtn = document.getElementById('custom-alert-ok');
        setTimeout(() => okBtn.focus(), 100);
        
        // Event handlers
        okBtn.onclick = () => {
            document.body.removeChild(overlay);
            resolve();
        };
        
        // ESC και Enter support
        const keyHandler = (e) => {
            if (e.key === 'Escape' || e.key === 'Enter') {
                document.body.removeChild(overlay);
                document.removeEventListener('keydown', keyHandler);
                resolve();
            }
        };
        document.addEventListener('keydown', keyHandler);
    });
}
// CSS animations
const style = document.createElement('style');
style.textContent = `
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    @keyframes slideIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }
`;
document.head.appendChild(style);
      // Διορθωμένη deleteMessage χωρίς bug διπλού κλικ
// Enhanced deleteMessage με debug logging
// Enhanced deleteMessage με custom dialog
async function deleteMessage(messageId) {
    if (window.deletingInProgress) return;
    window.deletingInProgress = true;
    
    try {
        // Χρήση custom dialog αντί για Electron dialog
        const userConfirmed = await customConfirm(
            'Διαγραφή Μηνύματος',
            'Είστε σίγουροι ότι θέλετε να διαγράψετε αυτό το μήνυμα;',
            'Διαγραφή',
            'Ακύρωση'
        );
        
        if (!userConfirmed) return;
        
        // Υπόλοιπος κώδικας ίδιος...
        const response = await fetch(`/api/saved-messages/${messageId}`, {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.success) {
            console.log('✅ DELETE SUCCESS:', data.deleted.content);
            
            // 🔥 Event-driven save: Message deleted
            triggerEventDrivenSave('saved message deleted');
        } else {
            console.error('❌ DELETE FAILED:', data.error);
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Error deleting message' : 'Σφάλμα κατά τη διαγραφή του μηνύματος';
            await showCustomAlert(title, message);
        }
        
    } catch (error) {
        console.error('💥 DELETE ERROR:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Connection Error' : 'Σφάλμα Σύνδεσης';
        const message = currentLang === 'en' ? 'Server connection error' : 'Σφάλμα σύνδεσης με τον server';
        await showCustomAlert(title, message);
    } finally {
        window.deletingInProgress = false;
    }
}
       
       // ------ HANDLE INCOMING COMMANDS ------
       function handleCommand(data) {
           console.log('handleCommand called with:', data);
           
           if (data.type !== 'timer') return;
           
           switch (data.action) {
               case 'start':
                   isRunning = true;
                   startPauseButton.textContent = '⏸︎';
                   console.log('Timer started by server');
                   break;
               case 'pause':
                   isRunning = false;
                   startPauseButton.textContent = '▶︎';
                   console.log('Timer paused by server');
                   break;
               case 'reset':
                   isRunning = false;
                   startPauseButton.textContent = '▶︎';
                   
                   // Καθαρισμός της προεπισκόπησης μηνύματος
                   const messagePreview = document.getElementById('message-preview');
                   const messageContainer = document.getElementById('message-container-preview');
                   if (messagePreview) {
                       messagePreview.textContent = '';
                   }
                   if (messageContainer) {
                       messageContainer.style.display = 'none';
                   }
                   
                   // Επαναφορά visibility
isMessageVisible = false;
const toggleButton = document.getElementById('toggle-message-btn');
if (toggleButton) {
    toggleButton.textContent = '📤';
    toggleButton.classList.remove('message-visible');
    toggleButton.classList.add('message-hidden');
}
                   
                   console.log('Timer reset by server - admin updated');
                   break;
           }
       }
       
       function handleTimerUpdate(data) {
    timeLeft = data.timeLeft;
    updateTimerDisplay();
    updatePreviewProgressBar();

    timerPreview.classList.remove('warning', 'danger');

    if (data.status === 'warning') {
        timerPreview.classList.add('warning');
    } else if (data.status === 'danger') {
        timerPreview.classList.add('danger');
    }

    // ΚΡΙΣΙΜΟ: Έλεγχος για αρνητικό χρόνο - εμφάνιση "ΤΕΛΟΣ ΧΡΟΝΟΥ"
    if (timeLeft < 0) {
        const messageInput = document.getElementById('message-input');
        const messagePreview = document.getElementById('message-preview');
        const messageContainer = document.getElementById('message-container-preview');

        if (messagePreview && messageInput.value.trim() === '') {
            // Μόνο αν δεν υπάρχει ήδη custom message
            const endTimeMsg = getEndTimeMessage();
            messageInput.value = endTimeMsg;
            messagePreview.textContent = endTimeMsg;

            // Εφαρμογή ειδικού styling
            messagePreview.style.setProperty('font-size', 'clamp(2rem, 8vh, 10vh)', 'important');
            messagePreview.style.setProperty('font-weight', 'bold', 'important');
            messagePreview.style.setProperty('text-align', 'center', 'important');
            messagePreview.style.setProperty('white-space', 'normal', 'important');
            messagePreview.style.setProperty('word-wrap', 'break-word', 'important');

            // ΚΡΙΣΙΜΟ: Εμφάνιση του messagePreview
            messagePreview.style.display = 'block';

            // Εμφάνιση message container
            if (messageContainer) {
                messageContainer.style.display = 'flex';
            }

            // Ενημέρωση toggle button
            if (!isMessageVisible) {
                isMessageVisible = true;
                const toggleButton = document.getElementById('toggle-message-btn');
                if (toggleButton) {
                    toggleButton.textContent = '👁️';
                    toggleButton.classList.remove('message-hidden');
                    toggleButton.classList.add('message-visible');
                }
            }

            console.log('🚨 Αρνητικός χρόνος - "ΤΕΛΟΣ ΧΡΟΝΟΥ" εμφανίστηκε αυτόματα');
        }
    }

    // ΔΙΟΡΘΩΣΗ: Προσαρμογή μεγέθους χρόνου μετά από timer update
    setTimeout(() => {
        const messagePreview = document.getElementById('message-preview');
        const hasMessage = messagePreview && messagePreview.textContent.trim() !== '';

        // Κλήση της συνάρτησης που προσαρμόζει το μέγεθος
        adjustPreviewTimerAndMessageSize(hasMessage && isMessageVisible);

        console.log('Timer size adjustment triggered after handleTimerUpdate');
    }, 50);
}
       
       // ------ FLASH ALERT FUNCTIONS ------
       function triggerFlash() {
           // Manual flash - 3 φορές και σταματάει
           startFlash(false, 3);

           // Trigger Yeelight flash αν είναι διαθέσιμο
           if (window.yeelightManager && window.yeelightManager.isEnabled) {
               window.yeelightManager.triggerFlash(3);
           }
       }

       function startFlash(isAutomatic = false, flashCount = null) {
           if (isFlashAlertActive && !isAutomatic) return; // Αν ήδη τρέχει manual flash
           
           // Ενεργοποίηση local flash
           startFlashLocal(isAutomatic, flashCount);
           
           // Στέλνουμε εντολή στον server ΜΟΝΟ για manual flash
           if (isConnected) {
               socket.emit('flashAlert', { 
                   active: true, 
                   isAutomatic: isAutomatic,
                   flashCount: flashCount 
               });
           }
       }
       
       function startFlashLocal(isAutomatic = false, flashCount = null) {
           if (isFlashAlertActive && !isAutomatic) return; // Αν ήδη τρέχει manual flash
           
           isFlashAlertActive = true;
           
           const timerPreview = document.getElementById('timer-preview');
           const messagePreview = document.getElementById('message-preview');

           // Ενεργοποίηση Flash
           timerPreview.classList.add('flash-alert');
           if (messagePreview && messagePreview.textContent.trim() !== '') {
               messagePreview.classList.add('flash-alert');
           }
           
           // Αν είναι manual flash (3 φορές), σταματάει αυτόματα
           if (flashCount) {
               flashTimer = setTimeout(() => {
                   stopFlashLocal();
               }, flashCount * 2000); // 3 φορές x 2 δευτερόλεπτα
           }
       }

       function stopFlash() {
           // Σταμάτημα local flash
           stopFlashLocal();
           
           // Στέλνουμε εντολή στον server
           if (isConnected) {
               socket.emit('flashAlert', { active: false });
           }
       }
       
       function stopFlashLocal() {
           if (!isFlashAlertActive) return;
           
           isFlashAlertActive = false;
           
           if (flashTimer) {
               clearTimeout(flashTimer);
               flashTimer = null;
           }
           
           const timerPreview = document.getElementById('timer-preview');
           const messagePreview = document.getElementById('message-preview');

           timerPreview.classList.remove('flash-alert');
           messagePreview.classList.remove('flash-alert');
       }

       // Secondary Timer Preview Update Function
       function updateSecondaryTimerPreview(data) {
           const secondaryTimerPreview = document.getElementById('secondary-timer-preview');
           const titleElement = document.getElementById('secondary-timer-title-preview');
           const timeElement = document.getElementById('secondary-timer-time-preview');
           const progressElement = document.getElementById('secondary-progress-bar-preview');
           
           // Debug log για να δούμε τι παίρνουμε
           console.log('🔧 updateSecondaryTimerPreview called with:', data);
           
           // Έλεγχος αν το vMix secondary timer είναι ενεργό (μόνο όταν data.active = false)
           const vmixEnabled = document.getElementById('vmix-enabled')?.checked !== false;
           console.log('🔧 vMix enabled checkbox state:', vmixEnabled);
           
           if (!data || !data.active || !vmixEnabled) {
               // Slide out animation όταν τελειώνει το video
               if (secondaryTimerPreview.style.display === 'block') {
                   secondaryTimerPreview.classList.add('slide-out');
                   
                   // Κρύψιμο μετά το animation (800ms)
                   setTimeout(() => {
                       secondaryTimerPreview.style.display = 'none';
                       secondaryTimerPreview.classList.remove('slide-out');
                   }, 800);
               }
               return;
           }
           
           // Εμφάνιση secondary timer preview
           secondaryTimerPreview.style.display = 'block';
           secondaryTimerPreview.classList.remove('slide-out');
           
           // Ενημέρωση τίτλου
           titleElement.textContent = `🎬 ${data.title}`;
           
           // Ενημέρωση χρόνου (remaining)
           const minutes = Math.floor(data.remaining / 60);
           const seconds = data.remaining % 60;
           timeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
           
           // Ενημέρωση progress bar
           const progressPercent = data.total > 0 ? ((data.total - data.remaining) / data.total) * 100 : 0;
           progressElement.style.width = `${Math.min(100, Math.max(0, progressPercent))}%`;
           
           // Λογική χρωμάτων progress bar βάσει υπολειπόμενου χρόνου
           const remainingPercent = data.total > 0 ? (data.remaining / data.total) * 100 : 0;
           
           // Καθαρισμός classes
           progressElement.classList.remove('warning', 'danger');
           
           if (remainingPercent <= 10) {
               // Κόκκινο - 10% ή λιγότερο χρόνος απομένει
               progressElement.classList.add('danger');
           } else if (remainingPercent <= 25) {
               // Πορτοκαλί - 25% ή λιγότερο χρόνος απομένει
               progressElement.classList.add('warning');
           }
           // Αλλιώς παραμένει πράσινο (default)
           
           console.log(`📹 Secondary timer preview updated: ${data.title} - ${minutes}:${seconds.toString().padStart(2, '0')} remaining (${remainingPercent.toFixed(1)}% left)`);
       }
       
       // ------ CONNECTION STATUS FUNCTIONS ------
       function updateConnectionStatus(status) {
           const ledIndicator = document.getElementById('led-indicator');
           
           if (!ledIndicator) return;
           
           // Καθαρισμός παλιών classes
           ledIndicator.classList.remove('connected', 'connecting');
           
           switch (status) {
               case 'connected':
                   ledIndicator.classList.add('connected');
                   ledIndicator.title = 'Συνδέθηκε στον server';
                   break;
               case 'disconnected':
                   // Default red - δεν προσθέτουμε class
                   ledIndicator.title = 'Αποσυνδέθηκε από τον server';
                   break;
               case 'connecting':
                   ledIndicator.classList.add('connecting');
                   ledIndicator.title = 'Γίνεται σύνδεση...';
                   break;
               case 'error':
                   // Default red για error
                   ledIndicator.title = 'Σφάλμα σύνδεσης';
                   break;
           }
       }
       
     function updateSyncStatus() {
    if (lastSyncTime > 0) {
        const timeAgo = Math.floor((Date.now() - lastSyncTime) / 1000);
        const syncStatusElement = document.getElementById('sync-status');
        if (syncStatusElement) {
            syncStatusElement.textContent = `Συγχρονισμός: ${timeAgo}s`;
        }
        
        setTimeout(updateSyncStatus, 1000);
    }
}
       
       function requestSyncFromServer() {
    const syncStatusElement = document.getElementById('sync-status');
    if (isConnected) {
        socket.emit('requestFullState');
        if (syncStatusElement) {
            syncStatusElement.textContent = 'Συγχρονισμός...';
        }
    } else {
        if (syncStatusElement) {
            syncStatusElement.textContent = 'Δεν υπάρχει σύνδεση με τον server';
        }
    }
}
       
       function applyTimerSettings() {
           // Redirect to main timer settings
           applyMainTimerSettings();
           console.log('applyTimerSettings redirected to applyMainTimerSettings');
       }
       // Νέα συνάρτηση για τις κύριες ρυθμίσεις χρονομέτρου
       function applyMainTimerSettings() {
           const hours = parseInt(document.getElementById('main-timer-hours').value) || 0;
           const minutes = parseInt(document.getElementById('main-timer-minutes').value) || 0;
           const seconds = parseInt(document.getElementById('main-timer-seconds').value) || 0;
           const warning = parseInt(document.getElementById('main-warning-threshold').value) || 60;
           
           const totalSeconds = hours * 3600 + minutes * 60 + seconds;
           
           if (totalSeconds <= 0) {
               const currentLang = localStorage.getItem('preferredLanguage') || 'el';
               const title = currentLang === 'en' ? 'Invalid Time' : 'Άκυρος Χρόνος';
               const message = currentLang === 'en' ? 'Time must be greater than 0!' : 'Ο χρόνος πρέπει να είναι μεγαλύτερος από 0!';
               showCustomAlert(title, message);
               return;
           }
           
           // Ενημέρωση των global μεταβλητών
           timeLeft = totalSeconds;
           originalTime = totalSeconds;
           warningThreshold = warning;
           
           // Ενημέρωση του preview
           updateTimerDisplay();
           updatePreviewProgressBar();
           
           // Αποστολή στον server αν είμαστε συνδεδεμένοι
           if (isConnected) {
               socket.emit('settingsUpdate', {
                   timer: {
                       timeLeft: totalSeconds,
                       originalTime: totalSeconds,
                       warningThreshold: warning
                   }
               });
               console.log('Main timer settings sent to server:', {
                   totalSeconds: totalSeconds,
                   warning: warning
               });
           }
           
           // Αποθήκευση στο localStorage
           saveSettings();
           
           console.log(`Timer updated: ${hours}:${minutes}:${seconds} (${totalSeconds}s), Warning: ${warning}s`);
           
           // 🔥 EVENT-DRIVEN SAVE: Trigger save μετά από timer settings change
           triggerEventDrivenSave('Timer settings applied');
           
       }
       
       function changeTitleSize(delta) {
    titleFontSize = Math.max(16, Math.min(30, titleFontSize + delta * 2));
    
    // ΠΡΟΣΘΗΚΗ: Scale factor για το μικρό preview
    const previewContainer = document.getElementById('preview-screen');
    const containerWidth = previewContainer ? previewContainer.offsetWidth : 600;
    
    // Υπολογισμός κατάλληλου μεγέθους για το preview (που είναι μικρό)
    const scaleFactor = containerWidth / 1920; // Αναλογία με fullscreen οθόνη
    const previewFontSize = Math.max(8, titleFontSize * scaleFactor * 2); // x2 για καλύτερη εμφάνιση
    
    // Εφαρμογή στο preview με pixels
    titlePreview.style.fontSize = `${previewFontSize}px`;
    
    console.log(`Manual title size: ${titleFontSize}px (for timer) / ${previewFontSize.toFixed(1)}px (for preview)`);
}

       function changeLogoSize(delta) {
    logoSize = Math.max(40, Math.min(200, logoSize + delta * 10));

    // Ενημέρωση του preview στις ρυθμίσεις
    const preview = document.getElementById('logo-preview');
    if (preview && preview.style.display !== 'none') {
        preview.style.width = `${logoSize}px`;
        preview.style.height = `${logoSize}px`;
    }

    // ΚΡΙΣΙΜΟ: Ενημέρωση μόνο του μεγέθους - ΟΧΙ των θέσεων
    updateLogoSizesInPreview();

    // === FIX: Size sync ΧΩΡΙΣ logoDataUrl (για να μην αποσυνδέεται το socket) ===
    if (socket && socket.connected) {
        const logoPositions = getLogoPositions(); // Διάβασε τις τρέχουσες θέσεις

        socket.emit('logoSync', {
            // ΔΕΝ στέλνουμε logoDataUrl - είναι τεράστιο (500KB+) και κάνει disconnect!
            logoSize: logoSize,
            logoPositions: logoPositions
        });
        console.log('🖼️ Logo size changed (lightweight sync)');
    }
}
       
       function previewLogo(input) {
    if (input.files && input.files[0]) {
        const file = input.files[0];
        document.getElementById('logo-name').textContent = file.name;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            logoDataUrl = e.target.result;
            
            const preview = document.getElementById('logo-preview');
            preview.src = logoDataUrl;
            preview.style.display = 'block';
            preview.style.width = `${logoSize}px`;
            
            // Τοπική ενημέρωση preview
            updatePreviewLogos();
            
            // === ΠΡΟΣΘΗΚΗ: Άμεσο logo sync ===
            if (socket && socket.connected) {
                const logoPositions = getLogoPositions();
                
                socket.emit('logoSync', {
                    logoDataUrl: logoDataUrl,
                    logoSize: logoSize,
                    logoPositions: logoPositions
                });
                console.log('🖼️ Logo uploaded - instant sync sent');
            }
        };
        reader.readAsDataURL(file);
    }
}
// Preview function - updates local UI only (no server communication)
function updateDisplayPreview() {
    const title = document.getElementById('title-input').value;
    const backgroundColor = document.getElementById('background-color').value;
    const timerFontFamily = document.getElementById('timer-font-family').value;
    
    // Update local preview elements only
    const titlePreview = document.getElementById('title-preview');
    if (titlePreview && title.trim()) {
        titlePreview.textContent = title;
    }
    
    console.log('🎨 Display preview updated (local only)');
}

       function applyDisplaySettings() {
    const title = document.getElementById('title-input').value;
    const backgroundColor = document.getElementById('background-color').value;
    const timerFontFamily = document.getElementById('timer-font-family').value;
    
    const logoPositions = getLogoPositions();
    
    if (isConnected) {
        socket.emit('settingsUpdate', {
            display: {
                title: title || titlePreview.textContent,
                logoDataUrl: logoDataUrl,
                logoSize: logoSize,
                titleFontSize: titleFontSize,
                logoPositions: logoPositions,
                backgroundColor: backgroundColor,
                timerFontFamily: timerFontFamily
            }
        });
    } else {
        if (title) {
            titlePreview.textContent = title;
            document.title = "Admin - " + title;
            
            // ΠΡΟΣΘΗΚΗ: Αυτόματη προσαρμογή μεγέθους κατά την εφαρμογή
            adjustTitleFontSize(title);
        }
        
        saveSettings();
        updatePreviewLogos();
    }
    
    // === ΠΡΟΣΘΗΚΗ: Title sync με άλλα admin panels ===
    if (socket && socket.connected) {
        const currentTitle = document.getElementById('title-input').value;
        if (currentTitle) {
            socket.emit('titleSync', {
                title: currentTitle
            });
            console.log('📝 Title sync sent to other admin panels:', currentTitle);
        }
    }
    
    // 🔥 Event-driven save: Display settings change
    triggerEventDrivenSave('display settings updated');
}
       

       function applySoundSettings() {
           soundEnabled = document.getElementById('sound-enabled').checked;
           soundVolume = parseFloat(document.getElementById('sound-volume').value);
           
           if (isConnected) {
               socket.emit('settingsUpdate', {
                   sound: {
                       enabled: soundEnabled,
                       volume: soundVolume
                   }
               });
           } else {
               saveSettings();
           }
           
           // 🔥 Event-driven save: Sound settings change
           triggerEventDrivenSave('sound settings updated');
       }
       
       // vMix Connection Test
       function testVmixConnection() {
           const host = document.getElementById('vmix-host').value || 'localhost';
           const port = document.getElementById('vmix-port').value || 8088;
           const statusElement = document.getElementById('vmix-status-text');
           
           statusElement.textContent = '🔄 Έλεγχος σύνδεσης...';
           statusElement.style.color = '#f39c12';
           
           // Test vMix API connection
           fetch(`/api/vmix/test-connection?host=${host}&port=${port}`)
               .then(response => response.json())
               .then(data => {
                   if (data.success) {
                       statusElement.textContent = '✅ Σύνδεση επιτυχής!';
                       statusElement.style.color = '#27ae60';
                       
                       if (data.currentVideo) {
                           statusElement.textContent += ` 📹 ${data.currentVideo}`;
                       }
                   } else {
                       statusElement.textContent = `❌ Σφάλμα: ${data.error}`;
                       statusElement.style.color = '#e74c3c';
                   }
               })
               .catch(error => {
                   statusElement.textContent = '❌ Αποτυχία σύνδεσης';
                   statusElement.style.color = '#e74c3c';
                   console.error('vMix connection test failed:', error);
               });
       }
       
       // vMix Settings Application
       function applyVmixSettings() {
           const enabled = document.getElementById('vmix-enabled').checked;
           const host = document.getElementById('vmix-host').value || '192.168.5.123';
           const port = document.getElementById('vmix-port').value || 8088;
           // Get manual timer input from the correct dropdown
           const exportDropdown = document.getElementById('vmix-timer-export-input');
           const oldDropdown = document.getElementById('vmix-timer-input');
           const manualTimerInput = (exportDropdown || oldDropdown)?.value || '';
           
           if (isConnected) {
               socket.emit('vmixSettingsUpdate', {
                   enabled: enabled,
                   host: host,
                   port: port,
                   manualTimerInput: manualTimerInput
               });
               
               console.log('📹 vMix settings applied:', { enabled, host, port, manualTimerInput });
           }
           
           // 🔥 Event-driven save: vMix settings change
           triggerEventDrivenSave('vMix settings updated');
       }

       // Νέα function που κάνει και έλεγχο και εφαρμογή μαζί
       // Load available vMix inputs for dropdown
       async function loadVmixInputs() {
           const host = document.getElementById('vmix-host').value || '192.168.5.123';
           const port = document.getElementById('vmix-port').value || 8088;
           // Try to find the correct dropdown (new export dropdown takes priority)
           const exportDropdown = document.getElementById('vmix-timer-export-input');
           const oldDropdown = document.getElementById('vmix-timer-input');
           const dropdown = exportDropdown || oldDropdown;
           
           if (!dropdown) {
               console.error('❌ vMix timer dropdown not found');
               return;
           }
           
           const currentValue = dropdown.value;
           
           console.log(`📹 Loading vMix inputs from ${host}:${port}...`);
           
           try {
               // Test connection and get inputs
               const response = await fetch(`/api/vmix/get-inputs?host=${host}&port=${port}`);
               const result = await response.json();
               
               if (result.success && result.inputs) {
                   // Clear dropdown except default option
                   dropdown.innerHTML = '<option value="">🔍 Auto-detect (default)</option>';
                   
                   // Add all inputs to dropdown
                   result.inputs.forEach(input => {
                       const option = document.createElement('option');
                       option.value = input.key;
                       option.textContent = `${input.number}: ${input.title}`;
                       
                       // Mark potential timer inputs with emoji
                       const lowerTitle = input.title.toLowerCase();
                       if (lowerTitle.includes('timer') || lowerTitle.includes('clock') || 
                           lowerTitle.includes('timecast') || lowerTitle.includes('χρόνος')) {
                           option.textContent = `⏱️ ${option.textContent}`;
                       }
                       
                       dropdown.appendChild(option);
                   });
                   
                   // Restore previous selection if exists
                   if (currentValue) {
                       dropdown.value = currentValue;
                   }
                   
                   console.log(`✅ Loaded ${result.inputs.length} vMix inputs`);
               } else {
                   console.error('❌ Failed to load vMix inputs:', result.error);
                   // Silent fail - user is already informed by vMix offline indicator
               }
           } catch (error) {
               console.error('❌ Error loading vMix inputs:', error);
               const currentLang = localStorage.getItem('preferredLanguage') || 'el';
               const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
               const message = currentLang === 'en' ? `❌ Error loading inputs: ${error.message}` : `❌ Σφάλμα φόρτωσης inputs: ${error.message}`;
               showCustomAlert(title, message);
           }
       }

       async function testAndApplyVmixSettings() {
           const host = document.getElementById('vmix-host').value || '192.168.5.123';
           const port = document.getElementById('vmix-port').value || 8088;
           
           // Πρώτα κάνουμε έλεγχο
           console.log(`📹 Testing vMix connection to ${host}:${port}...`);
           const statusElement = document.getElementById('vmix-status-text');
           statusElement.textContent = '⏳ Έλεγχος σύνδεσης...';
           statusElement.style.color = '#f39c12';
           
           try {
               const response = await fetch(`/api/vmix/test-connection?host=${host}&port=${port}`);
               const result = await response.json();
               
               if (result.success) {
                   statusElement.textContent = `✅ Συνδέθηκε επιτυχώς! ${result.currentVideo ? `Τρέχει: ${result.currentVideo}` : ''}`;
                   statusElement.style.color = '#27ae60';
                   
                   // Αν ο έλεγχος πέτυχε, εφαρμόζουμε τις ρυθμίσεις
                   console.log('📹 Connection successful, applying settings...');
                   applyVmixSettings();
                   
               } else {
                   statusElement.textContent = `❌ Αποτυχία σύνδεσης: ${result.error}`;
                   statusElement.style.color = '#e74c3c';
               }
           } catch (error) {
               console.error('vMix connection test failed:', error);
               statusElement.textContent = `❌ Σφάλμα: ${error.message}`;
               statusElement.style.color = '#e74c3c';
           }
       }
       
       // Production-grade vMix IP configuration
       async function applyVmixConnection() {
           const host = document.getElementById('vmix-host').value.trim();
           const port = document.getElementById('vmix-port').value || 8088;
           const statusElement = document.getElementById('vmix-status-text');
           
           // Validation
           if (!host) {
               statusElement.textContent = '❌ Please enter vMix IP address';
               statusElement.style.color = '#e74c3c';
               return;
           }
           
           statusElement.textContent = '🔄 Testing vMix connection...';
           statusElement.style.color = '#f39c12';
           
           try {
               console.log(`📡 Applying new vMix connection: ${host}:${port}`);
               
               // Test connection first
               const response = await fetch(`/api/vmix/test-connection?host=${host}&port=${port}`);
               const result = await response.json();
               
               if (result.success) {
                   // Get manual timer input from dropdown
                   const exportDropdown = document.getElementById('vmix-timer-export-input');
                   const oldDropdown = document.getElementById('vmix-timer-input');
                   const manualTimerInput = (exportDropdown || oldDropdown)?.value || '';
                   
                   console.log('🎯 Manual timer input from dropdown:', manualTimerInput || 'Auto-detect');
                   
                   // Save to localStorage
                   const vmixConfig = { host, port: parseInt(port), manualTimerInput };
                   localStorage.setItem('vmixConnection', JSON.stringify(vmixConfig));
                   
                   console.log('📡 Sending vMix config to server:', vmixConfig);
                   
                   // Apply to server with restart (includes manual timer input)
                   if (isConnected) {
                       socket.emit('applyVmixConnection', vmixConfig);
                   }
                   
                   statusElement.textContent = `✅ Connected to ${host}:${port}! ${result.currentVideo ? `Playing: ${result.currentVideo}` : ''}`;
                   statusElement.style.color = '#27ae60';
                   
                   console.log('📡 vMix connection applied successfully:', vmixConfig);
                   
               } else {
                   statusElement.textContent = `❌ Cannot reach ${host}:${port} - ${result.error || 'Network error'}`;
                   statusElement.style.color = '#e74c3c';
                   console.error('vMix connection failed:', result.error);
               }
               
           } catch (error) {
               statusElement.textContent = `❌ Connection error: ${error.message}`;
               statusElement.style.color = '#e74c3c';
               console.error('vMix connection error:', error);
           }
       }
       
       // vMix Auto-Discovery function
       async function discoverVmixInstances() {
           const statusElement = document.getElementById('vmix-status-text');
           
           statusElement.textContent = '🔍 Scanning LAN for vMix instances...';
           statusElement.style.color = '#f39c12';
           
           try {
               console.log('🔍 Starting vMix discovery...');
               
               const response = await fetch('/api/vmix/discover');
               const result = await response.json();
               
               if (result.success && result.instances.length > 0) {
                   console.log('🔍 Discovery results:', result.instances);
                   
                   // Show discovery results
                   let message = `🎯 Found ${result.instances.length} vMix instance(s):\n\n`;
                   
                   result.instances.forEach((instance, index) => {
                       message += `${index + 1}. ${instance.ip}:${instance.port}\n`;
                       message += `   Version: ${instance.version} (${instance.edition})\n\n`;
                   });
                   
                   message += `Select an instance to connect:`;
                   
                   // Create custom dialog for instance selection
                   const discovered = result.instances;
                   showVmixDiscoveryDialog(discovered);
                   
                   statusElement.textContent = `✅ Found ${result.instances.length} vMix instance(s) - Select one to connect`;
                   statusElement.style.color = '#27ae60';
                   
               } else if (result.success && result.instances.length === 0) {
                   statusElement.textContent = `❌ No vMix instances found on ${result.scannedSubnet}.x network`;
                   statusElement.style.color = '#e74c3c';
                   console.log(`🔍 No vMix found on subnet: ${result.scannedSubnet}.x`);
                   
               } else {
                   statusElement.textContent = `❌ Discovery failed: ${result.error || 'Unknown error'}`;
                   statusElement.style.color = '#e74c3c';
                   console.error('vMix discovery failed:', result.error);
               }
               
           } catch (error) {
               statusElement.textContent = `❌ Discovery error: ${error.message}`;
               statusElement.style.color = '#e74c3c';
               console.error('vMix discovery error:', error);
           }
       }
       
       // Show vMix discovery results dialog
       function showVmixDiscoveryDialog(instances) {
           // Create modal overlay
           const overlay = document.createElement('div');
           overlay.style.cssText = `
               position: fixed; top: 0; left: 0; width: 100%; height: 100%;
               background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
               justify-content: center; align-items: center;
           `;
           
           // Create dialog
           const dialog = document.createElement('div');
           dialog.style.cssText = `
               background: #2c3e50; color: #ecf0f1; padding: 20px; border-radius: 10px;
               min-width: 500px; max-width: 600px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);
           `;
           
           let html = `
               <h3 style="color: #3498db; margin-top: 0;">🔍 vMix Discovery Results</h3>
               <p style="margin-bottom: 15px;">Found ${instances.length} vMix instance(s) on your network:</p>
           `;
           
           instances.forEach((instance, index) => {
               html += `
                   <div style="margin: 12px 0; padding: 12px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; cursor: pointer;" 
                        onclick="selectVmixInstance('${instance.ip}', ${instance.port})" 
                        onmouseover="this.style.background='rgba(52, 152, 219, 0.2)'" 
                        onmouseout="this.style.background='rgba(52, 152, 219, 0.1)'">
                       <strong style="color: #3498db;">${instance.ip}:${instance.port}</strong><br>
                       <span style="font-size: 0.9em; color: #bdc3c7;">
                           Version: ${instance.version} (${instance.edition})
                       </span>
                   </div>
               `;
           });
           
           html += `
               <div style="text-align: center; margin-top: 20px;">
                   <button onclick="closeVmixDiscoveryDialog()" 
                           style="padding: 8px 15px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer;">
                       Cancel
                   </button>
               </div>
           `;
           
           dialog.innerHTML = html;
           overlay.appendChild(dialog);
           document.body.appendChild(overlay);
           
           // Store reference for cleanup
           window.vmixDiscoveryOverlay = overlay;
       }
       
       // Select discovered vMix instance
       function selectVmixInstance(ip, port) {
           // Set the form fields
           document.getElementById('vmix-host').value = ip;
           document.getElementById('vmix-port').value = port;
           
           // Close dialog
           closeVmixDiscoveryDialog();
           
           // Auto-apply the connection
           applyVmixConnection();
       }
       
       // Close discovery dialog
       function closeVmixDiscoveryDialog() {
           if (window.vmixDiscoveryOverlay) {
               document.body.removeChild(window.vmixDiscoveryOverlay);
               window.vmixDiscoveryOverlay = null;
           }
       }
       
       // Load saved vMix connection on startup
       function loadVmixConnection() {
           try {
               console.log('🔍 DEBUG: Checking localStorage for vmixConnection...');
               const saved = localStorage.getItem('vmixConnection');
               console.log('🔍 DEBUG: localStorage raw data:', saved);
               
               if (saved) {
                   const config = JSON.parse(saved);
                   console.log('🔍 DEBUG: Parsed config:', config);
                   
                   const hostField = document.getElementById('vmix-host');
                   const portField = document.getElementById('vmix-port');
                   
                   console.log('🔍 DEBUG: Host field before:', hostField ? hostField.value : 'NOT FOUND');
                   console.log('🔍 DEBUG: Port field before:', portField ? portField.value : 'NOT FOUND');
                   
                   if (hostField) hostField.value = config.host || '';
                   if (portField) portField.value = config.port || 8088;
                   
                   // Restore manual timer input dropdown selection
                   const exportDropdown = document.getElementById('vmix-timer-export-input');
                   const oldDropdown = document.getElementById('vmix-timer-input');
                   const dropdown = exportDropdown || oldDropdown;
                   
                   if (dropdown && config.manualTimerInput) {
                       dropdown.value = config.manualTimerInput;
                       console.log('🎯 Restored manual timer input selection:', config.manualTimerInput);
                   } else if (dropdown) {
                       dropdown.value = ''; // Auto-detect
                       console.log('🔍 Set manual timer input to auto-detect');
                   }
                   
                   console.log('🔍 DEBUG: Host field after:', hostField ? hostField.value : 'NOT FOUND');
                   console.log('🔍 DEBUG: Port field after:', portField ? portField.value : 'NOT FOUND');
                   console.log('🔍 DEBUG: Dropdown field after:', dropdown ? dropdown.value : 'NOT FOUND');
                   
                   console.log('✅ Loaded saved vMix connection:', config);
               } else {
                   console.log('⚠️ No saved vMix connection found in localStorage');
               }
           } catch (error) {
               console.error('❌ Failed to load vMix connection:', error);
           }
       }
       
       function saveSettings() {
           const settings = {
              hours: document.getElementById('main-timer-hours')?.value || document.getElementById('timer-hours')?.value || 0,
               minutes: document.getElementById('main-timer-minutes')?.value || document.getElementById('timer-minutes')?.value || 5,
               seconds: document.getElementById('main-timer-seconds')?.value || document.getElementById('timer-seconds')?.value || 0,
               warningThreshold: warningThreshold,
               mainWarningThreshold: document.getElementById('main-warning-threshold')?.value || warningThreshold,
               title: titlePreview.textContent,
               titleFontSize: titleFontSize,
               logoDataUrl: logoDataUrl,
               logoSize: logoSize,
               backgroundColor: document.getElementById('background-color').value,
               logoPositions: getLogoPositions(),
               soundEnabled: soundEnabled,
               soundVolume: soundVolume
           };
           
           localStorage.setItem('timerSettings', JSON.stringify(settings));
       }
       
       function loadSettings() {
           const settings = JSON.parse(localStorage.getItem('timerSettings'));
           if (settings) {
               document.getElementById('timer-hours').value = settings.hours || 0;
               document.getElementById('timer-minutes').value = settings.minutes || 5;
               document.getElementById('timer-seconds').value = settings.seconds || 0;
               document.getElementById('warning-threshold').value = settings.warningThreshold || 60;
               // ΠΡΟΣΘΗΚΗ: Ενημέρωση των κύριων timer fields
               if (settings.hours !== undefined || settings.minutes !== undefined || settings.seconds !== undefined) {
                   const loadHours = parseInt(settings.hours) || 0;
                   const loadMinutes = parseInt(settings.minutes) || 5;
                   const loadSeconds = parseInt(settings.seconds) || 0;
                   
                   const mainHoursField = document.getElementById('main-timer-hours');
                   const mainMinutesField = document.getElementById('main-timer-minutes');
                   const mainSecondsField = document.getElementById('main-timer-seconds');
                   
                   if (mainHoursField) mainHoursField.value = loadHours;
                   if (mainMinutesField) mainMinutesField.value = loadMinutes;
                   if (mainSecondsField) mainSecondsField.value = loadSeconds;
               }
               
               if (settings.warningThreshold !== undefined) {
                   const mainWarningField = document.getElementById('main-warning-threshold');
                   if (mainWarningField) mainWarningField.value = settings.warningThreshold;
               }
               document.getElementById('title-input').value = settings.title || '';
               
               if (settings.titleFontSize) {
                   titleFontSize = settings.titleFontSize;
               }
               
               if (settings.logoDataUrl) {
                   logoDataUrl = settings.logoDataUrl;
               }
               
               if (settings.logoSize) {
                   logoSize = settings.logoSize;
               }
               
               
               if (settings.backgroundColor) {
                   document.getElementById('background-color').value = settings.backgroundColor;
                   
                   // Safe background preview update
                   const backgroundPreview = document.getElementById('background-preview');
                   if (backgroundPreview) {
                       backgroundPreview.style.backgroundColor = settings.backgroundColor;
                   }
                   
                   const previewScreen = document.querySelector('#preview-screen');
                   if (previewScreen) {
                       previewScreen.style.backgroundColor = settings.backgroundColor;
                   }
               }
               
               if (settings.logoPositions) {
                   setLogoPosition(settings.logoPositions);
               }
                 if (settings.timeline) {
            document.getElementById('event-start-time-settings').value = settings.timeline.startTime || '09:00';
            document.getElementById('event-end-time-settings').value = settings.timeline.endTime || '17:00';
            
            document.getElementById('timeline-start-display').textContent = settings.timeline.startTime || '09:00';
            document.getElementById('timeline-end-display').textContent = settings.timeline.endTime || '17:00';
            
            console.log('Timeline settings loaded from localStorage');
        }
               
               document.getElementById('sound-enabled').checked = settings.soundEnabled;
               document.getElementById('sound-volume').value = settings.soundVolume;
               soundEnabled = settings.soundEnabled;
               soundVolume = settings.soundVolume;
               // ΠΡΟΣΘΗΚΗ: Σωστή προσαρμογή τίτλου όταν φορτώνονται settings
const currentTitle = document.getElementById('title-input')?.value || 'TimeCast® Pro Conference Timer';
adjustTitleFontSize(currentTitle);
           }
       }
       
       function updateTimerSettings(settings) {
           if (settings.timeLeft !== undefined) timeLeft = settings.timeLeft;
           if (settings.originalTime !== undefined) originalTime = settings.originalTime;
           if (settings.warningThreshold !== undefined) warningThreshold = settings.warningThreshold;
           
           const hours = Math.floor(originalTime / 3600);
           const minutes = Math.floor((originalTime % 3600) / 60);
           const seconds = originalTime % 60;
           
           document.getElementById('timer-hours').value = hours;
           document.getElementById('timer-minutes').value = minutes;
           document.getElementById('timer-seconds').value = seconds;
           document.getElementById('warning-threshold').value = warningThreshold;
           // ΠΡΟΣΘΗΚΗ: Ενημέρωση κύριων timer fields από server state
               const stateHours = Math.floor(originalTime / 3600);
               const stateMinutes = Math.floor((originalTime % 3600) / 60);
               const stateSeconds = originalTime % 60;
               
               const mainHoursField = document.getElementById('main-timer-hours');
               const mainMinutesField = document.getElementById('main-timer-minutes');
               const mainSecondsField = document.getElementById('main-timer-seconds');
               const mainWarningField = document.getElementById('main-warning-threshold');
               
               if (mainHoursField) mainHoursField.value = stateHours;
               if (mainMinutesField) mainMinutesField.value = stateMinutes;
               if (mainSecondsField) mainSecondsField.value = stateSeconds;
               if (mainWarningField) mainWarningField.value = warningThreshold;
           
           updateTimerDisplay();
           updatePreviewProgressBar();
       }
       
       function updateDisplaySettings(settings) {
          if (settings.title) {
    document.getElementById('title-input').value = settings.title;
    titlePreview.textContent = settings.title;
    document.title = "Admin - " + settings.title;
    
    // ΠΡΟΣΘΗΚΗ: Προσαρμογή μεγέθους όταν λαμβάνουμε settings
    adjustTitleFontSize(settings.title);
}
           
           if (settings.titleFontSize) {
               titleFontSize = settings.titleFontSize;
               titlePreview.style.fontSize = `${titleFontSize}px`;
           }
           
           if (settings.logoDataUrl) {
               logoDataUrl = settings.logoDataUrl;
               const preview = document.getElementById('logo-preview');
               preview.src = logoDataUrl;
               preview.style.display = 'block';
               document.getElementById('logo-name').textContent = 'Αποθηκευμένο λογότυπο';
           }
           
           if (settings.logoSize) {
               logoSize = settings.logoSize;
               const preview = document.getElementById('logo-preview');
               if (preview && preview.style.display !== 'none') {
                   preview.style.width = `${logoSize}px`;
               }
           }
           
           if (settings.logoPositions) {
               setLogoPosition(settings.logoPositions);
           }
           
           if (settings.backgroundColor) {
               document.getElementById('background-color').value = settings.backgroundColor;
               
               // Safe background preview update
               const backgroundPreview = document.getElementById('background-preview');
               if (backgroundPreview) {
                   backgroundPreview.style.backgroundColor = settings.backgroundColor;
               }
               
               const previewScreen = document.querySelector('#preview-screen');
               if (previewScreen) {
                   previewScreen.style.backgroundColor = settings.backgroundColor;
               }
           }
           
           updatePreviewLogos();
       }
       
       function updateSoundSettings(settings) {
           if (settings.enabled !== undefined) {
               soundEnabled = settings.enabled;
               document.getElementById('sound-enabled').checked = settings.enabled;
           }
           
           if (settings.volume !== undefined) {
               soundVolume = settings.volume;
               document.getElementById('sound-volume').value = settings.volume;
           }
       }
       
       // ------ LOGO FUNCTIONS ------
       // Helper function to get current logo positions as object
       function getLogoPositions() {
           const selectedPosition = document.querySelector('input[name="logo-position"]:checked');
           const position = selectedPosition ? selectedPosition.value : 'top-left';
           
           return {
               tl: position === 'top-left',
               tc: position === 'top-center',
               tr: position === 'top-right',
               bl: position === 'bottom-left',
               bc: position === 'bottom-center',
               br: position === 'bottom-right'
           };
       }

       // Helper function to set logo position from logoPositions object
       function setLogoPosition(logoPositions) {
           // Find which position is true
           const positionMap = {
               tl: 'top-left',
               tc: 'top-center', 
               tr: 'top-right',
               bl: 'bottom-left',
               bc: 'bottom-center',
               br: 'bottom-right'
           };
           
           // Find the first true position, default to top-left
           let selectedValue = 'top-left';
           for (const [key, value] of Object.entries(logoPositions)) {
               if (value) {
                   selectedValue = positionMap[key];
                   break;
               }
           }
           
           // Set the radio button
           const radioButton = document.querySelector(`input[name="logo-position"][value="${selectedValue}"]`);
           if (radioButton) {
               radioButton.checked = true;
           }
       }

       function updatePreviewLogos() {
           // Καθαρισμός όλων των λογότυπων στην προεπισκόπηση
           const logoElements = [
               document.getElementById('preview-logo-tl'),
               document.getElementById('preview-logo-tc'),
               document.getElementById('preview-logo-tr'),
               document.getElementById('preview-logo-bl'),
               document.getElementById('preview-logo-bc'),
               document.getElementById('preview-logo-br')
           ];
           
           // Καθαρισμός και απόκρυψη όλων των λογότυπων
           logoElements.forEach(element => {
               if (element) {
                   element.style.backgroundImage = '';
                   element.style.display = 'none';
               }
           });
           
           // Αν δεν υπάρχει λογότυπο, επιστροφή
           if (!logoDataUrl) {
               return;
           }
           
           // Διαβάστε την επιλεγμένη θέση από radio button
           const selectedPosition = document.querySelector('input[name="logo-position"]:checked');
           const position = selectedPosition ? selectedPosition.value : 'top-left';
           
           const positions = {
               tl: position === 'top-left',
               tc: position === 'top-center', 
               tr: position === 'top-right',
               bl: position === 'bottom-left',
               bc: position === 'bottom-center',
               br: position === 'bottom-right'
           };
           
           // Εφαρμογή των λογότυπων στις επιλεγμένες θέσεις
           Object.keys(positions).forEach(pos => {
               const element = document.getElementById(`preview-logo-${pos}`);
               if (element && positions[pos]) {
                   element.style.backgroundImage = `url('${logoDataUrl}')`;
                   element.style.display = 'block';
               }
           });
           
           // Ενημέρωση του μεγέθους των λογότυπων
           updateLogoSizesInPreview();

           // ΠΡΟΣΘΗΚΗ: Ενημέρωση των κύριων fields
           const mainHours = Math.floor(originalTime / 3600);
           const mainMinutes = Math.floor((originalTime % 3600) / 60);
           const mainSeconds = originalTime % 60;
           
           const mainHoursField = document.getElementById('main-timer-hours');
           const mainMinutesField = document.getElementById('main-timer-minutes');
           const mainSecondsField = document.getElementById('main-timer-seconds');
           const mainWarningField = document.getElementById('main-warning-threshold');
           
           if (mainHoursField) mainHoursField.value = mainHours;
           if (mainMinutesField) mainMinutesField.value = mainMinutes;
           if (mainSecondsField) mainSecondsField.value = mainSeconds;
           if (mainWarningField) mainWarningField.value = warningThreshold;
       }
       
       function updateLogoSizesInPreview() {
           // Υπολογισμός του μεγέθους βάσει του preview container
           const previewContainer = document.getElementById('preview-screen');
           const containerWidth = previewContainer ? previewContainer.offsetWidth : 600;
           
           // Αναλογικό μέγεθος: βάση το logoSize αλλά προσαρμοσμένο στο container
           const scaleFactor = containerWidth / 600; // Αναφορά στα 600px max-width
           const calculatedSize = Math.max(20, Math.min(80, (logoSize * scaleFactor * 0.15)));
           
           const logoElements = document.querySelectorAll('.preview-logo');
           logoElements.forEach(element => {
               element.style.width = calculatedSize + 'px';
               element.style.height = calculatedSize + 'px';
           });
           
           // Προσθήκη event listener για resize (μόνο μία φορά)
           if (!window.logoResizeListenerAdded) {
               window.addEventListener('resize', updateLogoSizesInPreview);
               window.logoResizeListenerAdded = true;
           }
       }
       
      // ------ QR & SERVER INFO FUNCTIONS ------
function fetchServerInfo() {
    console.log('=== FETCHING SERVER INFO ===');
    
    fetch('/get-ips')
        .then(response => {
            console.log('IP response received:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('IP data:', data);
            
            const modalServerAddresses = document.getElementById('modal-server-addresses');
            
            if (modalServerAddresses) {
                modalServerAddresses.innerHTML = '';
                
                if (data.ips && data.ips.length > 0) {
                    modalServerAddresses.innerHTML = '';
                    
                    // ΠΡΟΣΘΗΚΗ: Ενημέρωση VMix Timer API URLs (modal + settings)
                    if (data.ips && data.ips.length > 0) {
                        const timerApiUrl = `http://${data.ips[0]}:3000/api/timer/text`;

                        // Update modal element
                        const modalElement = document.getElementById('modal-vmix-timer-api-url');
                        if (modalElement) {
                            modalElement.textContent = timerApiUrl;
                        }

                        // Update settings element
                        const settingsElement = document.getElementById('vmix-timer-api-url');
                        if (settingsElement) {
                            settingsElement.textContent = timerApiUrl;
                            settingsElement.style.color = '#ecf0f1';
                        }

                        console.log('✅ Timer API URL updated to:', timerApiUrl);
                    }
                    
                } else {
                    modalServerAddresses.innerHTML = '<div style="color: #e74c3c;">Δεν βρέθηκαν διαθέσιμες IP διευθύνσεις</div>';
                }
            }
            
            // Modal QR generation για timer (όχι admin)
            if (data.ips && data.ips.length > 0) {
                const protocol = window.location.protocol;
                const port = window.location.port ? `:${window.location.port}` : '';
                const timerUrl = `${protocol}//${data.ips[0]}${port}/timer.html`;
                
                console.log('Generating QR for timer URL:', timerUrl);
                generateQRCode(timerUrl);
            }
        })
        .catch(error => {
            console.error('Error fetching server info:', error);
        });
}
       
       // QR Tab switching functionality
       let currentQRTab = 'timer';
       
       function switchQRTab(tabName) {
           // Update tab buttons
           document.querySelectorAll('.qr-tab').forEach(tab => {
               tab.classList.remove('active');
           });
           document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
           
           // Update button visibility
           document.querySelectorAll('.qr-buttons').forEach(buttons => {
               buttons.style.display = 'none';
           });
           document.getElementById(`${tabName}-buttons`).style.display = 'flex';
           
           // Generate appropriate QR code
           currentQRTab = tabName;
           regenerateQRCode();
       }
       
       function regenerateQRCode() {
           fetch('/get-ips')
               .then(response => response.json())
               .then(data => {
                   if (data.ips && data.ips.length > 0) {
                       const protocol = window.location.protocol;
                       const port = window.location.port ? `:${window.location.port}` : '';
                       let targetUrl;
                       
                       switch(currentQRTab) {
                           case 'timer':
                               targetUrl = `${protocol}//${data.ips[0]}${port}/timer.html`;
                               break;
                           case 'admin':
                               targetUrl = `${protocol}//${data.ips[0]}${port}/admin.html`;
                               break;
                           case 'questions-admin':
                               targetUrl = `${protocol}//${data.ips[0]}${port}/questions-admin.html`;
                               break;
                           case 'questions-form':
                               targetUrl = `${protocol}//${data.ips[0]}${port}/questions-form.html`;
                               break;
                           case 'questions-qr':
                               targetUrl = `${protocol}//${data.ips[0]}${port}/questions-qr.html`;
                               break;
                       }
                       
                       generateModalQRCode(targetUrl);
                   }
               })
               .catch(error => console.error('Error regenerating QR:', error));
       }

       function generateQRCode(url) {
    // Original QR (θα αφαιρεθεί στο επόμενο βήμα)
    const qrcodeContainer = document.getElementById('qrcode');
    const timerUrlElement = document.getElementById('timer-url');
    
    if (qrcodeContainer) {
        qrcodeContainer.innerHTML = '';
        if (timerUrlElement) timerUrlElement.textContent = url;
        
        if (typeof QRCode !== 'undefined') {
            new QRCode(qrcodeContainer, {
                text: url,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        } else {
            qrcodeContainer.innerHTML = '<div style="color: orange;">QR Library Loading...</div>';
        }
    }
    
    // Modal QR - μικρότερο
    const qrcodeModalContainer = document.getElementById('qrcode-modal');
    const modalTimerUrlElement = document.getElementById('modal-timer-url');
    
    if (qrcodeModalContainer) {
        qrcodeModalContainer.innerHTML = '';
        if (modalTimerUrlElement) modalTimerUrlElement.textContent = url;
        
        if (typeof QRCode !== 'undefined') {
            new QRCode(qrcodeModalContainer, {
                text: url,
                width: 120,  // 50% μικρότερο
                height: 120,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        } else {
            qrcodeModalContainer.innerHTML = '<div style="color: orange; font-size: 0.8em;">QR Library Loading...</div>';
        }
    }
}

       function generateModalQRCode(url) {
    // Modal QR Code για tabs
    const qrcodeModalContainer = document.getElementById('qrcode-modal');
    const modalTimerUrlElement = document.getElementById('modal-timer-url');
    
    if (qrcodeModalContainer) {
        qrcodeModalContainer.innerHTML = '';
        
        if (modalTimerUrlElement) {
            modalTimerUrlElement.textContent = url;
        }
        
        if (typeof QRCode !== 'undefined') {
            new QRCode(qrcodeModalContainer, {
                text: url,
                width: 120,
                height: 120,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        } else {
            qrcodeModalContainer.innerHTML = '<div style="color: orange; font-size: 0.8em; text-align: center;">QR Library Loading...</div>';
        }
    }
}
       
       // ------ MODAL FUNCTIONS ------
       function openSettings() {
           const modal = document.getElementById('settings-modal');
           modal.style.display = 'flex';

           // Trigger reflow
           modal.offsetHeight;

           // Add animation class
           modal.classList.add('show');

           // Initialize with timeline tab active
           switchSettingsTab('timeline');

           document.body.style.overflow = 'hidden';

           // Initialize draggable functionality
           initModalDragging();

           // Initialize Yeelight settings
           setTimeout(() => {
               initYeelightSettings();
           }, 500);

           // Load license management information (fix for "Checking license status..." stuck)
           setTimeout(() => {
               loadLicenseManagement();
           }, 100);
       }

       function closeSettings() {
           const modal = document.getElementById('settings-modal');
           modal.classList.remove('show');
           
           // Wait for animation to complete
           setTimeout(() => {
               modal.style.display = 'none';
           }, 300);
           
           document.body.style.overflow = 'auto';
       }

       // ------ YEELIGHT SETTINGS FUNCTIONS ------

       function yeelightUpdateBulbTable() {
           const tableDiv = document.getElementById('yeelight-bulb-table');

           if (!window.yeelightManager || window.yeelightManager.connectedBulbs.length === 0) {
               tableDiv.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Δεν βρέθηκαν λάμπες</div>';
               return;
           }

           const bulbs = window.yeelightManager.connectedBulbs;
           const selectionStatus = window.yeelightManager.getBulbSelectionStatus();

           // Συμπαγής table layout - ΧΡΗΣΗ MAC ΩΣ UNIQUE ID
           tableDiv.innerHTML = `
               <div style="display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; font-size: 0.85rem;">
                   ${bulbs.map(bulb => `
                       <input type="checkbox"
                              onchange="yeelightToggleSelection('${bulb.mac}', this.checked)"
                              ${selectionStatus.selectedMacs?.includes(bulb.mac) ? 'checked' : ''}
                              style="transform: scale(0.9);">
                       <div style="color: ${selectionStatus.selectedMacs?.includes(bulb.mac) ? '#22c55e' : '#fff'};">
                           <div style="font-weight: bold;">${bulb.name || bulb.ip}</div>
                           <div style="font-size: 0.75rem; color: #ccc;">${bulb.mac || 'Unknown MAC'} • ${bulb.model || 'Unknown'}</div>
                       </div>
                       <div style="color: ${selectionStatus.selectedMacs?.includes(bulb.mac) ? '#22c55e' : '#666'};">
                           ${selectionStatus.selectedMacs?.includes(bulb.mac) ? '🎯' : '💡'}
                       </div>
                   `).join('')}
               </div>
               <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 0.8rem; color: #ccc; text-align: center;">
                   ${selectionStatus.selectedMacs?.length || 0}/${bulbs.length} επιλεγμένες για timer sync
               </div>
           `;
       }

       function yeelightToggleSelection(bulbMac, isSelected) {
           if (!window.yeelightManager) return;

           if (isSelected) {
               window.yeelightManager.addBulbToSelection(bulbMac); // Accepts MAC or IP
           } else {
               window.yeelightManager.removeBulbFromSelection(bulbMac); // Accepts MAC or IP
           }

           yeelightUpdateBulbTable();
       }

       // Debounced brightness update για να αποφευχθεί το κόλλημα
       let brightnessUpdateTimeout;
       function yeelightUpdateBrightness(value) {
           const valueSpan = document.getElementById('yeelight-brightness-value');
           valueSpan.textContent = `${value}%`;

           // Clear previous timeout
           if (brightnessUpdateTimeout) {
               clearTimeout(brightnessUpdateTimeout);
           }

           // Set new timeout - στέλνει command μόνο μετά από 300ms χωρίς αλλαγή
           brightnessUpdateTimeout = setTimeout(() => {
               if (window.yeelightManager) {
                   console.log(`🔆 Applying brightness: ${value}%`);
                   window.yeelightManager.setBrightness(parseInt(value));
               }
           }, 300);
       }

       // Manual Yeelight Search Function
       async function manualYeelightSearch() {
           console.log('♻️ Manual Yeelight search triggered');
           const statusDiv = document.getElementById('yeelight-status');
           const button = event.target;

           // Disable button during search
           button.disabled = true;
           button.style.opacity = '0.5';
           button.style.cursor = 'not-allowed';
           statusDiv.textContent = '🔍 Αναζήτηση...';

           try {
               if (window.yeelightManager) {
                   // Trigger FORCED manual discovery (bypass cache)
                   await window.yeelightManager.discoverBulbs(true);
                   statusDiv.textContent = `✅ Βρέθηκαν ${window.yeelightManager.connectedBulbs.length} λάμπες`;

                   // Update table
                   yeelightUpdateBulbTable();
               } else {
                   statusDiv.textContent = '❌ Yeelight manager not initialized';
               }
           } catch (error) {
               console.error('❌ Manual search error:', error);
               statusDiv.textContent = '❌ Σφάλμα αναζήτησης';
           } finally {
               // Re-enable button after 2 seconds
               setTimeout(() => {
                   button.disabled = false;
                   button.style.opacity = '1';
                   button.style.cursor = 'pointer';
               }, 2000);
           }
       }

       // Universal On/Off Toggle Function - ΚΡΙΣΙΜΟ: Επηρεάζει ΜΟΝΟ τις επιλεγμένες λάμπες
       async function yeelightUniversalToggle(isOn) {
           if (!window.yeelightManager) return;

           // Ενημέρωση του enabled state
           window.yeelightManager.isEnabled = isOn;

           console.log(`🔆 Yeelight Universal Toggle: ${isOn ? 'ON' : 'OFF'} (affects ${window.yeelightManager.selectedBulbs.length} selected bulbs)`);

           if (window.yeelightManager.selectedBulbs && window.yeelightManager.selectedBulbs.length > 0) {
               for (const bulb of window.yeelightManager.selectedBulbs) {
                   try {
                       if (isOn) {
                           // Άναμμα με την τρέχουσα φωτεινότητα και χρώμα
                           console.log(`🔆 Turning ON bulb: ${bulb.ip}`);

                           // Άναμμα λάμπας με smooth effect
                           const powerResponse = await fetch('/api/yeelight/set-power', {
                               method: 'POST',
                               headers: { 'Content-Type': 'application/json' },
                               body: JSON.stringify({
                                   ip: bulb.ip,
                                   power: 'on',
                                   effect: 'smooth',
                                   duration: 300
                               })
                           });

                           // Ρύθμιση φωτεινότητας
                           const brightnessResponse = await fetch('/api/yeelight/set-brightness', {
                               method: 'POST',
                               headers: { 'Content-Type': 'application/json' },
                               body: JSON.stringify({
                                   ip: bulb.ip,
                                   brightness: window.yeelightManager.brightness || 100,
                                   duration: 300
                               })
                           });

                       } else {
                           // Σβήσιμο λάμπας
                           console.log(`🔆 Turning OFF bulb: ${bulb.ip}`);

                           const response = await fetch('/api/yeelight/set-power', {
                               method: 'POST',
                               headers: { 'Content-Type': 'application/json' },
                               body: JSON.stringify({
                                   ip: bulb.ip,
                                   power: 'off',
                                   effect: 'smooth',
                                   duration: 300
                               })
                           });
                       }
                   } catch (error) {
                       console.error(`❌ Error controlling bulb ${bulb.ip}:`, error);
                   }
               }
           }

           // Ενημέρωση του slider state (disable/enable)
           const slider = document.getElementById('yeelight-brightness-slider');
           if (slider) {
               slider.disabled = !isOn;
               slider.style.opacity = isOn ? '1' : '0.5';
           }
       }

       // Auto-update όταν ανοίγουν τα settings
       async function initYeelightSettings() {
           if (window.yeelightManager) {
               // Update brightness slider value πάντα
               const slider = document.getElementById('yeelight-brightness-slider');
               const valueSpan = document.getElementById('yeelight-brightness-value');
               if (slider && valueSpan) {
                   slider.value = window.yeelightManager.brightness;
                   valueSpan.textContent = `${window.yeelightManager.brightness}%`;
               }

               // Update universal toggle switch
               const universalToggle = document.getElementById('yeelight-universal-toggle');
               if (universalToggle) {
                   universalToggle.checked = window.yeelightManager.isEnabled;
                   // Αρχικοποίηση slider state
                   if (slider) {
                       slider.disabled = !window.yeelightManager.isEnabled;
                       slider.style.opacity = window.yeelightManager.isEnabled ? '1' : '0.5';
                   }
               }

               // Ελέγχει αν υπάρχουν ήδη λάμπες
               if (window.yeelightManager.connectedBulbs.length > 0) {
                   // Υπάρχουν ήδη λάμπες - απλά ενημερώνει το UI
                   yeelightUpdateBulbTable();
                   const statusDiv = document.getElementById('yeelight-status');
                   statusDiv.textContent = `✅ ${window.yeelightManager.connectedBulbs.length} λάμπες`;
                   statusDiv.style.color = '#22c55e';
               } else {
                   // Δεν υπάρχουν λάμπες - καλεί το discovery του manager
                   console.log('💡 No bulbs found in settings - triggering auto-discovery...');
                   const statusDiv = document.getElementById('yeelight-status');
                   statusDiv.textContent = '🔍 Αναζήτηση λαμπών...';
                   statusDiv.style.color = '#ff69b4';

                   try {
                       await window.yeelightManager.discoverBulbs();
                       // Το updateSettingsUI() καλείται αυτόματα από το discoverBulbs()
                   } catch (error) {
                       console.error('Auto-discovery error:', error);
                       statusDiv.textContent = '❌ Σφάλμα αναζήτησης';
                       statusDiv.style.color = '#ef4444';
                   }
               }
           } else {
               // Yeelight manager δεν είναι διαθέσιμο
               const statusDiv = document.getElementById('yeelight-status');
               if (statusDiv) {
                   statusDiv.textContent = '❌ Yeelight module μη διαθέσιμο';
                   statusDiv.style.color = '#ef4444';
               }
           }
       }
       
       // Initialize i18next using electronAPI (preload.js)
       let isI18nReady = false;
       
       async function initI18nForElectron() {
           try {
               console.log('🌐 Initializing i18next through electronAPI...');
               
               // Check if electronAPI is available
               if (typeof window.electronAPI === 'undefined') {
                   console.log('❌ electronAPI not available');
                   return false;
               }
               
               console.log('✅ electronAPI available - checking i18next readiness...');
               
               // Wait a bit for preload.js to initialize i18next
               let attempts = 0;
               while (!window.electronAPI.isI18nextReady() && attempts < 10) {
                   console.log(`⏳ Waiting for i18next... attempt ${attempts + 1}`);
                   await new Promise(resolve => setTimeout(resolve, 100));
                   attempts++;
               }
               
               if (window.electronAPI.isI18nextReady()) {
                   isI18nReady = true;
                   const currentLang = window.electronAPI.getCurrentLanguage();
                   console.log(`✅ i18next ready through electronAPI - Language: ${currentLang}`);
                   
                   // Restore saved language preference
                   const savedLanguage = localStorage.getItem('preferredLanguage');
                   if (savedLanguage && savedLanguage !== currentLang) {
                       console.log(`🔄 Restoring saved language: ${savedLanguage}`);
                       await window.electronAPI.changeLanguage(savedLanguage);
                       
                       // Update dropdown to match restored language
                       const languageSelector = document.getElementById('language-selector');
                       if (languageSelector) {
                           languageSelector.value = savedLanguage;
                       }
                   } else if (savedLanguage) {
                       console.log(`✅ Language already matches saved preference: ${savedLanguage}`);
                       
                       // Just update dropdown to match current language
                       const languageSelector = document.getElementById('language-selector');
                       if (languageSelector) {
                           languageSelector.value = savedLanguage;
                       }
                   }
                   
                   // Apply translations after language is set
                   updateUITranslations();

                   // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" message μετά το restore
                   setTimeout(() => {
                       const messageInput = document.getElementById('message-input');
                       const messagePreview = document.getElementById('message-preview');
                       if (messageInput && messagePreview) {
                           const currentMsg = messageInput.value.trim();
                           if (currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') {
                               const correctEndTimeMsg = getEndTimeMessage();
                               if (currentMsg !== correctEndTimeMsg) {
                                   messageInput.value = correctEndTimeMsg;
                                   messagePreview.textContent = correctEndTimeMsg;
                                   console.log(`🔄 [Restore] Updated end time message from "${currentMsg}" to "${correctEndTimeMsg}"`);

                                   // Broadcast το διορθωμένο μήνυμα
                                   if (socket && socket.connected) {
                                       socket.emit('updateMessage', {
                                           message: correctEndTimeMsg,
                                           visible: true
                                       });
                                   }
                               }
                           }
                       }
                   }, 500); // Small delay to ensure DOM is ready

                   return true;
               } else {
                   console.log('❌ i18next failed to initialize in preload.js');
                   return false;
               }
           } catch (error) {
               console.error('❌ i18next initialization failed:', error);
               console.log('⚠️ Falling back to non-i18next mode');
               return false;
           }
       }
       
       // Update all UI text elements with translations
       function updateUITranslations() {
           console.log('🌐 Updating UI translations...');
           
           if (!window.electronAPI) {
               console.log('⚠️ electronAPI not available for translations');
               return;
           }
           
           // Find all elements with data-i18n attribute
           const elementsToTranslate = document.querySelectorAll('[data-i18n]');
           
           elementsToTranslate.forEach(element => {
               const translationKey = element.getAttribute('data-i18n');
               const translatedText = window.electronAPI.translate(translationKey);
               
               console.log(`🔤 Translating "${translationKey}" → "${translatedText}"`);
               element.textContent = translatedText;
           });
           
           // Update placeholders that can't use data-i18n
           const messageInput = document.getElementById('message-input');
           if (messageInput) {
               messageInput.placeholder = window.electronAPI.translate('messages.placeholder');
           }
           
           console.log(`✅ Updated ${elementsToTranslate.length} UI elements + placeholders`);
       }
       
       // Language change handler 
       window.onLanguageChange = async function() {
           const selector = document.getElementById('language-selector');
           const selectedLang = selector.value;
           
           console.log(`🌐 Language dropdown changed to: ${selectedLang}`);
           
           if (isI18nReady && window.electronAPI) {
               try {
                   await window.electronAPI.changeLanguage(selectedLang);
                   console.log(`✅ Language changed to: ${selectedLang}`);

                   // Save language preference to localStorage
                   localStorage.setItem('preferredLanguage', selectedLang);
                   console.log(`💾 Language preference saved: ${selectedLang}`);

                   // Broadcast language change to remote admin pages
                   if (socket && socket.connected) {
                       socket.emit('languageChange', { language: selectedLang });
                       console.log(`📡 Language change broadcast to remote admins: ${selectedLang}`);
                   }

                   // Update all UI elements with new translations
                   updateUITranslations();

                   // Update static HTML translations
                   updateStaticTranslations();

                   // Re-render events to update dynamic text
                   refreshEventDisplays();

                   // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" message αν εμφανίζεται
                   const messageInput = document.getElementById('message-input');
                   const messagePreview = document.getElementById('message-preview');
                   if (messageInput && messagePreview) {
                       const currentMsg = messageInput.value.trim();
                       // Έλεγχος αν το τρέχον μήνυμα είναι "ΤΕΛΟΣ ΧΡΟΝΟΥ" ή "TIME UP"
                       if (currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') {
                           const newEndTimeMsg = getEndTimeMessage();
                           messageInput.value = newEndTimeMsg;
                           messagePreview.textContent = newEndTimeMsg;
                           console.log(`🔄 Updated end time message to: ${newEndTimeMsg}`);

                           // Broadcast το νέο μήνυμα
                           if (socket && socket.connected) {
                               socket.emit('updateMessage', {
                                   message: newEndTimeMsg,
                                   visible: true
                               });
                           }
                       }
                   }

               } catch (error) {
                   console.error('❌ Failed to change language:', error);
               }
           } else {
               // Fallback message
               const message = selectedLang === 'el' 
                   ? 'Επιλέχθηκαν Ελληνικά (i18next δεν είναι διαθέσιμο)'
                   : 'Selected English (i18next not available)';
               
               console.log('💡 ' + message);
               
               // Save language preference to localStorage and update static translations
               localStorage.setItem('preferredLanguage', selectedLang);
               updateStaticTranslations();
               
               // Re-render events to update dynamic text
               refreshEventDisplays();
           }
       }
       
       // Initialize i18next when DOM loads (only attempt in Electron)
       document.addEventListener('DOMContentLoaded', () => {
           console.log('🔄 DOMContentLoaded fired - will initialize i18next in 1 second...');
           setTimeout(() => {
               console.log('⏰ Timeout reached - calling initI18nForElectron()');
               initI18nForElectron();
           }, 1000); // Small delay to ensure everything is loaded
       });

       // Modal dragging functionality - DRAGGABLE ΑΠΟ ΟΠΟΥΔΗΠΟΤΕ
       function initModalDragging() {
           const modal = document.getElementById('settings-modal');
           const modalDialog = modal.querySelector('.modal');

           let isDragging = false;
           let currentX;
           let currentY;
           let initialX;
           let initialY;
           let xOffset = 0;
           let yOffset = 0;

           // Draggable από ολόκληρο το modal body
           modalDialog.addEventListener('mousedown', dragStart);
           document.addEventListener('mouseup', dragEnd);
           document.addEventListener('mousemove', drag);

           function dragStart(e) {
               // Αποφυγή drag σε interactive elements (buttons, inputs, selects)
               const clickedElement = e.target;
               const interactiveElements = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A'];

               // Αν πατήθηκε button, input, κτλ - ΜΗΝ ξεκινήσεις drag
               if (interactiveElements.includes(clickedElement.tagName)) {
                   return;
               }

               // Αν πατήθηκε μέσα σε button (π.χ. icon μέσα σε button) - ΜΗΝ ξεκινήσεις drag
               if (clickedElement.closest('button, input, select, textarea, a')) {
                   return;
               }

               initialX = e.clientX - xOffset;
               initialY = e.clientY - yOffset;
               isDragging = true;
               modalDialog.style.transition = 'none';
               modalDialog.style.cursor = 'move';
           }

           function dragEnd(e) {
               initialX = currentX;
               initialY = currentY;
               isDragging = false;
               modalDialog.style.transition = '';
               modalDialog.style.cursor = '';
           }

           function drag(e) {
               if (isDragging) {
                   e.preventDefault();
                   currentX = e.clientX - initialX;
                   currentY = e.clientY - initialY;
                   xOffset = currentX;
                   yOffset = currentY;

                   modalDialog.style.transform = `translate(${currentX}px, ${currentY}px)`;
               }
           }
       }

       // Close modal with Escape key
       document.addEventListener('keydown', function(event) {
           if (event.key === 'Escape') {
               const modal = document.getElementById('settings-modal');
               if (modal.style.display === 'flex') {
                   closeSettings();
               }
           }
       });
       
       // ------ SETTINGS TAB FUNCTIONS ------
       function switchSettingsTab(tabName) {
           // Remove active class from all tab buttons
           const tabButtons = document.querySelectorAll('.settings-tab-btn');
           tabButtons.forEach(btn => btn.classList.remove('active'));
           
           // Hide all tab content
           const tabContents = document.querySelectorAll('.settings-tab-content');
           tabContents.forEach(content => {
               content.style.display = 'none';
               content.classList.remove('active');
           });
           
           // Show selected tab content
           const selectedTab = document.getElementById(tabName + '-tab');
           const selectedButton = document.querySelector(`[data-tab="${tabName}"]`);
           
           if (selectedTab && selectedButton) {
               selectedTab.style.display = 'block';
               selectedTab.classList.add('active');
               selectedButton.classList.add('active');
               
               console.log(`Switched to ${tabName} tab`);
           }
       }
       
       // ------ TIMELINE IMPORT TAB FUNCTIONS ------
       function switchTimelineTab(tabName) {
           // Update tab buttons
           const excelTab = document.getElementById('excel-tab');
           const googleTab = document.getElementById('google-tab');
           
           if (tabName === 'excel') {
               // Excel tab active
               excelTab.style.background = '#27ae60';
               excelTab.style.color = 'white';
               googleTab.style.background = 'rgba(255,255,255,0.1)';
               googleTab.style.color = '#bdc3c7';
               
               // Show Excel content, hide Google content
               document.getElementById('excel-tab-content').style.display = 'block';
               document.getElementById('google-tab-content').style.display = 'none';
           } else if (tabName === 'google') {
               // Google tab active
               googleTab.style.background = '#e74c3c';
               googleTab.style.color = 'white';
               excelTab.style.background = 'rgba(255,255,255,0.1)';
               excelTab.style.color = '#bdc3c7';
               
               // Show Google content, hide Excel content
               document.getElementById('google-tab-content').style.display = 'block';
               document.getElementById('excel-tab-content').style.display = 'none';
           }
           
           console.log(`Timeline import tab switched to: ${tabName}`);
       }
       
       // ------ EXPORT/IMPORT SETTINGS ------
       function exportSettings() {
           const settings = {
               timer: {
                   hours: document.getElementById('main-timer-hours')?.value || document.getElementById('timer-hours')?.value || 0,
                   minutes: document.getElementById('main-timer-minutes')?.value || document.getElementById('timer-minutes')?.value || 5,
                   seconds: document.getElementById('main-timer-seconds')?.value || document.getElementById('timer-seconds')?.value || 0,
                   warningThreshold: warningThreshold,
                   mainWarningThreshold: document.getElementById('main-warning-threshold')?.value || warningThreshold,
                   originalTime: originalTime
               },
               display: {
                   title: titlePreview.textContent,
                   titleFontSize: titleFontSize,
                   logoDataUrl: logoDataUrl,
                   logoSize: logoSize,
                   backgroundColor: document.getElementById('background-color').value,
                   timerFontFamily: document.getElementById('timer-font-family').value,
                   logoPositions: getLogoPositions()
               },
               sound: {
    enabled: soundEnabled,
    volume: soundVolume
},
timeline: {
    startTime: document.getElementById('timeline-start-display').textContent || '09:00',
    endTime: document.getElementById('timeline-end-display').textContent || '17:00'
},
savedMessages: savedMessages,
eventMarkers: eventMarkers,
yeelight: {
    enabled: window.yeelightManager ? window.yeelightManager.isEnabled : false,
    brightness: window.yeelightManager ? window.yeelightManager.brightness : 100,
    selectedBulbs: window.yeelightManager ? window.yeelightManager.selectedBulbs : [],
    connectedBulbs: window.yeelightManager ? window.yeelightManager.connectedBulbs : []
},
           };
           
           const blob = new Blob([JSON.stringify(settings, null, 2)], {type: 'application/json'});
           const url = URL.createObjectURL(blob);
           const a = document.createElement('a');
           a.href = url;
           a.download = `timer-settings-${new Date().toISOString().slice(0,10)}.json`;
           document.body.appendChild(a);
           a.click();
           document.body.removeChild(a);
           URL.revokeObjectURL(url);
       }

       function importSettings() {
           document.getElementById('settings-file').click();
       }

       function handleImportFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const settings = JSON.parse(e.target.result);
            
            if (!confirm('ΠΡΟΣΟΧΗ: Η εισαγωγή θα ΔΙΑΓΡΑΨΕΙ όλες τις τρέχουσες ρυθμίσεις, μηνύματα και markers!\n\nΘέλετε να συνεχίσετε;')) {
                return;
            }
            
            console.log('=== STARTING IMPORT - CLEARING ALL DATA ===');
            
            // 1. ΚΑΘΑΡΙΣΜΟΣ SAVED MESSAGES
            if (savedMessages && savedMessages.length > 0) {
                console.log('Clearing existing saved messages...');
                for (const message of savedMessages) {
                    try {
                        await fetch(`/api/saved-messages/${message.id}`, {
                            method: 'DELETE'
                        });
                    } catch (error) {
                        console.error('Error deleting message:', error);
                    }
                }
                savedMessages = [];
                renderSavedMessages();
            }
            
            // 2. ΚΑΘΑΡΙΣΜΟΣ EVENT MARKERS  
            if (eventMarkers && eventMarkers.length > 0) {
                console.log('Clearing existing event markers...');
                for (const marker of eventMarkers) {
                    try {
                        await fetch(`/api/event-markers/${marker.id}`, {
                            method: 'DELETE'
                        });
                    } catch (error) {
                        console.error('Error deleting marker:', error);
                    }
                }
                eventMarkers = [];
                renderEventMarkers();
            }
            
            // 3. ΑΝΑΜΟΝΗ ΓΙΑ ΚΑΘΑΡΙΣΜΟ
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 4. ΕΙΣΑΓΩΓΗ ΝΕΩΝ ΡΥΘΜΙΣΕΩΝ ΜΕ ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ
            if (settings.timer) {
                // Υπολογισμός από originalTime
                // Υπολογισμός από originalTime - με string conversion
                let importHours = parseInt(settings.timer.hours) || 0;
                let importMinutes = parseInt(settings.timer.minutes) || 0;
                let importSeconds = parseInt(settings.timer.seconds) || 0;
                
                // Αν δεν υπάρχουν, υπολόγισε από originalTime
                if ((importHours === 0 && importMinutes === 0 && importSeconds === 0) && settings.timer.originalTime) {
                    const totalSecs = settings.timer.originalTime;
                    importHours = Math.floor(totalSecs / 3600);
                    importMinutes = Math.floor((totalSecs % 3600) / 60);
                    importSeconds = totalSecs % 60;
                    console.log(`Calculated from originalTime ${totalSecs}s: ${importHours}h ${importMinutes}m ${importSeconds}s`);
                }
                
                // Κύρια fields
                const mainHours = document.getElementById('main-timer-hours');
                const mainMinutes = document.getElementById('main-timer-minutes');
                const mainSeconds = document.getElementById('main-timer-seconds');
                const mainWarning = document.getElementById('main-warning-threshold');
                
                if (mainHours) mainHours.value = importHours;
                if (mainMinutes) mainMinutes.value = importMinutes;
                if (mainSeconds) mainSeconds.value = importSeconds;
                if (mainWarning) mainWarning.value = settings.timer.warningThreshold || 60;
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ των timer settings
                console.log('Applying imported timer settings immediately...');
                setTimeout(() => {
                    applyMainTimerSettings();
                    console.log('Timer settings applied from import');
                }, 100);
            }
            
            
            if (settings.display) {
                const newTitle = settings.display.title || 'TimeCast® Pro Conference Timer';
                document.getElementById('title-input').value = newTitle;
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Ενημέρωση του preview
                document.getElementById('title-preview').textContent = newTitle;
                document.title = "Admin - " + newTitle;
                
                titleFontSize = settings.display.titleFontSize || 32;
                document.getElementById('title-preview').style.fontSize = `${titleFontSize}px`;
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Λογότυπο
                if (settings.display.logoDataUrl) {
                    logoDataUrl = settings.display.logoDataUrl;
                    const preview = document.getElementById('logo-preview');
                    preview.src = logoDataUrl;
                    preview.style.display = 'block';
                    preview.style.width = `${settings.display.logoSize || 80}px`;
                    preview.style.height = `${settings.display.logoSize || 80}px`;
                    document.getElementById('logo-name').textContent = 'Εισαγμένο λογότυπο';
                }
                
                logoSize = settings.display.logoSize || 80;
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Background color
                const bgColor = settings.display.backgroundColor || '#2c3e50';
                document.getElementById('background-color').value = bgColor;
                document.querySelector('#preview-screen').style.backgroundColor = bgColor;
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Timer Font Family
                if (settings.display.timerFontFamily) {
                    document.getElementById('timer-font-family').value = settings.display.timerFontFamily;
                    console.log('✅ Font restored:', settings.display.timerFontFamily);
                }
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Logo positions
                if (settings.display.logoPositions) {
                    setLogoPosition(settings.display.logoPositions);
                    
                    // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Preview logos
                    setTimeout(() => {
                        updatePreviewLogos();
                    }, 100);
                }
            }
            
            if (settings.sound) {
                soundEnabled = settings.sound.enabled;
                soundVolume = settings.sound.volume;
                document.getElementById('sound-enabled').checked = soundEnabled;
                document.getElementById('sound-volume').value = soundVolume;
            }
            
            if (settings.timeline) {
                document.getElementById('event-start-time-settings').value = settings.timeline.startTime || '09:00';
                document.getElementById('event-end-time-settings').value = settings.timeline.endTime || '17:00';
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Timeline displays
                document.getElementById('timeline-start-display').textContent = settings.timeline.startTime || '09:00';
                document.getElementById('timeline-end-display').textContent = settings.timeline.endTime || '17:00';
                
                // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Duration calculator
                setTimeout(() => {
                    updateEventDuration();
                    updateTimelineProgress();
                }, 200);
            }
            
            // ΑΜΕΣΗ ΕΦΑΡΜΟΓΗ: Timer preview - ασφαλές
            setTimeout(() => {
                const hours = parseInt(document.getElementById('main-timer-hours')?.value) || 0;
                const minutes = parseInt(document.getElementById('main-timer-minutes')?.value) || 0;
                const seconds = parseInt(document.getElementById('main-timer-seconds')?.value) || 0;
                const totalSeconds = hours * 3600 + minutes * 60 + seconds;
                
                timeLeft = totalSeconds;
                originalTime = totalSeconds;
                warningThreshold = parseInt(document.getElementById('main-warning-threshold')?.value) || 60;
                
                updateTimerDisplay();
                updatePreviewProgressBar();
            }, 300);
            
            // 5. ΕΙΣΑΓΩΓΗ SAVED MESSAGES (ΜΕΤΑ ΤΟΝ ΚΑΘΑΡΙΣΜΟ)
            if (settings.savedMessages && settings.savedMessages.length > 0) {
                console.log('Importing saved messages...');
                for (const message of settings.savedMessages) {
                    try {
                        await fetch('/api/saved-messages/add', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: message.content })
                        });
                    } catch (error) {
                        console.error('Error importing message:', error);
                    }
                }
                console.log('Messages imported:', settings.savedMessages.length);
            }
            
            // 6. ΕΙΣΑΓΩΓΗ EVENT MARKERS (ΜΕΤΑ ΤΟΝ ΚΑΘΑΡΙΣΜΟ)
            if (settings.eventMarkers && settings.eventMarkers.length > 0) {
                console.log('Importing event markers...');
                for (const marker of settings.eventMarkers) {
                    try {
                        await fetch('/api/event-markers/add', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                time: marker.time,
                                title: marker.title,
                                type: marker.type
                            })
                        });
                    } catch (error) {
                        console.error('Error importing marker:', error);
                    }
                }
                console.log('Event markers imported:', settings.eventMarkers.length);
            }

            // 6.5. YEELIGHT SETTINGS IMPORT
            if (settings.yeelight && window.yeelightManager) {
                console.log('💡 Importing Yeelight settings...');

                // Restore brightness
                if (settings.yeelight.brightness !== undefined) {
                    window.yeelightManager.brightness = settings.yeelight.brightness;
                    const brightnessSlider = document.getElementById('yeelight-brightness-slider');
                    const brightnessValue = document.getElementById('yeelight-brightness-value');
                    if (brightnessSlider) brightnessSlider.value = settings.yeelight.brightness;
                    if (brightnessValue) brightnessValue.textContent = `${settings.yeelight.brightness}%`;
                    console.log(`🔆 Brightness imported: ${settings.yeelight.brightness}%`);
                }

                // Restore enabled state
                if (settings.yeelight.enabled !== undefined) {
                    window.yeelightManager.isEnabled = settings.yeelight.enabled;
                    console.log(`🔌 Yeelight enabled state imported: ${settings.yeelight.enabled}`);
                }

                // Prepare selected bulbs for restoration after discovery
                if (settings.yeelight.selectedBulbs && Array.isArray(settings.yeelight.selectedBulbs)) {
                    window.yeelightManager.pendingSelectedBulbs = settings.yeelight.selectedBulbs;
                    console.log(`🎯 ${settings.yeelight.selectedBulbs.length} bulb selections queued for import`);
                }

                console.log('💡 Yeelight settings imported successfully');
            }

            // 7. ΤΕΛΙΚΗ ΕΦΑΡΜΟΓΗ ΡΥΘΜΙΣΕΩΝ ΜΕ ΑΜΕΣΗ ΕΝΗΜΕΡΩΣΗ
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Success' : 'Επιτυχία';
            const message = currentLang === 'en' ? 'Settings imported successfully!\nAll previous data has been cleared.' : 'Οι ρυθμίσεις εισήχθησαν επιτυχώς!\nΌλα τα προηγούμενα δεδομένα διαγράφηκαν.';
            showCustomAlert(title, message);
            
            // Εφαρμογή στον server
           applyMainTimerSettings();  // <-- ΑΛΛΑΓΗ ΕΔΩ!
            applyDisplaySettings();
            applySoundSettings();
            if (settings.timeline) {
                applyTimelineSettings();
            }
            
            // Αναγκαστική ενημέρωση preview
            setTimeout(() => {
                updatePreviewLogos();
                updateTimerDisplay();
                updatePreviewProgressBar();
            }, 500);
            
            console.log('=== IMPORT COMPLETED WITH IMMEDIATE UI UPDATE ===');
            
        } catch (error) {
            console.error('Σφάλμα εισαγωγής ρυθμίσεων:', error);
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Error importing settings. Please ensure the file is valid.' : 'Σφάλμα κατά την εισαγωγή των ρυθμίσεων. Βεβαιωθείτε ότι το αρχείο είναι έγκυρο.';
            showCustomAlert(title, message);
        }
    };
    
    reader.readAsText(file);
    event.target.value = ''; // Clear the input
}
       async function loadSavedMessagesFromServer() {
    try {
        const response = await fetch('/api/saved-messages');
        if (response.ok) {
            const data = await response.json();
            savedMessages = data.messages || [];
            renderSavedMessages();
            console.log('Loaded saved messages from server:', savedMessages.length);
        }
    } catch (error) {
        console.error('Error loading saved messages:', error);
    }
}
// Σιωπηρό AutoSave - ΜΟΝΟ localStorage (χωρίς αρχείο)
async function performSilentAutoSave() {
    const timestamp = new Date().toLocaleString('el-GR');
    console.log(`🔄 Auto-Save: Starting at ${timestamp}`);
    
    try {
        const settings = {
            timer: {
                hours: document.getElementById('main-timer-hours')?.value || 0,
                minutes: document.getElementById('main-timer-minutes')?.value || 5,
                seconds: document.getElementById('main-timer-seconds')?.value || 0,
                warningThreshold: warningThreshold,
                mainWarningThreshold: document.getElementById('main-warning-threshold')?.value || warningThreshold,
                originalTime: originalTime
            },
            display: {
                title: titlePreview.textContent,
                titleFontSize: titleFontSize,
                logoDataUrl: logoDataUrl,
                logoSize: logoSize,
                backgroundColor: document.getElementById('background-color').value,
                timerFontFamily: document.getElementById('timer-font-family')?.value || 'Arial',
                currentMessage: document.getElementById('message-input')?.value || '',
                messageVisible: window.messageVisible || false,
                logoPositions: getLogoPositions()
            },
            sound: {
                enabled: soundEnabled,
                volume: soundVolume
            },
            timeline: {
                startTime: document.getElementById('timeline-start-display').textContent || '09:00',
                endTime: document.getElementById('timeline-end-display').textContent || '17:00'
            },
            savedMessages: await getSavedMessagesForAutoSave(),
            eventMarkers: await getEventMarkersForAutoSave(),
            vmix: {
                host: document.getElementById('vmix-host')?.value || 'localhost',
                port: document.getElementById('vmix-port')?.value || '8088',
                enabled: document.getElementById('vmix-enabled')?.checked || false,
                secondaryTimerEnabled: document.getElementById('vmix-secondary-timer-enabled')?.checked || false,
                manualTimerInput: document.getElementById('vmix-timer-export-input')?.value || '',
                tallyEnabled: window.vmixTallyEnabled || false,
                connectionStatus: window.vmixConnected || false
            },
            googleSheets: {
                lastUrl: localStorage.getItem('lastGoogleSheetsUrl') || null,
                connected: false // This would need server state check
            },
            excel: {
                lastFile: localStorage.getItem('lastExcelFile') || null,
                lastImported: localStorage.getItem('lastExcelImported') || null
            },
            advanced: {
                clockMode: window.clockMode || false,
                timerRunning: window.timerRunning || false,
                timeLeft: window.timeLeft || 0,
                originalTime: window.originalTime || 0,
                currentPC: localStorage.getItem('currentPCName') || '',
                noSleepEnabled: window.adminNoSleepEnabled || false,
                hdmiTimerOpen: window.hdmiTimerOpen || false
            },
            yeelight: {
                enabled: window.yeelightManager ? window.yeelightManager.isEnabled : false,
                brightness: window.yeelightManager ? window.yeelightManager.brightness : 100,
                selectedBulbs: window.yeelightManager ? window.yeelightManager.selectedBulbs : [],
                connectedBulbs: window.yeelightManager ? window.yeelightManager.connectedBulbs : [],
                currentTimerState: window.yeelightManager ? window.yeelightManager.currentTimerState : 'idle'
            },
            ui: {
                settingsTabActive: document.querySelector('.settings-tab-btn.active')?.dataset?.tab || 'timer',
                messageInputValue: document.getElementById('message-input')?.value || '',
                eventStartTime: document.getElementById('event-start-time-settings')?.value || '09:00',
                eventEndTime: document.getElementById('event-end-time-settings')?.value || '17:00',
                logoPreviewVisible: document.getElementById('logo-preview')?.style?.display !== 'none',
                soundVolumeValue: document.getElementById('sound-volume')?.value || 50
            },
            autoSaveTimestamp: timestamp,
            lastSaved: `Τελευταία αποθήκευση: ${timestamp}`
        };
        
        // FILE-BASED auto-save using Electron IPC με fallback
        if (window.electronAPI && window.electronAPI.saveAutoBackupFile) {
            const result = await window.electronAPI.saveAutoBackupFile(settings);
            if (result.success) {
                console.log(`✅ Auto-Save: File created at ${timestamp}`);
                console.log(`📁 Auto-save location: ${result.filePath}`);
            } else {
                console.error(`❌ Auto-Save: File creation failed:`, result.error);
                // Fallback to localStorage if file save fails
                localStorage.setItem('timerAutoSave', JSON.stringify(settings));
                console.log(`🔄 Fallback: Saved to localStorage instead`);
            }
        } else {
            // Fallback για browser environment
            localStorage.setItem('timerAutoSave', JSON.stringify(settings));
            console.log(`✅ Auto-Save: Browser fallback - saved to localStorage at ${timestamp}`);
        }
        
    } catch (error) {
        console.error(`❌ Auto-Save: Failed at ${timestamp}:`, error);
        // Final fallback to localStorage
        try {
            const fallbackData = {
                timestamp: timestamp,
                fallback: true,
                error: error.message
            };
            localStorage.setItem('timerAutoSave', JSON.stringify(fallbackData));
            console.log(`🔄 Emergency fallback: Basic save to localStorage`);
        } catch (fallbackError) {
            console.error(`💥 Critical: Even fallback failed:`, fallbackError);
        }
    }
}

// Silent restore function για auto-load στην εκκίνηση
async function applySavedSettings(savedSettings) {
    try {
        console.log('🔄 Applying saved settings silently...');
        
        // Apply timer settings
        if (savedSettings.timer) {
            const hours = parseInt(savedSettings.timer.hours || 0);
            const minutes = parseInt(savedSettings.timer.minutes || 15);
            const seconds = parseInt(savedSettings.timer.seconds || 0);
            
            // Update UI fields
            const mainHoursField = document.getElementById('main-timer-hours');
            const mainMinutesField = document.getElementById('main-timer-minutes'); 
            const mainSecondsField = document.getElementById('main-timer-seconds');
            
            if (mainHoursField) mainHoursField.value = hours;
            if (mainMinutesField) mainMinutesField.value = minutes;
            if (mainSecondsField) mainSecondsField.value = seconds;
            
            console.log(`⏰ Timer applied: ${hours}:${minutes}:${seconds}`);
        }
        
        // Apply display settings
        if (savedSettings.display) {
            if (savedSettings.display.title) {
                const titleInput = document.getElementById('title-input');
                if (titleInput) {
                    titleInput.value = savedSettings.display.title;
                    socket.emit('titleSync', { title: savedSettings.display.title });
                }
            }
            console.log('🎨 Display settings applied');
        }
        
        // 🧹 CRITICAL: Clear existing server data before auto-restore to prevent duplicates
        console.log('🧹 [AUTO-RESTORE] Clearing existing server data...');
        
        // Clear existing messages first
        try {
            const existingMessagesResponse = await fetch('/api/saved-messages');
            const existingMessagesData = await existingMessagesResponse.json();
            
            if (existingMessagesData.messages && existingMessagesData.messages.length > 0) {
                console.log(`🧹 [AUTO-RESTORE] Clearing ${existingMessagesData.messages.length} existing messages...`);
                for (const message of existingMessagesData.messages) {
                    await fetch(`/api/saved-messages/${message.id}`, { method: 'DELETE' });
                }
                console.log('✅ [AUTO-RESTORE] Existing messages cleared');
            }
        } catch (error) {
            console.error('❌ [AUTO-RESTORE] Error clearing existing messages:', error);
        }
        
        // Clear existing markers first
        try {
            const existingMarkersResponse = await fetch('/api/event-markers');
            const existingMarkersData = await existingMarkersResponse.json();
            
            if (existingMarkersData.markers && existingMarkersData.markers.length > 0) {
                console.log(`🧹 [AUTO-RESTORE] Clearing ${existingMarkersData.markers.length} existing markers...`);
                for (const marker of existingMarkersData.markers) {
                    await fetch(`/api/event-markers/${marker.id}`, { method: 'DELETE' });
                }
                console.log('✅ [AUTO-RESTORE] Existing markers cleared');
            }
        } catch (error) {
            console.error('❌ [AUTO-RESTORE] Error clearing existing markers:', error);
        }
        
        // Apply and send messages/markers to server (now on clean slate)
        const hasMessages = savedSettings.savedMessages?.messages?.length > 0;
        const hasMarkers = savedSettings.eventMarkers?.markers?.length > 0;
        
        if (hasMessages) {
            const messages = savedSettings.savedMessages.messages;
            console.log(`💬 Sending ${messages.length} messages to server...`);
            
            for (const message of messages) {
                await fetch('/api/saved-messages/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message.content })
                });
            }
        }
        
        if (hasMarkers) {
            const markers = savedSettings.eventMarkers.markers;
            console.log(`📍 Sending ${markers.length} markers to server...`);
            
            for (const marker of markers) {
                await fetch('/api/event-markers/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        time: marker.time,
                        title: marker.title,
                        note: marker.note || '',
                        type: marker.type || null
                    })
                });
            }
        }
        
        // 🚀 PRO: Apply advanced settings (silent auto-restore)
        if (savedSettings.display) {
            if (savedSettings.display.timerFontFamily) {
                const fontFamilyField = document.getElementById('timer-font-family');
                if (fontFamilyField) fontFamilyField.value = savedSettings.display.timerFontFamily;
            }
            if (savedSettings.display.currentMessage) {
                const messageInputField = document.getElementById('message-input');
                if (messageInputField) messageInputField.value = savedSettings.display.currentMessage;
            }
        }
        
        if (savedSettings.vmix && savedSettings.vmix.manualTimerInput) {
            const manualInputField = document.getElementById('vmix-timer-export-input');
            if (manualInputField) manualInputField.value = savedSettings.vmix.manualTimerInput;
        }
        
        if (savedSettings.advanced) {
            if (savedSettings.advanced.clockMode !== undefined) {
                window.clockMode = savedSettings.advanced.clockMode;
                const clockModeCheckbox = document.getElementById('clock-mode-checkbox');
                if (clockModeCheckbox) clockModeCheckbox.checked = savedSettings.advanced.clockMode;
            }
            if (savedSettings.advanced.currentPC) {
                localStorage.setItem('currentPCName', savedSettings.advanced.currentPC);
            }
            if (savedSettings.advanced.timeLeft !== undefined) {
                window.timeLeft = savedSettings.advanced.timeLeft;
            }
            if (savedSettings.advanced.originalTime !== undefined) {
                window.originalTime = savedSettings.advanced.originalTime;
            }
        }
        
        if (savedSettings.ui) {
            if (savedSettings.ui.eventStartTime) {
                const startTimeField = document.getElementById('event-start-time-settings');
                if (startTimeField) startTimeField.value = savedSettings.ui.eventStartTime;
            }
            if (savedSettings.ui.eventEndTime) {
                const endTimeField = document.getElementById('event-end-time-settings');
                if (endTimeField) endTimeField.value = savedSettings.ui.eventEndTime;
            }
        }
        
        console.log('✅ PRO: All advanced settings applied successfully (silent auto-restore)');
        
        // 🔥 Apply restored settings to UI (for consistency, even though silent restore is disabled)
        try {
            console.log('🎨 [SILENT] Applying restored settings to UI...');
            
            // Apply key settings silently 
            updateTimerDisplay();
            updatePreviewLogos();
            
            console.log('✅ [SILENT] UI updated with restored settings');
        } catch (uiError) {
            console.error('❌ [SILENT] Failed to update UI:', uiError);
        }
        
    } catch (error) {
        console.error('❌ Failed to apply saved settings:', error);
    }
}

// Event-driven save function (όπως το vMix - αποθηκεύει όταν αλλάζει κάτι)
async function triggerEventDrivenSave(reason) {
    try {
        console.log(`💾 Event-driven save triggered: ${reason}`);
        
        // Use the same auto-save logic
        await performSilentAutoSave();
        
        console.log(`✅ Event-driven save completed: ${reason}`);
        
    } catch (error) {
        console.error(`❌ Event-driven save failed (${reason}):`, error);
    }
}

// Helper functions για auto-save που παίρνουν δεδομένα από server
async function getSavedMessagesForAutoSave() {
    try {
        const response = await fetch('/api/saved-messages');
        if (response.ok) {
            const messages = await response.json();
            console.log(`📥 Auto-save: Fetched ${messages.length} saved messages`);
            return messages;
        }
    } catch (error) {
        console.log('⚠️ Auto-save: Could not fetch saved messages, using empty array');
    }
    return [];
}

async function getEventMarkersForAutoSave() {
    try {
        const response = await fetch('/api/event-markers');
        if (response.ok) {
            const markers = await response.json();
            console.log(`📥 Auto-save: Fetched ${markers.length} event markers`);
            return markers;
        }
    } catch (error) {
        console.log('⚠️ Auto-save: Could not fetch event markers, using empty array');
    }
    return [];
}

// ------ FINAL CLEAR ALL DATA FUNCTION - NUCLEAR RESET ------
async function clearAllData() {
    // ΒΗΜΑ 1: ΕΠΙΒΕΒΑΙΩΣΗ ΜΕ ΑΣΦΑΛΕΣ ELECTRON DIALOG
   // Έλεγχος environment - Electron ή Browser
const currentLang = localStorage.getItem('preferredLanguage') || 'el';

const title = currentLang === 'en'
    ? 'WARNING - COMPLETE DELETION!'
    : 'ΠΡΟΣΟΧΗ - ΠΛΗΡΗΣ ΔΙΑΓΡΑΦΗ!';

const message = currentLang === 'en'
    ? `This action will DELETE ALL data:

• All Event Markers
• All Saved Messages
• Excel & Google Sheets monitoring
• Stream Deck slots
• Logos and settings
• localStorage & cache

FORGET EVERYTHING - Start Fresh!

Are you 100% sure?`
    : `Αυτή η ενέργεια θα διαγράψει ΠΑΝΤΑ τα δεδομένα:

• Όλα τα Event Markers
• Όλα τα Saved Messages
• Excel & Google Sheets monitoring
• Stream Deck slots
• Λογότυπα και ρυθμίσεις
• localStorage & cache

ΞΕΧΝΑ ΤΑ ΠΑΝΤΑ - Start Fresh!

Είστε 100% σίγουροι;`;

const userConfirmed = await showCustomConfirm(title, message);
    
    if (!userConfirmed) {
        console.log("🚫 Nuclear reset canceled by user");
        return;
    }
    
    console.log('🔥 === STARTING NUCLEAR RESET - CLEAR EVERYTHING ===');
    
    try {
        // 🔥 STEP 1: ΔΙΑΓΡΑΦΗ SAVED MESSAGES ΑΠΟ SERVER & CLIENT
        console.log('🗑️ Clearing saved messages...');
        if (savedMessages && savedMessages.length > 0) {
            for (const message of savedMessages) {
                try {
                    await fetch(`/api/saved-messages/${message.id}`, { method: 'DELETE' });
                } catch (error) {
                    console.error('Error deleting message:', error);
                }
            }
        }
        // Server bulk delete
        try {
            await fetch('/api/saved-messages/clear-all', { method: 'DELETE' });
        } catch (error) {
            console.error('Bulk message delete error:', error);
        }
        savedMessages = [];
        
        // 🔥 STEP 2: ΔΙΑΓΡΑΦΗ EVENT MARKERS ΑΠΟ SERVER & CLIENT
        console.log('🗑️ Clearing event markers...');
        if (eventMarkers && eventMarkers.length > 0) {
            for (const marker of eventMarkers) {
                try {
                    await fetch(`/api/event-markers/${marker.id}`, { method: 'DELETE' });
                } catch (error) {
                    console.error('Error deleting marker:', error);
                }
            }
        }
        // Server bulk delete
        try {
            await fetch('/api/event-markers/clear-all', { method: 'DELETE' });
        } catch (error) {
            console.error('Bulk marker delete error:', error);
        }
        eventMarkers = [];
        
        // 🔥 STEP 3: EXCEL & GOOGLE SHEETS - ΠΛΗΡΗ ΔΙΑΓΡΑΦΗ
        console.log('📊 Stopping all monitoring...');
        try {
            await fetch('/api/markers/clear-excel', { method: 'POST' });
            await fetch('/api/markers/stop-monitoring', { method: 'POST' });
            await fetch('/api/google-sheets/stop-monitoring', { method: 'POST' });
            await fetch('/api/google-sheets/clear', { method: 'POST' });
            console.log('✅ Excel & Google Sheets monitoring stopped');
        } catch (error) {
            console.error('Monitoring clear error:', error);
        }
        // 🔥 STEP 3.1: ΚΑΘΑΡΙΣΜΟΣ BACKGROUND INTERVALS & AUTO-CHECKS
console.log('🔄 Clearing background intervals and auto-checks...');
try {
    // Καθαρισμός όλων των timers/intervals
    if (window.excelMonitorInterval) {
        clearInterval(window.excelMonitorInterval);
        window.excelMonitorInterval = null;
    }
    
    if (window.googleSheetsInterval) {
        clearInterval(window.googleSheetsInterval);
        window.googleSheetsInterval = null;
    }
    
    // ΚΛΕΙΔΙ: Disable το auto-check για Excel
    window.disableExcelAutoCheck = true;
    
    console.log('✅ Background intervals and auto-checks cleared');
} catch (error) {
    console.error('Interval clear error:', error);
}
        

        // 🔥 STEP 4: STREAM DECK SLOTS - ΚΑΘΑΡΙΣΜΟΣ
        console.log('🎛️ Clearing Stream Deck slots...');
        try {
            for (let i = 0; i < 8; i++) {
                await fetch(`/api/streamdeck-slots/clear/${i}`, { method: 'POST' });
            }
            console.log('✅ Stream Deck slots cleared');
        } catch (error) {
            console.error('Stream Deck clear error:', error);
        }

        // 🔥 STEP 5: ΕΠΑΝΑΦΟΡΑ ΟΛΩΝ ΤΩΝ ΡΥΘΜΙΣΕΩΝ ΣΤΑ DEFAULT
        console.log('⚙️ Resetting all settings to defaults...');
        
        // Timer settings - DEFAULT (15 λεπτά)
        const mainHoursField = document.getElementById('main-timer-hours');
        const mainMinutesField = document.getElementById('main-timer-minutes');
        const mainSecondsField = document.getElementById('main-timer-seconds');
        const mainWarningField = document.getElementById('main-warning-threshold');
        
        if (mainHoursField) mainHoursField.value = 0;
        if (mainMinutesField) mainMinutesField.value = 15;  // 15 λεπτά default
        if (mainSecondsField) mainSecondsField.value = 0;
        if (mainWarningField) mainWarningField.value = 60;
        
        timeLeft = 900;      // 15 λεπτά × 60 = 900 δευτερόλεπτα
        originalTime = 900;  // 15 λεπτά × 60 = 900 δευτερόλεπτα
        warningThreshold = 60;
        
        // Title - DEFAULT
        const defaultTitle = 'TimeCast® Pro Conference Timer';
        safeUpdateElement('title-input', 'value', defaultTitle);
        safeUpdateElement('title-preview', 'textContent', defaultTitle);
        document.title = "Admin - " + defaultTitle;
        titleFontSize = 32;
        
        // Timer Font Family - DEFAULT
        document.getElementById('timer-font-family').value = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
        
        // Message - CLEAR
        safeUpdateElement('message-input', 'value', '');
        safeUpdateElement('message-preview', 'textContent', '');
        isMessageVisible = false;
        
        // Timeline - DEFAULT
        document.getElementById('event-start-time-settings').value = '09:00';
        document.getElementById('event-end-time-settings').value = '17:00';
        document.getElementById('timeline-start-display').textContent = '09:00';
        document.getElementById('timeline-end-display').textContent = '17:00';
        
        // Background - DEFAULT
        const defaultBgColor = '#2c3e50';
        document.getElementById('background-color').value = defaultBgColor;
        
        // Safe background preview update
        const backgroundPreview = document.getElementById('background-preview');
        if (backgroundPreview) {
            backgroundPreview.style.backgroundColor = defaultBgColor;
        }
        
        const previewScreen = document.querySelector('#preview-screen');
        if (previewScreen) {
            previewScreen.style.backgroundColor = defaultBgColor;
        }
        
        // 🧹 CLEAR ANY INLINE STYLES from previous restore
        const titlePreview = document.getElementById('title-preview');
        if (titlePreview) {
            titlePreview.textContent = defaultTitle;
            titlePreview.style.fontSize = ''; // Clear inline font size
        }
        
        const timerPreview = document.getElementById('timer-preview');
        if (timerPreview) {
            timerPreview.style.fontFamily = ''; // Clear inline font family
        }
        
        // Logo - CLEAR EVERYTHING
        logoDataUrl = '';
        logoSize = 80;
        const logoPreview = document.getElementById('logo-preview');
        if (logoPreview) {
            logoPreview.src = '';
            logoPreview.style.display = 'none';
        }
        
        // Logo position - DEFAULT (top-left)
        const topLeftRadio = document.querySelector('input[name="logo-position"][value="top-left"]');
        if (topLeftRadio) {
            topLeftRadio.checked = true;
        }
        
        // Sound - DEFAULT
        soundEnabled = true;
        soundVolume = 0.7;
        document.getElementById('sound-enabled').checked = true;
        document.getElementById('sound-volume').value = 0.7;

        // 🔥 STEP 6: UI ELEMENTS - ΞΕΧΝΑ ΤΑ ΠΑΝΤΑ
        console.log('🖥️ Resetting UI elements...');
        try {
            // File displays - RESET
            const fileElements = [
                'current-file-name', 'current-file-path', 'current-file-display',
                'excel-status-modal'
            ];
            
            fileElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    if (id.includes('name')) element.textContent = 'Κανένα αρχείο δεν έχει φορτωθεί';
                    else if (id.includes('path')) element.textContent = '';
                    else if (id.includes('display')) element.className = 'current-file-info no-file';
                    else if (id.includes('status')) element.innerHTML = '❌ Κανένα αρχείο Excel δεν έχει φορτωθεί';
                }
            });
            
            // Clear timeline markers
            const timelineBar = document.getElementById('timeline-bar');
            if (timelineBar) {
                const markers = timelineBar.querySelectorAll('.event-marker');
                markers.forEach(marker => marker.remove());
            }
            
            // Clear messages list
            const messagesList = document.getElementById('messages-list');
            if (messagesList) {
                const currentLang = localStorage.getItem('preferredLanguage') || 'el';
                const noMessagesText = currentLang === 'en' ? 'No saved messages' : 'Δεν υπάρχουν αποθηκευμένα μηνύματα';
                messagesList.innerHTML = `<p style="color: #95a5a6; font-style: italic;">${noMessagesText}</p>`;
            }
            
            // Render empty arrays
            if (typeof renderSavedMessages === 'function') renderSavedMessages();
            if (typeof renderEventMarkers === 'function') renderEventMarkers();
            
            console.log('✅ UI completely reset');
        } catch (error) {
            console.error('UI reset error:', error);
        }

        // 🔥 STEP 7: GLOBAL VARIABLES - RESET ΤΑ ΠΑΝΤΑ
        console.log('🌐 Resetting global variables...');
        try {
            // Reset global state
            window.currentExcelFile = null;
            window.currentGoogleSheet = null;
            window.lastImportSource = null;
            
            console.log('✅ Global variables reset');
        } catch (error) {
            console.error('Global reset error:', error);
        }

        // 🔥 STEP 8: ΑΠΟΣΤΟΛΗ ΣΤΟΝ SERVER ΓΙΑ ΠΛΗΡΗ ΕΠΑΝΑΦΟΡΑ
        console.log('🔄 Requesting full server reset...');
        if (isConnected && socket) {
            socket.emit('fullResetToDefaults');
        } else {
            console.warn('Not connected to server - settings not synchronized');
        }
        
        // 🔥 STEP 9: UI FORCE UPDATE
        console.log('🎨 Force updating UI...');
        await new Promise(resolve => setTimeout(resolve, 500));
        
        try {
            updatePreviewLogos();
            updateTimerDisplay();
            updatePreviewProgressBar();
            
            // Άμεση εφαρμογή μεγέθους τίτλου
            const titlePreview = document.getElementById('title-preview');
            if (titlePreview) {
                titlePreview.style.fontSize = '32px';
            }
            
            if (typeof updateEventTimelineFeed === 'function') {
                updateEventTimelineFeed();
            }
            
            console.log('✅ UI force-updated after reset');
        } catch (error) {
            console.error('Error during UI update:', error);
        }
        
        // 🔥 STEP 10: NUCLEAR STORAGE CLEAR
        console.log('💾 Nuclear storage clear...');
        try {
            localStorage.clear();
            sessionStorage.clear();
            
            // Clear any remaining cache
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => caches.delete(name));
                });
            }
            
            console.log('✅ All storage nuked');
        } catch (error) {
            console.error('Storage clear error:', error);
        }

        console.log('🔥 === NUCLEAR RESET COMPLETED - EVERYTHING FORGOTTEN ===');
        
        // 🔥 STEP 11: ΠΛΗΡΗΣ SERVER RESET - ΠΕΡΙΜΕΝΕ ΝΑ ΟΛΟΚΛΗΡΩΘΕΙ
console.log('🔄 Forcing complete server reset...');
if (isConnected && socket) {
    // Στείλε το reset command
    socket.emit('fullResetToDefaults');
    
    // ΠΕΡΙΜΕΝΕ να ολοκληρωθεί ο server reset
    await new Promise((resolve) => {
        socket.once('fullStateUpdate', (data) => {
            console.log('✅ Server reset confirmed:', data.title, data.timelineSettings);
            resolve();
        });
        
        // Timeout fallback
        setTimeout(resolve, 2000);
    });
    
    console.log('✅ Server reset completed');
} else {
    console.warn('❌ Socket not connected - server may retain old data');
}

// 🔥 STEP 11: YEELIGHT RESET
console.log('💡 Resetting Yeelight settings...');
try {
    if (window.yeelightManager) {
        // Reset Yeelight manager to defaults
        window.yeelightManager.isEnabled = false;
        window.yeelightManager.brightness = 100;
        window.yeelightManager.selectedBulbs = [];
        window.yeelightManager.connectedBulbs = [];
        window.yeelightManager.currentTimerState = 'idle';

        // Clear any pending selections
        delete window.yeelightManager.pendingSelectedBulbs;
        delete window.yeelightManager.lastRestoredBulbs;

        // Reset UI elements
        const brightnessSlider = document.getElementById('yeelight-brightness-slider');
        const brightnessValue = document.getElementById('yeelight-brightness-value');
        const statusDiv = document.getElementById('yeelight-status');
        const tableDiv = document.getElementById('yeelight-bulb-table');

        if (brightnessSlider) brightnessSlider.value = 100;
        if (brightnessValue) brightnessValue.textContent = '100%';
        if (statusDiv) {
            statusDiv.textContent = '●●● Αναζήτηση...';
            statusDiv.style.color = '#ff69b4';
        }
        if (tableDiv) {
            tableDiv.innerHTML = '<div style="color: #fff; text-align: center; padding: 20px;">🔍 Αναζήτηση λαμπών...</div>';
        }

        console.log('✅ Yeelight settings reset to defaults');
    } else {
        console.log('⚠️ Yeelight manager not available for reset');
    }
} catch (error) {
    console.error('Error resetting Yeelight:', error);
}

console.log('🔄 Nuclear reset complete - Reloading...');


    } catch (error) {
        console.error('🚨 Critical error during nuclear reset:', error);
        console.error('❌ Nuclear reset failed:', error.message);
    }
}
// ΠΡΟΣΘΗΚΗ: Βοηθητική συνάρτηση για update timer από main inputs
function updateTimerFromMainInputs() {
    const hours = parseInt(document.getElementById('main-timer-hours').value) || 0;
    const minutes = parseInt(document.getElementById('main-timer-minutes').value) || 0;
    const seconds = parseInt(document.getElementById('main-timer-seconds').value) || 0;
    
    const totalSeconds = hours * 3600 + minutes * 60 + seconds;
    window.timeLeft = totalSeconds;
    window.originalTime = totalSeconds;
    
    updateTimerDisplay();
    console.log('Timer updated from main inputs:', totalSeconds);
    
    // 🔥 Event-driven save: Timer change
    triggerEventDrivenSave('timer updated from main inputs');
}
       // ------ NOSLEEP FOR ADMIN PANEL (SEPARATE DEVICE) ------
       const adminNoSleep = new NoSleep();
       let adminNoSleepEnabled = false;
       
       // Ενεργοποίηση με πρώτο κλικ
       document.addEventListener('click', function enableAdminNoSleep() {
           if (!adminNoSleepEnabled) {
               try {
                   adminNoSleep.enable();
                   adminNoSleepEnabled = true;
                   console.log('Admin NoSleep ενεργοποιήθηκε');
                   showAdminNoSleepNotification();
                   document.removeEventListener('click', enableAdminNoSleep, false);
               } catch (error) {
                   console.error('Admin NoSleep failed:', error);
               }
           }
       }, false);
       
       // Ενεργοποίηση με touch για tablets/mobile admin
       document.addEventListener('touchstart', function enableAdminNoSleepTouch() {
           if (!adminNoSleepEnabled) {
               try {
                   adminNoSleep.enable();
                   adminNoSleepEnabled = true;
                   console.log('Admin NoSleep ενεργοποιήθηκε (touch)');
                   showAdminNoSleepNotification();
                   document.removeEventListener('touchstart', enableAdminNoSleepTouch, false);
               } catch (error) {
                   console.error('Admin NoSleep touch failed:', error);
               }
           }
       }, false);
       
       // Επανενεργοποίηση κάθε 1 λεπτό
       setInterval(() => {
           if (adminNoSleepEnabled && adminNoSleep) {
               try {
                   adminNoSleep.enable();
               } catch (error) {
                   console.error('Admin NoSleep reactivation failed:', error);
               }
           }
       }, 60000);
       
       // Ειδοποίηση ενεργοποίησης
       function showAdminNoSleepNotification() {
           const notification = document.createElement('div');
           notification.style.cssText = `
               position: fixed;
               top: 80px;
               right: 20px;
               background-color: #3498db;
               color: white;
               padding: 8px 15px;
               border-radius: 5px;
               font-size: 0.8rem;
               z-index: 10000;
               pointer-events: none;
           `;
           notification.textContent = '🔋 Admin Screen Active';
           document.body.appendChild(notification);
           
           setTimeout(() => {
               if (notification.parentNode) {
                   notification.parentNode.removeChild(notification);
               }
           }, 2500);
       }
       

       // ------ HEADER CLOCK ------
       function updateHeaderClock() {
           const now = new Date();
           const hours = String(now.getHours()).padStart(2, '0');
           const minutes = String(now.getMinutes()).padStart(2, '0');
           const seconds = String(now.getSeconds()).padStart(2, '0');
           
           // Ημερομηνία στη μορφή 02-AUG-2025
           const day = String(now.getDate()).padStart(2, '0');
           const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                              'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
           const month = monthNames[now.getMonth()];
           const year = now.getFullYear();
           
           const timeString = `${hours}:${minutes}:${seconds}`;
           
           const timeElement = document.getElementById('header-time');
           
           if (timeElement) {
               timeElement.textContent = timeString;
           }
       }
       
       // Ενημέρωση ρολογιού κάθε δευτερόλεπτο
       setInterval(updateHeaderClock, 1000);
       
       // Εκκίνηση ρολογιού
       updateHeaderClock();

       // ------ EVENT TIMELINE FUNCTIONS ------


function handleTimelineResize() {
    const timelineBar = document.getElementById('timeline-bar');
    if (!timelineBar) return;
    
    //console.log('Timeline resized - recalculating marker positions');
    
    // Επαναυπολογισμός όλων των markers
    const markers = timelineBar.querySelectorAll('.event-marker');
    
    markers.forEach(marker => {
        const markerId = marker.dataset.markerId;
        const markerData = eventMarkers.find(m => m.id === markerId);
        
        if (markerData && markerData.time) {
            // Επαναυπολογισμός percentage από την απόλυτη ώρα
            const startTime = document.getElementById('timeline-start-display').textContent || '09:00';
            const endTime = document.getElementById('timeline-end-display').textContent || '17:00';
            
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            const markerMinutes = timeToMinutes(markerData.time);
            
            const totalDuration = endMinutes - startMinutes;
            const elapsedFromStart = markerMinutes - startMinutes;
            const calculatedPercentage = (elapsedFromStart / totalDuration) * 100;
            
           // ΑΚΡΙΒΗΣ επαναυπολογισμός
const exactPercentage = calculatePercentageFromTime(markerData.time);
marker.style.left = `${exactPercentage}%`;
           marker.style.left = `${exactPercentage}%`;

        }
    });
}

// Window resize event listener
window.addEventListener('resize', () => {
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(handleTimelineResize, 250);
});

// Βοηθητική συνάρτηση για υπολογισμό ώρας από ποσοστό
function calculateTimeFromPercentage(percentage) {
    const startTimeDisplay = document.getElementById('timeline-start-display');
    const endTimeDisplay = document.getElementById('timeline-end-display');
    
    if (!startTimeDisplay || !endTimeDisplay) {
        console.log('Timeline displays not found');
        return '00:00';
    }
    
    const startTime = startTimeDisplay.textContent || '09:00';
    const endTime = endTimeDisplay.textContent || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const totalDuration = endMinutes - startMinutes;
    
    // SNAP TO MINUTE - ακέραια λεπτά μόνο
    const currentMinutes = startMinutes + (totalDuration * percentage / 100);
    const roundedMinutes = Math.round(currentMinutes);
    
    return minutesToTime(roundedMinutes);
}
// ΑΚΡΙΒΗΣ υπολογισμός ποσοστού από ώρα - για repositioning
function calculatePercentageFromTime(timeStr) {
    const startTimeDisplay = document.getElementById('timeline-start-display');
    const endTimeDisplay = document.getElementById('timeline-end-display');
    
    if (!startTimeDisplay || !endTimeDisplay) {
        return 0;
    }
    
    const startTime = startTimeDisplay.textContent || '09:00';
    const endTime = endTimeDisplay.textContent || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const targetMinutes = timeToMinutes(timeStr);
    
    const totalDuration = endMinutes - startMinutes;
    const elapsed = targetMinutes - startMinutes;
    
    return (elapsed / totalDuration) * 100;
}
// ===== FIXED TIMELINE TOOLTIP FUNCTION - ΠΑΛΙΟ POSITIONING =====
function initializeTimelineTooltipDelayed() {
    console.log('🔧 Initializing timeline tooltip (delayed)');
    
    setTimeout(() => {
        // ΣΩΣΤΑ SELECTORS - χρήση των IDs που υπάρχουν
        const timelineBar = document.getElementById('timeline-bar') || 
                           document.querySelector('.timeline-bar-container') ||
                           document.querySelector('#timeline-bar-container');
        
        if (!timelineBar) {
            console.log('⚠️ Timeline bar not found - checking available elements:');
            console.log('Available timeline elements:', {
                'timeline-bar': !!document.getElementById('timeline-bar'),
                'timeline-progress-bar': !!document.querySelector('.timeline-progress-bar'),
                'timeline-container': !!document.querySelector('.timeline-container')
            });
            return;
        }
        
        console.log('✅ Timeline elements found:', {
            timelineBar: !!timelineBar,
            timelineBarId: timelineBar.id,
            timelineBarClass: timelineBar.className
        });
        
        // Χρήση του existing tooltip ή δημιουργία νέου
        let tooltip = document.getElementById('timeline-tooltip');
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.id = 'timeline-tooltip';
            tooltip.className = 'timeline-tooltip'; // Προσθήκη class για CSS
            
            // ΠΑΛΙΟ CSS SYSTEM - relative positioning
            tooltip.style.cssText = `
                position: absolute !important;
                bottom: -35px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                background-color: rgba(0, 0, 0, 0.9) !important;
                color: white !important;
                padding: 5px 10px !important;
                border-radius: 4px !important;
                font-size: 0.8rem !important;
                font-family: 'Courier New', monospace !important;
                white-space: nowrap !important;
                opacity: 0 !important;
                pointer-events: none !important;
                transition: opacity 0.2s ease !important;
                z-index: 1000 !important;
            `;
            
            // Προσθήκη του tooltip ΜΕΣΑ στο timeline bar (όχι στο body)
            timelineBar.appendChild(tooltip);
            console.log('✅ New tooltip created and added to timeline bar');
        } else {
            console.log('✅ Using existing tooltip');
        }
        
        // Mouse move event για tooltip - ΠΑΛΙΟ SYSTEM
        timelineBar.addEventListener('mousemove', (e) => {
            const rect = timelineBar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
            
            // Υπολογισμός ώρας βάσει του ποσοστού
            const calculatedTime = calculateTimeFromPercentage(percentage);
            
            // Ενημέρωση περιεχομένου tooltip - ΜΟΝΟ Η ΩΡΑ
            tooltip.textContent = calculatedTime;
            
            // Τοποθέτηση tooltip στη σωστή θέση - PERCENTAGE BASED
            tooltip.style.left = `${Math.max(0, Math.min(percentage, 100))}%`;
            
            // Εμφάνιση tooltip
            tooltip.classList.add('show');
            
            
        });
        
        // Mouse leave event για απόκρυψη tooltip
        timelineBar.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show');
            
        });
        
        // Βεβαιώσου ότι υπάρχει το CSS για .show class
        if (!document.querySelector('style[data-tooltip-css]')) {
            const style = document.createElement('style');
            style.setAttribute('data-tooltip-css', 'true');
            style.textContent = `
                .timeline-tooltip.show {
                    opacity: 1 !important;
                }
            `;
            document.head.appendChild(style);
            console.log('✅ Tooltip CSS added');
        }
        
        console.log('✅ Timeline tooltip initialized successfully (old positioning system)');
        
    }, 200);
}
// Helper functions για timeline calculations
function getTimelineStartTime() {
    const startInput = document.getElementById('timeline-start');
    return startInput ? startInput.value || '09:00' : '09:00';
}

function getTimelineEndTime() {
    const endInput = document.getElementById('timeline-end');
    return endInput ? endInput.value || '17:00' : '17:00';
}

function calculateTimeFromPercentage(percentage) {
    const startTimeDisplay = document.getElementById('timeline-start-display');
    const endTimeDisplay = document.getElementById('timeline-end-display');
    
    
    
    if (!startTimeDisplay || !endTimeDisplay) {
        console.log('Timeline displays not found');
        return '00:00';
    }
    
    const startTime = startTimeDisplay.textContent || '09:00';
    const endTime = endTimeDisplay.textContent || '17:00';
    
    
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const totalDuration = endMinutes - startMinutes;
    
    // SNAP TO MINUTE - ακέραια λεπτά μόνο
    const currentMinutes = startMinutes + (totalDuration * percentage / 100);
    const roundedMinutes = Math.round(currentMinutes);
    
    return minutesToTime(roundedMinutes);
}

function timeToMinutes(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
}

function minutesToTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
}

/// ΑΦΑΙΡΕΣΗ DOMContentLoaded - Θα καλείται από το κύριο initialization


// Καλείται από το κύριο DOMContentLoaded
setTimeout(() => {
    initializeTimelineTooltipDelayed();
}, 2000);
       
       // Βοηθητική συνάρτηση: HH:MM -> minutes
       function timeToMinutes(timeString) {
           const [hours, minutes] = timeString.split(':').map(Number);
           return hours * 60 + minutes;
       }
       
       // Βοηθητική συνάρτηση: minutes -> HH:MM
       function minutesToTime(totalMinutes) {
           const hours = Math.floor(totalMinutes / 60);
           const minutes = totalMinutes % 60;
           return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
       }
       
       
// Custom dialog για Electron marker creation
function createMarkerDialog(markerTime, percentage) {
    // Δημιουργία modal dialog
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    const dialogBox = document.createElement('div');
    dialogBox.style.cssText = `
        background: #2c3e50;
        color: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        min-width: 450px;
        max-width: 90vw;
        max-height: 90vh;
        box-sizing: border-box;
    `;
    
    const currentLang = localStorage.getItem('preferredLanguage') || 'el';
    const texts = {
        el: {
            title: `🆕 Δημιουργία Event στις ${markerTime}`,
            titleLabel: '📌 Τίτλος:',
            titlePlaceholder: 'Εισάγετε τίτλο...',
            notesLabel: '📝 Σημειώσεις:',
            notesPlaceholder: 'Σημειώσεις (προαιρετικό)...',
            createBtn: '✅ Δημιουργία',
            cancelBtn: '❌ Ακύρωση'
        },
        en: {
            title: `🆕 Create Event at ${markerTime}`,
            titleLabel: '📌 Title:',
            titlePlaceholder: 'Enter title...',
            notesLabel: '📝 Notes:',
            notesPlaceholder: 'Notes (optional)...',
            createBtn: '✅ Create',
            cancelBtn: '❌ Cancel'
        }
    };
    const t = texts[currentLang];
    
    dialogBox.innerHTML = `
        <h3>${t.title}</h3>
        
        <!-- Title Input -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">${t.titleLabel}</label>
            <input type="text" id="marker-title-input" placeholder="${t.titlePlaceholder}" 
                   style="width: 100%; padding: 10px; font-size: 16px; border: none; border-radius: 5px; box-sizing: border-box;">
        </div>
        
        <!-- Notes Input -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">${t.notesLabel}</label>
            <textarea id="marker-note-input" placeholder="${t.notesPlaceholder}" 
                      style="width: 100%; padding: 10px; font-size: 16px; border: none; border-radius: 5px; resize: vertical; min-height: 60px; max-height: 120px; box-sizing: border-box; font-family: inherit;"></textarea>
        </div>
        
        <!-- Buttons -->
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
            <button id="marker-ok-btn" style="background: #3498db; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1; font-size: 14px;">
                ${t.createBtn}
            </button>
            <button id="marker-cancel-btn" style="background: #95a5a6; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1; font-size: 14px;">
                ${t.cancelBtn}
            </button>
        </div>
    `;
    
    dialog.appendChild(dialogBox);
    document.body.appendChild(dialog);
    
    // Focus στο input
    const input = document.getElementById('marker-title-input');
    const noteInput = document.getElementById('marker-note-input');
    input.focus();
    
    // Keyboard support
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            noteInput.focus();
        }
    });
    
    noteInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('marker-ok-btn').click();
        }
    });
    
    // Event listeners
    document.getElementById('marker-ok-btn').onclick = () => {
        const title = input.value.trim();
        const note = document.getElementById('marker-note-input').value.trim();
        if (title) {
            createEventMarker(percentage, markerTime, title, note);
            //console.log('Marker created:', title, note);
        }
        document.body.removeChild(dialog);
    };
    
    document.getElementById('marker-cancel-btn').onclick = () => {
        //console.log('Marker creation cancelled');
        document.body.removeChild(dialog);
    };
    
    // Enter για OK
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            document.getElementById('marker-ok-btn').click();
        } else if (e.key === 'Escape') {
            document.getElementById('marker-cancel-btn').click();
        }
    };
}
// Enhanced Edit Marker Dialog με NoSleep disable - ΔΙΟΡΘΩΜΕΝΗ
function createEditMarkerDialog(markerData) {
    // Παύση NoSleep κατά τη διάρκεια editing
    if (window.noSleep && window.noSleep.isEnabled) {
        window.noSleep.disable();
        console.log('🛑 NoSleep disabled for editing');
    }
    
    // Δημιουργία modal dialog
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;
    
    const dialogBox = document.createElement('div');
    dialogBox.style.cssText = `
        background: #2c3e50;
        color: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        min-width: 450px;
    `;
    
    const currentLang = localStorage.getItem('preferredLanguage') || 'el';
    const texts = {
        el: {
            title: '📝 Επεξεργασία Event',
            timeLabel: '🕒 Ώρα:',
            titleLabel: '📌 Τίτλος:',
            notesLabel: '📝 Σημειώσεις:',
            notesPlaceholder: 'Σημειώσεις (προαιρετικό)...',
            sourceLabel: '📊 Προέλευση:',
            saveBtn: '💾 Αποθήκευση',
            deleteBtn: '🗑️ Διαγραφή',
            cancelBtn: '❌ Ακύρωση'
        },
        en: {
            title: '📝 Edit Event',
            timeLabel: '🕒 Time:',
            titleLabel: '📌 Title:',
            notesLabel: '📝 Notes:',
            notesPlaceholder: 'Notes (optional)...',
            sourceLabel: '📊 Source:',
            saveBtn: '💾 Save',
            deleteBtn: '🗑️ Delete',
            cancelBtn: '❌ Cancel'
        }
    };
    const t = texts[currentLang];
    
    dialogBox.innerHTML = `
        <h3>${t.title}</h3>
        <br>
        
        <!-- Time Input -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">${t.timeLabel}</label>
            <input type="time" id="edit-marker-time-input" value="${markerData.time}" 
                   style="width: 150px; padding: 10px; font-size: 16px; border: none; border-radius: 5px;">
        </div>
        
        <!-- Title Input -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">${t.titleLabel}</label>
            <input type="text" id="edit-marker-title-input" value="${markerData.title}" 
                   style="width: 100%; padding: 10px; font-size: 16px; border: none; border-radius: 5px;">
        </div>
        
        <!-- Notes Input -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">${t.notesLabel}</label>
            <textarea id="edit-marker-note-input" placeholder="${t.notesPlaceholder}" 
                      style="width: 100%; padding: 10px; font-size: 16px; border: none; border-radius: 5px; resize: vertical; min-height: 60px; max-height: 120px; box-sizing: border-box; font-family: inherit;">${markerData.note || ''}</textarea>
        </div>
        
        <!-- Source Info -->
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">${t.sourceLabel}</label>
            <div style="padding: 10px; background: #34495e; border-radius: 5px; color: #ecf0f1;">
                ${getSourceLabel(markerData.source)}
            </div>
        </div>
        
        <!-- Buttons -->
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
            <button id="edit-marker-ok-btn" style="background: #3498db; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1; font-size: 14px;">
                ${t.saveBtn}
            </button>
            <button id="edit-marker-delete-btn" style="background: #e74c3c; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1; font-size: 14px;">
                ${t.deleteBtn}
            </button>
            <button id="edit-marker-cancel-btn" style="background: #95a5a6; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1; font-size: 14px;">
                ${t.cancelBtn}
            </button>
        </div>
    `;
    
    dialog.appendChild(dialogBox);
    document.body.appendChild(dialog);
    
    // Focus στο title input ΧΩΡΙΣ auto-select
const titleInput = document.getElementById('edit-marker-title-input');
const timeInput = document.getElementById('edit-marker-time-input');

// Απλό focus χωρίς επιλογή κειμένου
setTimeout(() => {
    titleInput.focus();
    // Τοποθέτηση cursor στο τέλος
    titleInput.setSelectionRange(titleInput.value.length, titleInput.value.length);
    console.log('🎯 Cursor positioned at end of text');
}, 100);
    
    // Helper function για re-enable NoSleep
    function reEnableNoSleep() {
        if (window.noSleep) {
            setTimeout(() => {
                window.noSleep.enable();
                console.log('✅ NoSleep re-enabled');
            }, 200);
        }
    }
    
    // Event listeners
    document.getElementById('edit-marker-ok-btn').onclick = () => {
        const newTitle = titleInput.value.trim();
        const newTime = timeInput.value;
        const newNote = document.getElementById('edit-marker-note-input').value.trim();
        
        if (!newTitle) {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Required Field' : 'Απαιτούμενο Πεδίο';
            const message = currentLang === 'en' ? 'Title cannot be empty!' : 'Ο τίτλος δεν μπορεί να είναι κενός!';
            showCustomAlert(title, message);
            return;
        }
        
        if (!newTime) {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Required Field' : 'Απαιτούμενο Πεδίο';
            const message = currentLang === 'en' ? 'Time cannot be empty!' : 'Η ώρα δεν μπορεί να είναι κενή!';
            showCustomAlert(title, message);
            return;
        }
        
        // Έλεγχος αν υπήρξαν αλλαγές
        const titleChanged = newTitle !== markerData.title;
        const timeChanged = newTime !== markerData.time;
        const noteChanged = newNote !== (markerData.note || '');
        
        if (titleChanged || timeChanged || noteChanged) {
            console.log('Updating marker:', {
                id: markerData.id,
                oldTitle: markerData.title,
                newTitle: newTitle,
                oldTime: markerData.time,
                newTime: newTime,
                oldNote: markerData.note || '',
                newNote: newNote
            });
            
            // Κλήση στη βελτιωμένη edit function
            editEventMarkerWithTime(markerData.id, newTitle, newTime, newNote);
        }
        
        // Re-enable NoSleep και κλείσιμο
        reEnableNoSleep();
        document.body.removeChild(dialog);
    };
    
    // Delete button event
    document.getElementById('edit-marker-delete-btn').onclick = () => {
        deleteEventMarker(markerData.id, markerData.title);
        
        // Re-enable NoSleep και κλείσιμο
        reEnableNoSleep();
        document.body.removeChild(dialog);
    };
    
    document.getElementById('edit-marker-cancel-btn').onclick = () => {
        console.log('Edit marker cancelled');
        
        // Re-enable NoSleep και κλείσιμο
        reEnableNoSleep();
        document.body.removeChild(dialog);
    };
    
    // Keyboard shortcuts
    titleInput.onkeydown = (e) => {
        if (e.key === 'Enter') {
            document.getElementById('edit-marker-ok-btn').click();
        } else if (e.key === 'Escape') {
            document.getElementById('edit-marker-cancel-btn').click();
        }
    };
    
    timeInput.onkeydown = (e) => {
        if (e.key === 'Enter') {
            document.getElementById('edit-marker-ok-btn').click();
        } else if (e.key === 'Escape') {
            document.getElementById('edit-marker-cancel-btn').click();
        }
    };
    
    // Escape key για κλείσιμο dialog
    document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape') {
            document.removeEventListener('keydown', escapeHandler);
            document.getElementById('edit-marker-cancel-btn').click();
        }
    });
}
// Custom Google Sheets import dialog για Electron
function createGoogleSheetsDialog() {
    // Δημιουργία modal dialog
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        outline: none; 
-webkit-user-select: text; 
user-select: text;
    `;
    
    const dialogBox = document.createElement('div');
    dialogBox.style.cssText = `
        background: #2c3e50;
        color: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        min-width: 500px;
        max-width: 600px;
    `;
    
    dialogBox.innerHTML = `
        <h3>🌐 GOOGLE SHEETS IMPORT</h3>
        <br>
        
        <div style="text-align: left; margin-bottom: 20px; background: #34495e; padding: 15px; border-radius: 5px; font-size: 14px;">
            <strong>ΟΔΗΓΙΕΣ:</strong><br>
            1. Ανοίξτε το Google Sheet<br>
            2. Κλικ "Share" → "Anyone with the link can view"<br>
            3. Αντιγράψτε το URL<br>
            4. Επικολλήστε παρακάτω<br><br>
            
            <strong>ΜΟΡΦΗ ΔΕΔΟΜΕΝΩΝ:</strong><br>
            A: Time (09:30) | B: Title (Έναρξη) | C: Note (προαιρετικό)
        </div>
        
        <div style="margin-bottom: 20px; text-align: left;">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">🔗 Google Sheets URL:</label>
            <input type="url" id="google-sheets-url-input" placeholder="https://docs.google.com/spreadsheets/d/..." 
                   style="width: 100%; padding: 12px; font-size: 14px; border: none; border-radius: 5px;">
        </div>
        
        <div style="display: flex; gap: 10px; justify-content: center;">
            <button id="google-sheets-ok-btn" style="background: #0f9d58; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1;">
                📊 Import από Google Sheets
            </button>
            <button id="google-sheets-cancel-btn" style="background: #e74c3c; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; flex: 1;">
                ❌ Ακύρωση
            </button>
        </div>
    `;
    
    dialog.appendChild(dialogBox);
    document.body.appendChild(dialog);
    
    // Focus στο input
    const input = document.getElementById('google-sheets-url-input');
    input.focus();
    
    // Event listeners
    document.getElementById('google-sheets-ok-btn').onclick = () => {
        const sheetsUrl = input.value.trim();
        if (sheetsUrl) {
            document.body.removeChild(dialog);
            // Καλούμε την υπάρχουσα logic
            performGoogleSheetsImport(sheetsUrl);
        } else {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Required Field' : 'Απαιτούμενο Πεδίο';
            const message = currentLang === 'en' ? 'Please enter the Google Sheets URL' : 'Παρακαλώ εισάγετε το Google Sheets URL';
            showCustomAlert(title, message);
        }
    };
    
    document.getElementById('google-sheets-cancel-btn').onclick = () => {
        document.body.removeChild(dialog);
    };
    
    // Enter για OK, Escape για Cancel
    input.onkeydown = (e) => {
        if (e.key === 'Enter') {
            document.getElementById('google-sheets-ok-btn').click();
        } else if (e.key === 'Escape') {
            document.getElementById('google-sheets-cancel-btn').click();
        }
    };
}

// Νέα function για edit με time support
// Νέα function για edit με time support + type detection
async function editEventMarkerWithTime(markerId, newTitle, newTime, newNote = '') {
    try {
        // Αναγνώριση νέου type από τον τίτλο
        const newType = determineMarkerType(newTitle);
        
        const response = await fetch('/api/event-markers/edit', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                id: markerId,
                newTitle: newTitle,
                newTime: newTime,
                newNote: newNote,
                newType: newType  // <-- ΠΡΟΣΘΗΚΗ!
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('Marker updated on server:', {
                title: data.marker.title,
                time: data.marker.time,
                type: data.marker.type
            });
            
            // 🔥 Event-driven save: Marker edited
            triggerEventDrivenSave('event marker edited');
        } else {
            console.error('Failed to update marker on server');
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Error updating marker' : 'Σφάλμα κατά την ενημέρωση του marker';
            showCustomAlert(title, message);
        }
    } catch (error) {
        console.error('Error updating marker:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Connection Error' : 'Σφάλμα Σύνδεσης';
        const message = currentLang === 'en' ? 'Server connection error' : 'Σφάλμα σύνδεσης με τον server';
        showCustomAlert(title, message);
    }
}
       // 2. Click για δημιουργία Event Marker
       function initializeMarkerCreationOLD() {
    const timelineBar = document.getElementById('timeline-bar');
    
    if (!timelineBar || timelineBar.dataset.initialized) {
        console.log('Timeline already initialized or not found');
        return;
    }
    
    // Mark as initialized
    timelineBar.dataset.initialized = 'true';
    
    let clickTimeout = null;
    let isProcessing = false;
    
    // Single, clean event listener
    timelineBar.addEventListener('click', function(e) {
        if (isProcessing || clickTimeout) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        // Debounce clicks
        clickTimeout = setTimeout(() => {
            clickTimeout = null;
        }, 500);
        
        // Avoid clicking on existing markers
        if (e.target.classList.contains('event-marker') || e.target.closest('.event-marker')) {
            return;
        }
        
        isProcessing = true;
        
        const rect = timelineBar.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percentage = (x / rect.width) * 100;
        const markerTime = calculateTimeFromPercentage(percentage);
       // Custom dialog για Electron
        createMarkerDialog(markerTime, percentage);
        
        setTimeout(() => {
            isProcessing = false;
        }, 1000);
        
        return; // Έξοδος από τη συνάρτηση
    });
    
    console.log('Clean marker creation initialized');
}
       
       // Συνάρτηση δημιουργίας marker
       function createEventMarker(percentage, time, title) {
           const timelineBar = document.getElementById('timeline-bar');
           
           if (!timelineBar) return;
           
           // Δημιουργία marker element
           const marker = document.createElement('div');
           marker.className = 'event-marker new';
           marker.style.left = `${Math.max(0, Math.min(percentage, 100))}%`;
           marker.title = `${title} - ${time}`;
           
           // Προσδιορισμός χρώματος βάσει λέξεων-κλειδιών
           const markerType = determineMarkerType(title);
           if (markerType) {
               marker.classList.add(markerType);
           }
           
           // Δημιουργία marker tooltip
           const markerTooltip = document.createElement('div');
           markerTooltip.className = 'marker-tooltip';
           markerTooltip.innerHTML = `${getMarkerIcon(markerType)} ${title}<br>${time}`;
           marker.appendChild(markerTooltip);
           
           // Event listeners για marker
           setupMarkerEvents(marker, time, title);
           
           // Προσθήκη στη timeline
           timelineBar.appendChild(marker);
           
           // Αφαίρεση "new" class μετά από animation
           setTimeout(() => {
               marker.classList.remove('new');
           }, 600);
           
           console.log(`Event marker created: "${title}" at ${time}`);
           
           // 💾 EVENT-DRIVEN SAVE: Αποθήκευση όταν δημιουργείται marker
           triggerEventDrivenSave('event marker created');
           
           return marker;
       }
       
       // Προσδιορισμός τύπου marker βάσει τίτλου
       function determineMarkerType(title) {
    const lowerTitle = title.toLowerCase();
    
    // ☕ ΔΙΑΛΕΙΜΜΑΤΑ & ΚΑΦΕ
    if (lowerTitle.includes('διάλειμμα') || lowerTitle.includes('διαλειμμα') || 
        lowerTitle.includes('break') || lowerTitle.includes('καφέ') || 
        lowerTitle.includes('καφε') || lowerTitle.includes('coffee')) {
        return 'break';
    }
    
    // 🍽️ ΓΕΥΜΑΤΑ
    if (lowerTitle.includes('lunch') || lowerTitle.includes('φαγητό') ||
        lowerTitle.includes('φαγητο') || lowerTitle.includes('μεσημεριανό') ||
        lowerTitle.includes('μεσημεριανο') || lowerTitle.includes('γεύμα') ||
        lowerTitle.includes('γευμα')) {
        return 'lunch';
    }
    
    // 🍷 ΔΕΙΠΝΟ & COCKTAIL
    if (lowerTitle.includes('δείπνο') || lowerTitle.includes('δειπνο') ||
        lowerTitle.includes('dinner') || lowerTitle.includes('cocktail') ||
        lowerTitle.includes('κοκτέιλ') || lowerTitle.includes('κοκτειλ') ||
        lowerTitle.includes('reception')) {
        return 'dinner';
    }
    
    // 🎤 ΟΜΙΛΙΕΣ (μόνο λόγος)
    if (lowerTitle.includes('ομιλία') || lowerTitle.includes('ομιλια') ||
        lowerTitle.includes('speech') || lowerTitle.includes('keynote') || 
        lowerTitle.includes('talk')) {
        return 'speech';
    }
    
    // 📈 ΠΑΡΟΥΣΙΑΣΕΙΣ & POWERPOINT
    if (lowerTitle.includes('παρουσίαση') || lowerTitle.includes('παρουσιαση') ||
        lowerTitle.includes('presentation') || lowerTitle.includes('powerpoint') ||
        lowerTitle.includes('ppt') || lowerTitle.includes('demo') ||
        lowerTitle.includes('showcase')) {
        return 'presentation';
    }
    
    // ❓ ΕΡΩΤΗΣΕΙΣ & ΣΥΖΗΤΗΣΗ
    if (lowerTitle.includes('ερωτήσεις') || lowerTitle.includes('ερωτησεις') || 
        lowerTitle.includes('questions') || lowerTitle.includes('q&a') ||
        lowerTitle.includes('συζήτηση') || lowerTitle.includes('συζητηση') ||
        lowerTitle.includes('discussion')) {
        return 'questions';
    }
    
    // 🗳️ ΨΗΦΟΦΟΡΙΕΣ & ΑΠΟΦΑΣΕΙΣ
    if (lowerTitle.includes('ψηφοφορία') || lowerTitle.includes('ψηφοφορια') ||
        lowerTitle.includes('voting') || lowerTitle.includes('poll') ||
        lowerTitle.includes('απόφαση') || lowerTitle.includes('αποφαση') ||
        lowerTitle.includes('decision')) {
        return 'voting';
    }
    
    // 🧠 ΚΟΥΙΖ & ΠΑΙΧΝΙΔΙΑ
    if (lowerTitle.includes('κουίζ') || lowerTitle.includes('κουιζ') ||
        lowerTitle.includes('quiz') || lowerTitle.includes('παιχνίδι') ||
        lowerTitle.includes('παιχνιδι') || lowerTitle.includes('game') ||
        lowerTitle.includes('competition')) {
        return 'quiz';
    }
    
    // 🎵 ΜΟΥΣΙΚΗ & ENTERTAINMENT
    if (lowerTitle.includes('μουσική') || lowerTitle.includes('μουσικη') ||
        lowerTitle.includes('music') || lowerTitle.includes('entertainment') ||
        lowerTitle.includes('διασκέδαση') || lowerTitle.includes('διασκεδαση') ||
        lowerTitle.includes('show')) {
        return 'music';
    }
    
    // 👥 NETWORKING & ΚΟΙΝΩΝΙΚΟΠΟΙΗΣΗ
    if (lowerTitle.includes('networking') || lowerTitle.includes('μίξη') ||
        lowerTitle.includes('μιξη') || lowerTitle.includes('socializing') ||
        lowerTitle.includes('κοινωνικοποίηση') || lowerTitle.includes('κοινωνικοποιηση') ||
        lowerTitle.includes('mixer')) {
        return 'networking';
    }
    
    // 🏆 ΒΡΑΒΕΙΑ & ΤΕΛΕΤΕΣ
    if (lowerTitle.includes('βραβεία') || lowerTitle.includes('βραβεια') ||
        lowerTitle.includes('awards') || lowerTitle.includes('τελετή') ||
        lowerTitle.includes('τελετη') || lowerTitle.includes('ceremony') ||
        lowerTitle.includes('βράβευση') || lowerTitle.includes('βραβευση')) {
        return 'awards';
    }
    
    // 📊 WORKSHOP & ΕΡΓΑΣΤΗΡΙΑ
    if (lowerTitle.includes('workshop') || lowerTitle.includes('εργαστήριο') ||
        lowerTitle.includes('εργαστηριο') || lowerTitle.includes('hands-on') ||
        lowerTitle.includes('πρακτική') || lowerTitle.includes('πρακτικη') ||
        lowerTitle.includes('training')) {
        return 'workshop';
    }
    
    // 🚀 ΕΝΑΡΞΗ & ΚΑΛΩΣΟΡΙΣΜΑ
    if (lowerTitle.includes('έναρξη') || lowerTitle.includes('εναρξη') ||
        lowerTitle.includes('καλωσόρισμα') || lowerTitle.includes('καλωσορισμα') ||
        lowerTitle.includes('opening') || lowerTitle.includes('welcome') ||
        lowerTitle.includes('kick-off')) {
        return 'opening';
    }
    
    // 🎯 ΚΛΕΙΣΙΜΟ & ΛΗΞΗ
    if (lowerTitle.includes('κλείσιμο') || lowerTitle.includes('κλεισιμο') ||
        lowerTitle.includes('λήξη') || lowerTitle.includes('ληξη') ||
        lowerTitle.includes('closing') || lowerTitle.includes('wrap-up') ||
        lowerTitle.includes('conclusion')) {
        return 'closing';
    }
    
    // ⚠️ ΣΗΜΑΝΤΙΚΟ & ΠΡΟΣΟΧΗ
    if (lowerTitle.includes('σημαντικό') || lowerTitle.includes('σημαντικο') || 
        lowerTitle.includes('important') || lowerTitle.includes('κρίσιμο') ||
        lowerTitle.includes('κρισιμο') || lowerTitle.includes('προσοχή') || 
        lowerTitle.includes('προσοχη') || lowerTitle.includes('urgent')) {
        return 'important';
    }
    
    return null; // Default (πορτοκαλί χρώμα)
}

// Επεκτεταμένη function για εικονίδια markers
function getMarkerIcon(markerType) {
    switch (markerType) {
        case 'break': return '☕';           // Διάλειμμα/Καφές
        case 'lunch': return '🍽️';          // Γεύμα
        case 'dinner': return '🍷';         // Δείπνο/Cocktail
        case 'speech': return '🎤';         // Ομιλία (μόνο λόγος)
        case 'presentation': return '📈';   // Παρουσίαση/PowerPoint
        case 'questions': return '❓';      // Ερωτήσεις/Q&A
        case 'voting': return '🗳️';         // Ψηφοφορία
        case 'quiz': return '🧠';           // Κουίζ/Παιχνίδια
        case 'music': return '🎵';          // Μουσική/Entertainment
        case 'networking': return '👥';     // Networking
        case 'awards': return '🏆';         // Βραβεία/Τελετές
        case 'workshop': return '📊';       // Workshop/Εργαστήρια
        case 'opening': return '🚀';        // Έναρξη/Καλωσόρισμα
        case 'closing': return '🎯';        // Κλείσιμο/Λήξη
        case 'important': return '⚠️';      // Σημαντικό/Προσοχή
        default: return '⌛';               // Default marker
    }
}
       
       // Setup events για κάθε marker
       function setupMarkerEvents(marker, time, title) {
           // Hover για εμφάνιση tooltip
           marker.addEventListener('mouseenter', () => {
               const tooltip = marker.querySelector('.marker-tooltip');
               if (tooltip) {
                   tooltip.classList.add('show');
               }
           });
           
           marker.addEventListener('mouseleave', () => {
               const tooltip = marker.querySelector('.marker-tooltip');
               if (tooltip) {
                   tooltip.classList.remove('show');
               }
           });
          // LEFT MOUSEDOWN για επεξεργασία - ELECTRON CUSTOM DIALOG
    marker.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Μόνο αριστερό κλικ
        
        e.preventDefault();
        e.stopImmediatePropagation();
        //console.log('Left mousedown on marker:', markerData.title);
        
        // Κρύψουμε το tooltip
        const tooltip = marker.querySelector('.marker-tooltip');
        if (tooltip) {
            tooltip.classList.remove('show');
        }
        
        // Custom dialog για Electron
        createEditMarkerDialog(markerData);
        
    }, { capture: true });
           
           // Right-click disabled - διαγραφή μόνο από edit dialog
           marker.addEventListener('contextmenu', (e) => {
               e.preventDefault(); // Disable context menu
           });
           
           // Double-click για επεξεργασία
           // Double-click για επεξεργασία - ELECTRON CUSTOM DIALOG
    marker.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        
        // Κρύψουμε το tooltip
        const tooltip = marker.querySelector('.marker-tooltip');
        if (tooltip) {
            tooltip.classList.remove('show');
        }
        
        // Custom dialog για Electron
        createEditMarkerDialog(markerData);
    });
       }
       
       

       
       
       // Συνάρτηση για προσομοίωση διαφορετικής ώρας (για testing)
       function simulateTime(timeString) {
           const currentTimeLine = document.getElementById('current-time-line');
           const startTimeInput = document.getElementById('event-start-time');
           const endTimeInput = document.getElementById('event-end-time');
           
           if (!currentTimeLine || !startTimeInput || !endTimeInput) return;
           
           const startTime = startTimeInput.value || '09:00';
           const endTime = endTimeInput.value || '17:00';
           
           // Μετατροπή σε λεπτά
           const startMinutes = timeToMinutes(startTime);
           const endMinutes = timeToMinutes(endTime);
           const simulatedMinutes = timeToMinutes(timeString);
           
           // Έλεγχος αν είναι μέσα στο timeframe
           if (simulatedMinutes >= startMinutes && simulatedMinutes <= endMinutes) {
               const totalDuration = endMinutes - startMinutes;
               const elapsed = simulatedMinutes - startMinutes;
               const percentage = (elapsed / totalDuration) * 100;
               
               currentTimeLine.style.left = `${Math.max(0, Math.min(percentage, 100))}%`;
               currentTimeLine.classList.add('show');
               currentTimeLine.title = `Προσομοιωμένη ώρα: ${timeString}`;
               
               console.log(`Simulated time: ${timeString} (${percentage.toFixed(1)}%)`);
           } else {
               currentTimeLine.classList.remove('show');
               console.log(`Simulated time ${timeString} is outside event timeframe`);
           }
       }
       
       
       
 // ΑΦΑΙΡΕΣΗ DOMContentLoaded - Συγχώνευση με κύριο initialization
function initializeTimelineFeatures() {
    if (!window.adminDOMInitialized) {
        console.log('⚠️ TIMELINE: Main DOM not initialized yet, skipping');
        return;
    }
    
    console.log('🎯 TIMELINE: Starting timeline features initialization...');
    
    setTimeout(() => {
        initializeTimelineTooltipDelayed();

        initializeMarkerCreation();
        
        // ΠΡΟΣΘΗΚΗ: Κόκκινη γραμμή στην αρχή της progress bar - ΑΠΛΗ ΕΚΔΟΣΗ
        const progressBar = document.getElementById('timeline-progress');
        if (progressBar && !progressBar.querySelector('.current-time-indicator')) {
            // Κάνε την πράσινη μπάρα ευθεία αριστερά για τέλεια εφαρμογή
            progressBar.style.borderRadius = '0 8px 8px 0';
            
            const redLine = document.createElement('div');
            redLine.className = 'current-time-indicator';
            redLine.style.cssText = `
                position: absolute;
                left: 0;
                top: 0;
                width: 3px;
                height: 100%;
                background-color: #ff4444;
                z-index: 10;
                pointer-events: none;
            `;
            progressBar.appendChild(redLine);
            console.log('✅ TIMELINE: Κόκκινη γραμμή με ευθεία πράσινη άκρη');
        }
        
        // Φόρτωση markers από server
        loadEventMarkersFromServer();
    }, 500);
    
    // Timeline Feed αργότερα
    setTimeout(() => {
        initializeEventTimelineFeed();
        initializeEventDurationCalculator();
        
        // File input listener
        const fileInput = document.getElementById('excel-file-input');
        if (fileInput) {
            fileInput.addEventListener('change', handleExcelFileSelection);
        }
        
        console.log('✅ TIMELINE: All features initialized');
    }, 2000);
}

// Καλείται από το κύριο DOMContentLoaded με καθυστέρηση
setTimeout(() => {
    initializeTimelineFeatures();
}, 1500);

// ΠΡΟΣΘΗΚΗ: Resize event listener για markers - ΒΕΛΤΙΩΜΕΝΗ ΕΚΔΟΣΗ
window.addEventListener('resize', () => {
    clearTimeout(window.markerResizeTimeout);
    window.markerResizeTimeout = setTimeout(() => {
        const timelineBar = document.getElementById('timeline-bar');
        if (timelineBar && eventMarkers && eventMarkers.length > 0) {
            console.log('🔄 TIMELINE: Window resized - repositioning markers');
            
            // ΠΡΟΣΘΗΚΗ: Αναμονή για να σταθεροποιηθεί το layout
            setTimeout(() => {
                renderEventMarkers();
                console.log('✅ TIMELINE: Markers repositioned after layout stabilization');
            }, 100);
        }
    }, 250);
});
// Αρχικοποίηση δημιουργίας markers
function initializeMarkerCreation() {
    const timelineBar = document.getElementById('timeline-bar');
    
    if (!timelineBar) return;
    
    // Αφαίρεση όλων των παλιών event listeners
    const newTimelineBar = timelineBar.cloneNode(true);
    timelineBar.parentNode.replaceChild(newTimelineBar, timelineBar);
    
    let isProcessing = false;
    console.log('Marker creation initialized for Electron');
    
    // Electron-specific fixes
    newTimelineBar.style.webkitUserSelect = 'auto';
    newTimelineBar.style.userSelect = 'auto';
    newTimelineBar.style.webkitAppRegion = 'no-drag';
    newTimelineBar.style.pointerEvents = 'auto';
    
    // Single, clean event listener
// HOLD-TO-CREATE TIMELINE LOGIC
let holdTimer = null;
let isHolding = false;
let holdStarted = false;

newTimelineBar.addEventListener('mousedown', function(e) {
    // Only left mouse button
    if (e.button !== 0) return;
    
    e.preventDefault();
    e.stopImmediatePropagation();
    
    if (isProcessing) {
       // console.log('Already processing - ignored');
        return;
    }
    
    // Αποφυγή δημιουργίας marker αν κάνουμε κλικ σε υπάρχον marker
    if (e.target.classList.contains('event-marker') || e.target.closest('.event-marker')) {
        //console.log('Click on existing marker - ignored');
        return;
    }
    
    //console.log('Mouse down on timeline - starting hold timer');
    
    const rect = newTimelineBar.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const percentage = (x / rect.width) * 100;
    const markerTime = calculateTimeFromPercentage(percentage);
    
    isHolding = true;
    holdStarted = false;
    
    // Start hold timer (1 second)
    holdTimer = setTimeout(() => {
        if (isHolding) {
            holdStarted = true;
            isProcessing = true;
            //console.log(`Hold completed at ${percentage.toFixed(1)}% = ${markerTime}`);
            
            // Visual feedback - optional
            newTimelineBar.style.cursor = 'copy';
            
            // Create marker dialog
            createMarkerDialog(markerTime, percentage);
            
            // Reset processing flag
            setTimeout(() => {
                isProcessing = false;
                newTimelineBar.style.cursor = 'pointer';
            }, 1000);
        }
    }, 1000); // 1 second hold
    
}, { capture: true, passive: false });

// Mouse up event
newTimelineBar.addEventListener('mouseup', function(e) {
    if (e.button !== 0) return;
    
    //console.log('Mouse up - clearing hold timer');
    
    // Clear the hold timer
    if (holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
    }
    
    // If it wasn't a hold, it was just a quick click - ignore on timeline
    if (isHolding && !holdStarted) {
        //console.log('Quick click on timeline - no action (use hold for 1 second to create marker)');
    }
    
    isHolding = false;
    holdStarted = false;
    newTimelineBar.style.cursor = 'pointer';
    
}, { capture: true });

// Mouse leave event (cancel hold if mouse leaves)
newTimelineBar.addEventListener('mouseleave', function(e) {
    //console.log('Mouse left timeline - cancelling hold');
    
    if (holdTimer) {
        clearTimeout(holdTimer);
        holdTimer = null;
    }
    
    isHolding = false;
    holdStarted = false;
    newTimelineBar.style.cursor = 'pointer';
    
}, { capture: true });

// TOUCH SUPPORT για tablets/οθόνες αφής
let touchHoldTimer = null;
let touchIsHolding = false;
let touchHoldStarted = false;

newTimelineBar.addEventListener('touchstart', function(e) {
    // Only single touch
    if (e.touches.length !== 1) return;
    
    e.preventDefault();
    e.stopImmediatePropagation();
    
    if (isProcessing) {
        console.log('Touch: Already processing - ignored');
        return;
    }
    
    // Αποφυγή δημιουργίας marker αν κάνουμε touch σε υπάρχον marker
    if (e.target.classList.contains('event-marker') || e.target.closest('.event-marker')) {
        console.log('Touch on existing marker - ignored');
        return;
    }
    
    //console.log('Touch start on timeline - starting hold timer');
    
    const touch = e.touches[0];
    const rect = newTimelineBar.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const percentage = (x / rect.width) * 100;
    const markerTime = calculateTimeFromPercentage(percentage);
    
    touchIsHolding = true;
    touchHoldStarted = false;
    
    // Start touch hold timer (1 second)
    touchHoldTimer = setTimeout(() => {
        if (touchIsHolding) {
            touchHoldStarted = true;
            isProcessing = true;
            //console.log(`Touch hold completed at ${percentage.toFixed(1)}% = ${markerTime}`);
            
            // Visual feedback
            newTimelineBar.style.cursor = 'copy';
            
            // Haptic feedback (if supported)
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            // Create marker dialog
            createMarkerDialog(markerTime, percentage);
            
            // Reset processing flag
            setTimeout(() => {
                isProcessing = false;
                newTimelineBar.style.cursor = 'pointer';
            }, 1000);
        }
    }, 1000); // 1 second hold
    
}, { capture: true, passive: false });

// Touch end event
newTimelineBar.addEventListener('touchend', function(e) {
    console.log('Touch end - clearing hold timer');
    
    // Clear the touch hold timer
    if (touchHoldTimer) {
        clearTimeout(touchHoldTimer);
        touchHoldTimer = null;
    }
    
    // If it wasn't a hold, it was just a quick tap - ignore
    if (touchIsHolding && !touchHoldStarted) {
        console.log('Quick tap on timeline - no action (use hold for 1 second to create marker)');
    }
    
    touchIsHolding = false;
    touchHoldStarted = false;
    newTimelineBar.style.cursor = 'pointer';
    
}, { capture: true });

// Touch cancel event (when touch is interrupted)
newTimelineBar.addEventListener('touchcancel', function(e) {
    console.log('Touch cancelled - clearing hold timer');
    
    if (touchHoldTimer) {
        clearTimeout(touchHoldTimer);
        touchHoldTimer = null;
    }
    
    touchIsHolding = false;
    touchHoldStarted = false;
    newTimelineBar.style.cursor = 'pointer';
    
}, { capture: true });
    
    //console.log('Clean marker creation initialized');
}

       // ------ SERVER-BASED EVENT MARKERS FUNCTIONS ------

// Δημιουργία νέου marker
async function createEventMarker(percentage, time, title, note = '') {
    const timelineBar = document.getElementById('timeline-bar');
    if (!timelineBar) return null;
    
    try {
        // ΑΛΛΑΓΗ: Αποθηκεύουμε με απόλυτη ώρα, ΟΧΙ percentage
        const response = await fetch('/api/event-markers/add', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                time: time,           // ΚΥΡΙΟ: Η απόλυτη ώρα (π.χ. "13:00")
                title: title,
                note: note,           // ΠΡΟΣΘΗΚΗ: Το πεδίο σημειώσεων
                type: determineMarkerType(title)
                // ΔΕΝ στέλνουμε percentage - θα υπολογιστεί δυναμικά
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('Marker saved to server with absolute time:', data.marker.time);
            return data.marker;
        } else {
            console.error('Failed to save marker to server');
            fixInputsWithPopup('❌ Σφάλμα κατά την αποθήκευση του marker');

        }
    } catch (error) {
        console.error('Error saving marker:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Connection Error' : 'Σφάλμα Σύνδεσης';
        const message = currentLang === 'en' ? 'Server connection error' : 'Σφάλμα σύνδεσης με τον server';
        showCustomAlert(title, message);
    }
    
    return null;
}

// Διαγραφή marker
async function deleteEventMarker(markerId, markerTitle) {
    const shouldDelete = await customConfirm(
        'Διαγραφή Event Marker',
        `Θέλετε να διαγράψετε το event "${markerTitle}";`,
        'Διαγραφή',
        'Ακύρωση'
    );
    
    if (!shouldDelete) {
        return;
    }
    
    try {
        const response = await fetch(`/api/event-markers/${markerId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('Marker deleted from server:', data.deleted.title);
            
            // 🔥 Event-driven save: Marker deleted
            triggerEventDrivenSave('event marker deleted');
            
            // Το renderEventMarkers θα καλεστεί αυτόματα από το WebSocket event
        } else {
            console.error('Failed to delete marker from server');
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Error deleting marker' : 'Σφάλμα κατά τη διαγραφή του marker';
            await showCustomAlert(title, message);
        }
    } catch (error) {
        console.error('Error deleting marker:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Connection Error' : 'Σφάλμα Σύνδεσης';
        const message = currentLang === 'en' ? 'Server connection error' : 'Σφάλμα σύνδεσης με τον server';
        showCustomAlert(title, message);
    }
}

// Επεξεργασία marker
async function editEventMarker(markerId, oldTitle, newTitle) {
    try {
        const response = await fetch('/api/event-markers/edit', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                id: markerId,
                newTitle: newTitle
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('Marker updated on server:', data.marker.title);
            // Το renderEventMarkers θα καλεστεί αυτόματα από το WebSocket event
        } else {
            console.error('Failed to update marker on server');
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
            const message = currentLang === 'en' ? 'Error updating marker' : 'Σφάλμα κατά την ενημέρωση του marker';
            showCustomAlert(title, message);
        }
    } catch (error) {
        console.error('Error updating marker:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Connection Error' : 'Σφάλμα Σύνδεσης';
        const message = currentLang === 'en' ? 'Server connection error' : 'Σφάλμα σύνδεσης με τον server';
        showCustomAlert(title, message);
    }
}

// Φόρτωση markers από server
async function loadEventMarkersFromServer() {
    try {
        const response = await fetch('/api/event-markers');
        if (response.ok) {
            const data = await response.json();
            eventMarkers = data.markers || [];
            renderEventMarkers();
            console.log('Loaded event markers from server:', eventMarkers.length);
        }
    } catch (error) {
        console.error('Error loading event markers:', error);
    }
}

// Render markers στο DOM
function renderEventMarkers() {
    const timelineBar = document.getElementById('timeline-bar');
    if (!timelineBar) return;
    
    console.log('=== RENDERING EVENT MARKERS ===');
    
    // Καθαρισμός υπαρχόντων markers
    const existingMarkers = timelineBar.querySelectorAll('.event-marker');
    existingMarkers.forEach(marker => marker.remove());
    
    // Έλεγχος αν υπάρχουν markers
    if (!eventMarkers || eventMarkers.length === 0) {
        console.log('No markers to render');
        return;
    }
    
    // Λήψη τρέχουσας timeline
    const startTime = document.getElementById('timeline-start-display').textContent || '09:00';
    const endTime = document.getElementById('timeline-end-display').textContent || '17:00';
    
    console.log(`Current timeline: ${startTime} - ${endTime}`);
    
    // Δημιουργία νέων markers με υπολογισμό θέσης βάσει απόλυτης ώρας
    eventMarkers.forEach((markerData, index) => {
        console.log(`Rendering marker ${index + 1}: "${markerData.title}" at ${markerData.time}`);
        createMarkerElement(markerData);
    });
    
    console.log(`=== RENDERED ${eventMarkers.length} MARKERS ===`);
}

// Δημιουργία marker element στο DOM
function createMarkerElement(markerData) {
    const timelineBar = document.getElementById('timeline-bar');
    if (!timelineBar) return;
    
    // ΝΕΟΣ ΚΩΔΙΚΑΣ: Υπολογισμός percentage από απόλυτη ώρα
    const startTime = document.getElementById('timeline-start-display').textContent || '09:00';
    const endTime = document.getElementById('timeline-end-display').textContent || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const markerMinutes = timeToMinutes(markerData.time);
    
    // Υπολογισμός percentage βάσει της τρέχουσας timeline
    const totalDuration = endMinutes - startMinutes;
    const elapsedFromStart = markerMinutes - startMinutes;
    const calculatedPercentage = (elapsedFromStart / totalDuration) * 100;
    
    console.log(`Marker "${markerData.title}" at ${markerData.time}: ${calculatedPercentage.toFixed(1)}%`);
    
    // Δημιουργία marker element
    const marker = document.createElement('div');
    marker.className = 'event-marker';
    // SNAP TO MINUTE positioning
const snappedTime = markerData.time; // Ήδη snapped από server
const exactPercentage = calculatePercentageFromTime(snappedTime);
const adjustedPercentage = exactPercentage; // ΧΩΡΙΣ OFFSET πια
marker.style.left = `${Math.max(0, Math.min(adjustedPercentage, 100))}%`;
    marker.title = `${markerData.title} - ${markerData.time}`;
    marker.dataset.markerId = markerData.id;
    
    // Προσθήκη εικονιδίου μέσα στο marker
    const markerIcon = getMarkerIcon(markerData.type);
    marker.textContent = markerIcon;
    
    // Προσθήκη τύπου αν υπάρχει (για χρώμα)
    if (markerData.type) {
        marker.classList.add(markerData.type);
    }
    // Προσθήκη CSS class βάσει source
if (markerData.source) {
    if (markerData.source === 'excel') {
        marker.classList.add('marker-excel');
    } else if (markerData.source === 'google_sheets') {
        marker.classList.add('marker-google');
    }
    // Manual markers δεν χρειάζονται επιπλέον class (έχουν ήδη λευκό περίγραμμα)
}
    
    // Δημιουργία tooltip
    const markerTooltip = document.createElement('div');
    markerTooltip.className = 'marker-tooltip';
    const tooltipIcon = getMarkerIcon(markerData.type);
    markerTooltip.innerHTML = `${markerData.time} ${tooltipIcon} ${markerData.title}${markerData.note ? '<br><small>' + markerData.note + '</small>' : ''}`;
    marker.appendChild(markerTooltip);
    
    // Setup events
    setupMarkerEvents(marker, markerData);
    
    // Προσθήκη στη timeline
    timelineBar.appendChild(marker);
    
    return marker;
}

// Setup events για κάθε marker
function setupMarkerEvents(marker, markerData) {
    // Hover για εμφάνιση tooltip
    marker.addEventListener('mouseenter', () => {
        const tooltip = marker.querySelector('.marker-tooltip');
        if (tooltip) {
            tooltip.classList.add('show');
        }
    });
    
    marker.addEventListener('mouseleave', () => {
        const tooltip = marker.querySelector('.marker-tooltip');
        if (tooltip) {
            tooltip.classList.remove('show');
        }
    });
    
    // Right-click disabled - διαγραφή μόνο από edit dialog
    marker.addEventListener('contextmenu', (e) => {
        e.preventDefault(); // Disable context menu
    });
    
    // Double-click για επεξεργασία
   // Double-click για επεξεργασία - ELECTRON CUSTOM DIALOG
    marker.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        
        // Κρύψουμε το tooltip
        const tooltip = marker.querySelector('.marker-tooltip');
        if (tooltip) {
            tooltip.classList.remove('show');
        }
        
        // Custom dialog για Electron
        createEditMarkerDialog(markerData);
    });
}


function applyTimelineSettings() {
    const startTime = document.getElementById('event-start-time-settings').value || '09:00';
    const endTime = document.getElementById('event-end-time-settings').value || '17:00';
    
    console.log(`=== APPLY TIMELINE SETTINGS ===`);
    console.log(`New timeline: ${startTime} - ${endTime}`);
    
    // Ενημέρωση των display fields
    document.getElementById('timeline-start-display').textContent = startTime;
    document.getElementById('timeline-end-display').textContent = endTime;
    
    // Άμεση ενημέρωση της progress bar
    updateTimelineProgress();
    updateEventDuration();
    
    // ΝΕΙΑ ΛΟΓΙΚΗ: Ενημέρωση server-based markers
    const newStartMinutes = timeToMinutes(startTime);
    const newEndMinutes = timeToMinutes(endTime);
    const newTotalDuration = newEndMinutes - newStartMinutes;
    
    console.log(`New timeline duration: ${newTotalDuration} minutes (${startTime} - ${endTime})`);
    
    // Ενημέρωση eventMarkers array
    if (eventMarkers && eventMarkers.length > 0) {
        console.log(`Updating ${eventMarkers.length} server markers`);
        
        eventMarkers.forEach((marker, index) => {
            const absoluteTime = marker.time; // π.χ. "11:00"
            const absoluteMinutes = timeToMinutes(absoluteTime);
            
            console.log(`Marker ${index + 1}: "${marker.title}" at ${absoluteTime}`);
            
            // Έλεγχος αν η ώρα είναι μέσα στη νέα timeline
            if (absoluteMinutes < newStartMinutes || absoluteMinutes > newEndMinutes) {
                console.log(`  ⚠️  Time ${absoluteTime} is OUTSIDE new timeline`);
                // Δεν αλλάζουμε το marker - απλά θα φαίνεται εκτός
            } else {
                // Υπολογίζουμε το ΝΕΟ ποσοστό
                const elapsedFromNewStart = absoluteMinutes - newStartMinutes;
                const newPercentage = (elapsedFromNewStart / newTotalDuration) * 100;
                
                // Ενημέρωση του marker στο array
                marker.percentage = Math.max(0, Math.min(newPercentage, 100));
                
                console.log(`  ✅ New position: ${marker.percentage.toFixed(1)}%`);
            }
        });
        
        // Ξανα-render όλων των markers με τις νέες θέσεις
        renderEventMarkers();
        console.log(`✅ Markers re-rendered with new positions`);
    }
    
    // Ενημέρωση Event Timeline Feed
    setTimeout(() => {
        updateEventTimelineFeed();
    }, 500);
    
    // Αποστολή στον server
    if (isConnected && socket) {
        socket.emit('settingsUpdate', {
            timeline: {
                startTime: startTime,
                endTime: endTime
            }
        });
        console.log('Timeline settings sent to server');
    }
    
    saveSettings();
    // ΠΡΟΣΘΗΚΗ: Αυτόματη ενημέρωση markers με νέες θέσεις
console.log('Auto-updating marker positions after timeline change...');
setTimeout(() => {
    renderEventMarkers(); // Αυτόματο re-render με νέες θέσεις
    console.log('Marker positions updated automatically');
}, 200);

// ΠΡΟΣΘΗΚΗ: Εφαρμογή display settings όταν πατιέται "Εφαρμογή"
applyDisplaySettings();
console.log('Display settings also applied');
// Timeline sync με άλλα admin panels
if (socket && socket.connected) {
    socket.emit('timelineSync', {
        startTime: startTime,
        endTime: endTime
    });
    console.log('📅 Timeline sync sent to other admin panels');
}

    // 🔥 Event-driven save: Timeline settings change
    triggerEventDrivenSave('timeline settings updated');
    
    console.log(`=== TIMELINE SETTINGS APPLIED ===`);
}

function updateTimelineProgress() {
    const now = new Date();
    const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
    
    const startTime = document.getElementById('timeline-start-display').textContent || '09:00';
    const endTime = document.getElementById('timeline-end-display').textContent || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const currentMinutes = timeToMinutes(currentTime);
    
    console.log(`Timeline: ${startTime}-${endTime}, Current: ${currentTime}`);
    
    const timelineProgress = document.getElementById('timeline-progress');
    if (timelineProgress) {
        let width;
        
        if (currentMinutes < startMinutes) {
            // Πριν την έναρξη - γεμάτη πράσινη
            width = 100;
            console.log('Before start - 100% green');
        } else if (currentMinutes >= endMinutes) {
            // Στη λήξη ή μετά - μικροσκοπική μπάρα (1%)
            width = 1;
            console.log('At/after end - 1% remaining');
        } else {
            // Κατά τη διάρκεια - η μπάρα μικραίνει από αριστερά προς δεξιά
            const totalDuration = endMinutes - startMinutes;
            const elapsed = currentMinutes - startMinutes;
            const elapsedPercentage = (elapsed / totalDuration) * 100;
            width = elapsedPercentage; // Χρόνος που έχει περάσει
            width = Math.max(width, 1); // Τουλάχιστον 1% για να φαίνεται
            
            console.log(`During event: ${elapsedPercentage.toFixed(1)}% elapsed, ${width.toFixed(1)}% remaining`);
        }
        
        timelineProgress.style.width = `${width}%`;
        console.log(`Timeline width set to: ${width}%`);
    }
}

// Ενημέρωση κάθε λεπτό
// ONLY ONE timeline progress update interval
if (!window.timelineProgressInterval) {
    window.timelineProgressInterval = setInterval(() => {
        if (document.getElementById('timeline-progress')) {
            updateTimelineProgress();
        } else {
            clearInterval(window.timelineProgressInterval);
            window.timelineProgressInterval = null;
        }
    }, 60000);
    console.log('Timeline progress interval started');
}
// ------ EVENT DURATION CALCULATOR ------
// Υπολογισμός και εμφάνιση διάρκειας event
function updateEventDuration() {
    const startTime = document.getElementById('event-start-time-settings').value || '09:00';
    const endTime = document.getElementById('event-end-time-settings').value || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const durationMinutes = endMinutes - startMinutes;
    
    if (durationMinutes <= 0) {
        const durationDisplay = document.getElementById('event-duration-display');
        if (durationDisplay) {
            durationDisplay.textContent = "⚠️ Λάθος ώρες - Η λήξη πρέπει να είναι μετά την έναρξη";
            durationDisplay.style.color = "#e74c3c";
        }
        return;
    }
    
    const hours = Math.floor(durationMinutes / 60);
    const minutes = durationMinutes % 60;
    
    const durationDisplay = document.getElementById('event-duration-display');
    if (durationDisplay) {
        durationDisplay.style.color = "#3498db"; // Επαναφορά χρώματος
        
        if (hours > 0 && minutes > 0) {
            durationDisplay.textContent = `${window.electronAPI?.translate('timeline.durationPrefix', '⏱️ Διάρκεια:')} ${hours} ${window.electronAPI?.translate('timeline.hours', 'ώρες')} και ${minutes} ${window.electronAPI?.translate('timeline.minutes', 'λεπτά')}`;
        } else if (hours > 0) {
            durationDisplay.textContent = `${window.electronAPI?.translate('timeline.durationPrefix', '⏱️ Διάρκεια:')} ${hours} ${window.electronAPI?.translate('timeline.hours', 'ώρες')}`;
        } else {
            durationDisplay.textContent = `${window.electronAPI?.translate('timeline.durationPrefix', '⏱️ Διάρκεια:')} ${minutes} ${window.electronAPI?.translate('timeline.minutes', 'λεπτά')}`;
        }
    }
}

// Event listeners για real-time ενημέρωση διάρκειας
function initializeEventDurationCalculator() {
    const startInput = document.getElementById('event-start-time-settings');
    const endInput = document.getElementById('event-end-time-settings');
    
    if (startInput && endInput) {
        startInput.addEventListener('change', updateEventDuration);
        endInput.addEventListener('change', updateEventDuration);
        startInput.addEventListener('input', updateEventDuration);
        endInput.addEventListener('input', updateEventDuration);
        
        updateEventDuration(); // Αρχική ενημέρωση
        console.log('Event duration calculator initialized');
    } else {
        console.log('Timeline inputs not found for duration calculator');
    }
}


// Επανυπολογισμός ώρας markers όταν αλλάζει η timeline
// Επανυπολογισμός ώρας ΚΑΙ θέσης markers όταν αλλάζει η timeline
// Απλή επανυπολογισμός χωρίς server sync (για να δουλέψει αμέσως)
function recalculateMarkersTime() {
    const startTime = document.getElementById('timeline-start-display').textContent || '09:00';
    const endTime = document.getElementById('timeline-end-display').textContent || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const totalDuration = endMinutes - startMinutes;
    
    console.log(`Recalculating markers for timeline: ${startTime} - ${endTime}`);
    
    // Ενημέρωση των markers στη σελίδα μόνο
    const markers = document.querySelectorAll('.event-marker');
    
    markers.forEach(marker => {
        // Παίρνουμε το ποσοστό από το style.left
        const leftPercentStr = marker.style.left;
        const leftPercent = parseFloat(leftPercentStr.replace('%', '')) || 0;
        
        // Υπολογίζουμε τη νέα ώρα βάσει του ποσοστού
        const markerMinutes = startMinutes + (totalDuration * leftPercent / 100);
        const newTime = minutesToTime(Math.round(markerMinutes));
        
        // Ενημερώνουμε το tooltip
        const tooltip = marker.querySelector('.marker-tooltip');
        if (tooltip) {
            const currentHTML = tooltip.innerHTML;
            // Αντικαταστούμε την παλιά ώρα με τη νέα
            const updatedHTML = currentHTML.replace(/\d{1,2}:\d{2}/, newTime);
            tooltip.innerHTML = updatedHTML;
        }
        
        // Ενημερώνουμε το title του marker
        const currentTitle = marker.title;
        const updatedTitle = currentTitle.replace(/\d{1,2}:\d{2}/, newTime);
        marker.title = updatedTitle;
        
        console.log(`Marker at ${leftPercent.toFixed(1)}% updated to ${newTime}`);
    });
    
    console.log('Markers time updated (local only)');
}

// ------ AUTOMATIC AUTOSAVE EVERY 5 MINUTES ------
let autoSaveInterval = null;
let autoSaveStartTime = null;

function startAutoSave() {
    // Καθαρισμός προηγούμενου interval αν υπάρχει
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    autoSaveStartTime = new Date();
    console.log('🔄 AutoSave: System started at', autoSaveStartTime.toLocaleTimeString('el-GR'));
    console.log('🔄 AutoSave: Will save every 30 seconds automatically');
    
   // AutoSave κάθε 30 δευτερόλεπτα (30,000 milliseconds)
autoSaveInterval = setInterval(() => {
    try {
        performSilentAutoSave(); // ΑΛΛΑΓΗ: χρήση silent αντί για full
        const now = new Date();
        console.log('✅ Silent AutoSave: Automatic save completed at', now.toLocaleTimeString('el-GR'));
        
        const nextSave = new Date(now.getTime() + 30000);
        console.log('⏰ Silent AutoSave: Next save at', nextSave.toLocaleTimeString('el-GR'));
        
    } catch (error) {
        console.error('❌ Silent AutoSave: Failed:', error);
    }
}, 30000);
}

// ΑΦΑΙΡΕΣΗ AutoSave DOMContentLoaded - Συγχώνευση με κύριο initialization  
function initializeAutoSaveDelayed() {
    if (!window.adminDOMInitialized) {
        console.log('⚠️ AUTOSAVE: Main DOM not initialized yet, skipping');
        return;
    }
    
    console.log('💾 AUTO-SAVE: Session management ready');
    
    // vMix Style: Check for saved data but DON'T auto-restore
    setTimeout(async () => {
        try {
            console.log('🔍 Checking for saved data...');
            
            // Try to check if save file exists (Electron environment)
            if (window.electronAPI && window.electronAPI.loadAutoBackupFile) {
                const fileResult = await window.electronAPI.loadAutoBackupFile();
                
                if (fileResult.success && fileResult.data) {
                    const savedSettings = fileResult.data;
                    
                    // Check if there's meaningful data to restore
                    const hasMessages = savedSettings.savedMessages?.messages?.length > 0;
                    const hasMarkers = savedSettings.eventMarkers?.markers?.length > 0; 
                    const hasCustomSettings = savedSettings.display?.title !== 'TimeCast™ Pro Conference Timer';
                    
                    if (hasMessages || hasMarkers || hasCustomSettings) {
                        console.log('📋 vMix Style: Saved data available - use "Restore" button to load');
                        console.log(`   └─ ${hasMessages ? savedSettings.savedMessages.messages.length + ' messages' : '0 messages'}`);
                        console.log(`   └─ ${hasMarkers ? savedSettings.eventMarkers.markers.length + ' markers' : '0 markers'}`);
                        console.log(`   └─ Save time: ${fileResult.timestamp || 'Unknown'}`);
                    } else {
                        console.log('ℹ️ No meaningful saved data found');
                    }
                } else {
                    console.log('ℹ️ No save file found - starting fresh session');
                }
            } else {
                console.log('ℹ️ Browser mode - use localStorage backup if available');
            }
        } catch (error) {
            console.error('❌ Error checking for saved data:', error);
        }
    }, 2000); // 2 δευτερόλεπτα delay για να φορτώσει το UI
}

// Καλείται από το κύριο DOMContentLoaded
setTimeout(() => {
    initializeAutoSaveDelayed();
}, 3000);

// Cleanup όταν κλείνει η σελίδα - ΜΟΝΟ silent save
window.addEventListener('beforeunload', () => {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        console.log('🛑 AutoSave: Interval stopped (page closing)');
    }
    
    try {
        performSilentAutoSave(); // ΑΛΛΑΓΗ: silent αντί για full
        console.log('💾 Silent AutoSave: Final save before page close (no file)');
    } catch (error) {
        console.error('❌ Silent AutoSave: Final save failed:', error);
    }
});

// Εμφάνιση κατάστασης AutoSave (προαιρετικό)
function showAutoSaveStatus() {
    if (autoSaveStartTime) {
        const now = new Date();
        const elapsed = Math.floor((now - autoSaveStartTime) / 1000 / 60); // λεπτά
        console.log(`📊 AutoSave: Running for ${elapsed} minutes`);
    }
}

// Status check κάθε 10 λεπτά (προαιρετικό)
setInterval(() => {
    if (autoSaveInterval) {
        showAutoSaveStatus();
    }
}, 600000); // 10 λεπτά

// ========== LIVE EVENT TIMELINE FEED FUNCTIONS ==========

let currentEventIndex = -1;
let eventTimelineInterval = null;

// Εκκίνηση Event Timeline Feed
function initializeEventTimelineFeed() {
    console.log('Initializing Event Timeline Feed...');
    
    // Ενημέρωση κάθε λεπτό
    eventTimelineInterval = setInterval(updateEventTimelineFeed, 60000);
    
    // Αρχική ενημέρωση
    updateEventTimelineFeed();
    
    console.log('Event Timeline Feed initialized');
}

// Κύρια συνάρτηση ενημέρωσης Event Feed
// Κύρια συνάρτηση ενημέρωσης Event Feed - ΑΠΛΗ ΜΟΡΦΗ
function updateEventTimelineFeed() {
    const now = new Date();
    const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
    const currentMinutes = timeToMinutes(currentTime);
    
    console.log(`Updating Event Feed for current time: ${currentTime}`);
    
    if (!eventMarkers || eventMarkers.length === 0) {
        showEmptyEventFeed();
        return;
    }
    
    // Ταξινόμηση markers κατά ώρα
    const sortedMarkers = [...eventMarkers].sort((a, b) => {
        const timeA = timeToMinutes(a.time);
        const timeB = timeToMinutes(b.time);
        return timeA - timeB;
    });
    
    // Εύρεση τρέχοντος, επόμενου και μεθεπόμενου event
    const { current, next, afterNext } = findEventStates(sortedMarkers, currentMinutes);
    
    // Ενημέρωση UI
    updateCurrentEvent(current);
    updateNextEvent(next);
    updateAfterNextEvent(afterNext);
    
    // Απλή ενημέρωση progress - ΜΗ καλούμε updateTimelineProgress
    // Αφήνουμε το header timeline να κάνει τη δουλειά του
    
    console.log('Event Feed updated:', { current: current?.title, next: next?.title, afterNext: afterNext?.title });
}
// Εύρεση κατάστασης events
function findEventStates(sortedMarkers, currentMinutes) {
    let current = null;
    let next = null;
    let afterNext = null;
    
    // Εύρεση τρέχοντος event (το τελευταίο που έχει περάσει)
    for (let i = 0; i < sortedMarkers.length; i++) {
        const markerMinutes = timeToMinutes(sortedMarkers[i].time);
        if (markerMinutes <= currentMinutes) {
            current = sortedMarkers[i];
            currentEventIndex = i;
        } else {
            break;
        }
    }
    
    // Εύρεση επόμενου event
    for (let i = 0; i < sortedMarkers.length; i++) {
        const markerMinutes = timeToMinutes(sortedMarkers[i].time);
        if (markerMinutes > currentMinutes) {
            next = sortedMarkers[i];
            // Εύρεση μεθεπόμενου
            if (i + 1 < sortedMarkers.length) {
                afterNext = sortedMarkers[i + 1];
            }
            break;
        }
    }
    
    return { current, next, afterNext };
}

// Ενημέρωση τρέχοντος event
function updateCurrentEvent(event) {
    const titleElement = document.getElementById('current-event-title');
    const timeElement = document.getElementById('current-event-time');
    
    if (titleElement && timeElement) {
        if (event) {
            titleElement.textContent = event.title;
            const sourceInfo = getSourceShortLabel(event.source);
            timeElement.innerHTML = `${event.time} <em>${sourceInfo}</em>`;
            titleElement.style.color = '#ffffff';
        } else {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            titleElement.textContent = currentLang === 'en' ? 'Waiting to start...' : 'Αναμονή εκκίνησης...';
            timeElement.textContent = '--:--';
            titleElement.style.color = '#95a5a6';
        }
    }
}

// Ενημέρωση επόμενου event
function updateNextEvent(event) {
    const titleElement = document.getElementById('next-event-title');
    const timeElement = document.getElementById('next-event-time');
    
    if (titleElement && timeElement) {
        if (event) {
            titleElement.textContent = event.title;
            const sourceInfo = getSourceShortLabel(event.source);
            timeElement.innerHTML = `${event.time} <em>${sourceInfo}</em>`;
            titleElement.style.color = '#ffffff';
        } else {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            titleElement.textContent = currentLang === 'en' ? 'No next event' : 'Δεν υπάρχει επόμενο';
            timeElement.textContent = '--:--';
            titleElement.style.color = '#95a5a6';
        }
    }
}

// Ενημέρωση μεθεπόμενου event
function updateAfterNextEvent(event) {
    const titleElement = document.getElementById('after-next-event-title');
    const timeElement = document.getElementById('after-next-event-time');
    
    if (titleElement && timeElement) {
        if (event) {
            titleElement.textContent = event.title;
            const sourceInfo = getSourceShortLabel(event.source);
            timeElement.innerHTML = `${event.time} <em>${sourceInfo}</em>`;
            titleElement.style.color = '#ffffff';
        } else {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            titleElement.textContent = currentLang === 'en' ? 'No event after' : 'Δεν υπάρχει μεθεπόμενο';
            timeElement.textContent = '--:--';
            titleElement.style.color = '#95a5a6';
        }
    }
}

// Ενημέρωση countdown για επόμενο event
function updateEventCountdown(nextEvent, currentMinutes) {
    const countdownElement = document.getElementById('countdown-timer');
    
    if (nextEvent) {
        const nextEventMinutes = timeToMinutes(nextEvent.time);
        const minutesUntilNext = nextEventMinutes - currentMinutes;
        
        if (minutesUntilNext > 0) {
            const hours = Math.floor(minutesUntilNext / 60);
            const minutes = minutesUntilNext % 60;
            
            if (hours > 0) {
                countdownElement.textContent = `${hours}:${String(minutes).padStart(2, '0')}`;
            } else {
                countdownElement.textContent = `${minutes} λεπτά`;
            }
            
            // Χρωματικός κώδικας countdown
            if (minutesUntilNext <= 5) {
                countdownElement.style.color = '#e74c3c'; // Κόκκινο
            } else if (minutesUntilNext <= 15) {
                countdownElement.style.color = '#f39c12'; // Πορτοκαλί
            } else {
                countdownElement.style.color = '#3498db'; // Μπλε
            }
        } else {
            countdownElement.textContent = 'Τώρα!';
            countdownElement.style.color = '#e74c3c';
        }
    } else {
        countdownElement.textContent = '--:--';
        countdownElement.style.color = '#95a5a6';
    }
}

// Ενημέρωση timeline progress
// Ενημέρωση timeline progress - ΑΔΕΙΑΖΕΙ καθώς περνάει ο χρόνος
function updateTimelineProgress() {
    const now = new Date();
    const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
    
    const startTime = document.getElementById('timeline-start-display').textContent || '09:00';
    const endTime = document.getElementById('timeline-end-display').textContent || '17:00';
    
    const startMinutes = timeToMinutes(startTime);
    const endMinutes = timeToMinutes(endTime);
    const currentMinutes = timeToMinutes(currentTime);

    const timelineProgress = document.getElementById('timeline-progress');
    if (timelineProgress) {
        let width;

        if (currentMinutes < startMinutes) {
            // Πριν την έναρξη - γεμάτη πράσινη
            width = 100;
        } else if (currentMinutes >= endMinutes) {
            // Στη λήξη ή μετά - τουλάχιστον 1% για να φαίνεται
            width = 1;
        } else {
            // Κατά τη διάρκεια - αδειάζει από αριστερά προς δεξιά
            const totalDuration = endMinutes - startMinutes;
            const elapsed = currentMinutes - startMinutes;
            const elapsedPercentage = (elapsed / totalDuration) * 100;
            width = 100 - elapsedPercentage; // ΕΝΑΠΟΜΕΙΝΑΝ χρόνος
            width = Math.max(width, 1); // Τουλάχιστον 1% για να φαίνεται
        }

        timelineProgress.style.width = `${width}%`;
    }
}

// Εμφάνιση κενού feed
function showEmptyEventFeed() {
    updateCurrentEvent(null);
    updateNextEvent(null);
    updateAfterNextEvent(null);
    
    const countdownElement = document.getElementById('countdown-timer');
    if (countdownElement) {
        countdownElement.textContent = '--:--';
        countdownElement.style.color = '#95a5a6';
    }
    
    const progressFillElement = document.getElementById('timeline-progress-fill');
    if (progressFillElement) {
        progressFillElement.style.width = '0%';
    }
}

// Συνάρτηση για manual refresh του feed
function refreshEventFeed() {
    console.log('Manual refresh of Event Timeline Feed');
    updateEventTimelineFeed();
}



// Cleanup όταν κλείνει η σελίδα
window.addEventListener('beforeunload', () => {
    if (eventTimelineInterval) {
        clearInterval(eventTimelineInterval);
    }
});

// Hook στις event markers updates
const originalRenderEventMarkers = renderEventMarkers;
renderEventMarkers = function() {
    originalRenderEventMarkers.call(this);
    // Ενημέρωση του feed όταν αλλάζουν τα markers
    setTimeout(updateEventTimelineFeed, 500);
};
// Αυτόματη προσαρμογή μεγέθους τίτλου βάσει μήκους
// Αυτόματη προσαρμογή μεγέθους τίτλου βάσει μήκους
function adjustTitleFontSize(titleText) {
    const titlePreview = document.getElementById('title-preview');
    
    // ΠΡΟΣΘΗΚΗ: Έλεγχος αν υπάρχει το element
    if (!titlePreview) {
        console.warn('adjustTitleFontSize: title-preview element not found');
        return;
    }
    
    if (!titleText || typeof titleText !== 'string') {
        console.warn('adjustTitleFontSize: invalid titleText provided:', titleText);
        return;
    }
    
    const textLength = titleText.length;
    let fontSize;
    
    if (textLength <= 20) {
        fontSize = 3.5; // Ακόμα μεγαλύτερο μέγεθος για μικρούς τίτλους
    } else if (textLength <= 40) {
        fontSize = 2.5; // Ακόμα μεγαλύτερο για μεσαίους
    } else if (textLength <= 60) {
        fontSize = 1.8; // Ακόμα μεγαλύτερο για μεγάλους
    } else if (textLength <= 80) {
        fontSize = 1.3; // Ακόμα μεγαλύτερο για πολύ μεγάλους
    } else {
        fontSize = 0.9; // Ακόμα μεγαλύτερο ελάχιστο για τεράστιους τίτλους
    }
    
    try {
        titlePreview.style.setProperty('font-size', fontSize + 'vh', 'important');
        console.log(`Title font size adjusted: ${textLength} chars → ${fontSize}vh`);
    } catch (error) {
        console.error('Error setting title font size:', error);
    }
    
}
// Ασφαλής wrapper για DOM operations
function safeUpdateElement(elementId, property, value) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.warn(`Element ${elementId} not found`);
        return false;
    }
    
    try {
        if (property === 'textContent') {
            element.textContent = value;
        } else if (property === 'value') {
            element.value = value;
        } else if (property === 'checked') {
            element.checked = value;
        } else if (property.startsWith('style.')) {
            const styleProp = property.replace('style.', '');
            element.style[styleProp] = value;
        }
        return true;
    } catch (error) {
        console.error(`Error updating ${elementId}.${property}:`, error);
        return false;
    }
}

// Ασφαλής εναλλακτική της adjustTitleFontSize
function safeTitleUpdate(titleText) {
    if (!titleText || typeof titleText !== 'string') {
        titleText = 'TimeCast® Pro Conference Timer';
    }
    
    // Ενημέρωση input
    safeUpdateElement('title-input', 'value', titleText);
    
    // Ενημέρωση preview
    safeUpdateElement('title-preview', 'textContent', titleText);
    
    // Ενημέρωση document title
    try {
        document.title = "Admin - " + titleText;
    } catch (error) {
        console.error('Error setting document title:', error);
    }
    
    console.log(`Safe title update: "${titleText}"`);
    
    // 🔥 Event-driven save: Title change
    triggerEventDrivenSave('title updated');
}
let hdmiTimerOpen = false;

// Helper function για safe i18n translations
function safeTranslate(key, fallback) {
    return (typeof i18next !== 'undefined' && i18next.t) ? i18next.t(key) : fallback;
}

async function toggleHDMITimer() {
    const btn = document.getElementById('hdmi-timer-btn');
    const btnSpan = btn.querySelector('span[data-i18n="qr.openTimerHDMI"]');
    const currentLang = localStorage.getItem('preferredLanguage') || 'el';

    
    if (isHdmiToggling) {
        console.log('HDMI Toggle: Already processing - ignored');
        return;
    }
    isHdmiToggling = true;
    
    // Έλεγχος αν τρέχει σε Electron
    if (!window.electronAPI) {
        // Fallback για browser mode
        const electronOnlyTitle = safeTranslate('admin:hdmiElectronOnly', 'HDMI μόνο σε Electron');
        const electronOnlyMsg = safeTranslate('admin:hdmiElectronOnlyMsg', 'Η λειτουργία HDMI δουλεύει μόνο στην Electron εφαρμογή!');
        customAlert(electronOnlyTitle, electronOnlyMsg, 'warning');
        isHdmiToggling = false;
        return;
    }
    
    btn.disabled = true;
    const originalText = btnSpan.textContent;
    const loadingText = safeTranslate('admin:companion.loadingText', '⏳ Φόρτωση...');
    btnSpan.textContent = loadingText;
    
    try {
        if (!hdmiTimerOpen) {
            // Έλεγχος διαθέσιμων οθονών
            const displayInfo = await window.electronAPI.getDisplaysCount();
            console.log('Display info:', displayInfo);
            
            if (displayInfo.count < 2) {
                await window.electronAPI.showHdmiDisplayWarning();
                return;
            }
            
            // Άνοιγμα timer στη δεύτερη οθόνη
            console.log('Opening timer on second screen...');
            const result = await window.electronAPI.openTimerWindow();
            console.log('Open result:', result);
            
            if (result.success) {
                hdmiTimerOpen = true;
                const closeText = safeTranslate('qr.closeTimerHDMI', '📺 Κλείσιμο Timer HDMI');
                btnSpan.textContent = closeText;
                btn.style.backgroundColor = '#e74c3c';
                
                // Εμφάνιση ειδοποίησης επιτυχίας
                const openTitle = safeTranslate('admin:hdmiTimerOpened', 'Timer HDMI Ανοίχτηκε');
                const openMsg = safeTranslate('admin:hdmiTimerOpenedMsg', 'Timer ανοίχτηκε στη δεύτερη οθόνη!');
                customAlert(openTitle, openMsg, 'success');
                console.log('Timer opened successfully on second screen');
            } else {
                const failMsg = safeTranslate('admin:hdmiFailedOpen', 'Αποτυχία ανοίγματος timer');
                throw new Error(result.message || failMsg);
            }
        } else {
            // Κλείσιμο timer
            console.log('Closing timer from second screen...');
            const result = await window.electronAPI.closeTimerWindow();
            console.log('Close result:', result);
            
            hdmiTimerOpen = false;
            const openText = safeTranslate('qr.openTimerHDMI', '📺 Άνοιγμα Timer HDMI');
            btnSpan.textContent = openText;
            btn.style.backgroundColor = '#27ae60';
            
            const closeTitle = safeTranslate('admin:hdmiTimerClosed', 'Timer HDMI Έκλεισε');
            const closeMsg = safeTranslate('admin:hdmiTimerClosedMsg', 'Timer έκλεισε από δεύτερη οθόνη');
            customAlert(closeTitle, closeMsg, 'info');
            console.log('Timer closed from second screen');
        }
        
    } catch (error) {
        console.error('Error with HDMI timer:', error);
        
        // Επαναφορά κατάστασης σε περίπτωση σφάλματος
        hdmiTimerOpen = false;
        const errorResetText = safeTranslate('qr.openTimerHDMI', '📺 Άνοιγμα Timer HDMI');
        btnSpan.textContent = errorResetText;
        btn.style.backgroundColor = '#27ae60';
        
        const title = safeTranslate('admin:hdmiScreenError', 'Σφάλμα Οθόνης');
        const message = `${safeTranslate('admin:hdmiScreenErrorMsg', '❌ Σφάλμα κατά τη διαχείριση της δεύτερης οθόνης:')}\n\n${error.message}`;
        showCustomAlert(title, message);
     } finally {
        btn.disabled = false;
        
        // Fallback: αν κάτι πάει λάθος με το κείμενο
        if (btnSpan.textContent === '⏳ Φόρτωση...' || btnSpan.textContent === '⏳ Loading...') {
            btnSpan.textContent = originalText;
        }
        
        // ΠΡΟΣΘΗΚΗ ΑΥΤΟ
        setTimeout(() => {
            isHdmiToggling = false;
        }, 2000);
               
    }
}

// HDMI notifications now use customAlert for consistency
// ------ FULLSCREEN FUNCTIONALITY ------
function toggleAdminFullscreen() {
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    
    if (!document.fullscreenElement) {
        // Μπαίνουμε σε fullscreen
        document.documentElement.requestFullscreen().then(() => {
            console.log('Admin entered fullscreen');
            fullscreenBtn.classList.add('fullscreen-active');
            fullscreenBtn.title = 'Έξοδος από Fullscreen (⛶)';
            showAdminFullscreenNotification('🔍 Fullscreen ON');
        }).catch(err => {
            console.error('Error entering fullscreen:', err);
        });
    } else {
        // Βγαίνουμε από fullscreen
        document.exitFullscreen().then(() => {
            console.log('Admin exited fullscreen');
            fullscreenBtn.classList.remove('fullscreen-active');
            fullscreenBtn.title = 'Εναλλαγή Fullscreen (⛶)';
            showAdminFullscreenNotification('🔍 Fullscreen OFF');
        });
    }
}

// Ανίχνευση αλλαγών fullscreen (για ESC key)
document.addEventListener('fullscreenchange', () => {
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    if (!document.fullscreenElement) {
        fullscreenBtn.classList.remove('fullscreen-active');
        fullscreenBtn.title = 'Εναλλαγή Fullscreen (⛶)';
    }
});

// Ειδοποίηση fullscreen
function showAdminFullscreenNotification(message) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: rgba(52, 152, 219, 0.9);
        color: white;
        padding: 10px 15px;
        border-radius: 6px;
        font-size: 0.9rem;
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
        border: 2px solid #3498db;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Εμφάνιση
    setTimeout(() => {
        notification.style.opacity = '1';
    }, 10);
    
    // Απόκρυψη μετά από 2 δευτερόλεπτα
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 2000);
}
// ============================================================
// ============================================================
// 📂 EXCEL IMPORT FUNCTIONS - Πρόσθεσε αντικαθιστώντας τις παλιές
// ============================================================





// Process selected Excel file
async function handleExcelFileSelection(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Validate file type
    if (!file.name.toLowerCase().endsWith('.xlsx') && !file.name.toLowerCase().endsWith('.xls')) {
        fixInputsWithPopup('❌ Παρακαλώ επιλέξτε αρχείο Excel (.xlsx ή .xls)');
        return;
    }
    
    const confirmMessage = `📂 IMPORT EXCEL ΑΡΧΕΙΟΥ

📁 Αρχείο: ${file.name}
📊 Μέγεθος: ${(file.size / 1024).toFixed(1)} KB
📂 Τοποθεσία: ${file.path || 'Επιλεγμένο αρχείο'}

⚠️ Το σύστημα θα αρχίσει να παρακολουθεί αυτό το αρχείο για αλλαγές κάθε 3 δευτερόλεπτα.

Συνέχεια με το import;`;

   // Έλεγχος αν είμαστε σε Electron για να χρησιμοποιήσουμε το σωστό dialog
    let userConfirmed;
    if (window.electronAPI) {
        userConfirmed = await window.electronAPI.showConfirmDialog({
            title: 'Import Excel',
            message: confirmMessage
        });
    } else {
        userConfirmed = confirm(confirmMessage);
    }
    
    if (!userConfirmed) {
        // Clear file input
        event.target.value = '';
        return;
    }
    
    try {
        console.log('📂 Starting Excel import:', file.name);
        
        // Prepare form data
        const formData = new FormData();
        formData.append('excelFile', file);
        
        // Send file to server
        const response = await fetch('/api/markers/import-excel', {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            const result = await response.json();
            
            console.log('✅ Excel import successful:', result);
            
            // Update UI
            updateCurrentFileDisplay(result.filename, result.filePath);
            updateExcelStatus();
            
            const successMessage = `✅ EXCEL IMPORT ΕΠΙΤΥΧΗΣ!

📁 Αρχείο: ${result.filename}
📊 Φορτώθηκαν: ${result.markersCount} markers
📂 Παρακολούθηση: Ενεργή

Το σύστημα παρακολουθεί τώρα το αρχείο για αλλαγές!`;
            
            
    fixInputsWithPopup('✅ Excel Import Επιτυχής!');
        } else {
            const error = await response.json();
            console.error('❌ Excel import failed:', error);
            fixInputsWithPopup(`❌ Σφάλμα import: ${error.error || 'Άγνωστο σφάλμα'}`);
        }
        
    } catch (error) {
        console.error('❌ Excel import error:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Import Error' : 'Σφάλμα Εισαγωγής';
        const message = currentLang === 'en' ? '❌ Connection error during import' : '❌ Σφάλμα σύνδεσης κατά το import';
        showCustomAlert(title, message);
    } finally {
        // Clear file input για να μπορεί να επιλέξει το ίδιο αρχείο ξανά
        event.target.value = '';
    }
}

// Update current file display
function updateCurrentFileDisplay(filename, filePath) {
    const nameElement = document.getElementById('current-file-name');
    const pathElement = document.getElementById('current-file-path');
    const containerElement = document.getElementById('current-file-display');
    
    if (filename) {
        nameElement.textContent = filename;
        pathElement.textContent = filePath || '';
        containerElement.className = 'current-file-info has-file';
    } else {
        nameElement.textContent = 'Κανένα αρχείο δεν έχει φορτωθεί';
        pathElement.textContent = '';
        containerElement.className = 'current-file-info no-file';
    }
}

// Enhanced Excel status update
async function updateExcelStatus() {
    try {
        const response = await fetch('/api/markers/excel-status');
        if (response.ok) {
            const status = await response.json();
            
            // Update current file display
            if (status.currentFile) {
                updateCurrentFileDisplay(status.currentFile.name, status.currentFile.path);
            } else {
                updateCurrentFileDisplay(null, null);
            }
            
            // Update main page status (αν υπάρχει)
            const statusDiv = document.getElementById('excel-status');
            if (statusDiv) {
                updateStatusDiv(statusDiv, status);
            }
            
            // Update modal status  
            const modalStatusDiv = document.getElementById('excel-status-modal');
            if (modalStatusDiv) {
                updateStatusDiv(modalStatusDiv, status);
            }
        }
    } catch (error) {
        console.error('Status update error:', error);
    }
}

// Enhanced helper function για update status divs
function updateStatusDiv(statusDiv, status) {
    if (status.currentFile && status.monitoringActive) {
        statusDiv.className = 'excel-status monitoring';
        statusDiv.innerHTML = `🔄 Παρακολούθηση: ${status.currentFile.name} | ${status.excelMarkers} markers`;
    } else if (status.currentFile && !status.monitoringActive) {
        statusDiv.className = 'excel-status warning';
        statusDiv.innerHTML = `⚠️ Αρχείο ${status.currentFile.name} - Παρακολούθηση ανενεργή`;
    } else {
        statusDiv.className = 'excel-status error';
        statusDiv.innerHTML = '❌ Κανένα αρχείο Excel δεν έχει φορτωθεί';
    }
}

// Manual refresh from Excel
async function refreshFromExcel() {
    try {
        const response = await fetch('/api/markers/refresh-excel', {
            method: 'POST'
        });
       
        if (response.ok) {
            const data = await response.json();
            console.log('📊 Excel refresh successful:', data.count, 'markers');
            updateExcelStatus();
            
            if (data.sourceFile) {
                const currentLang = localStorage.getItem('preferredLanguage') || 'el';
                const title = currentLang === 'en' ? 'Success' : 'Επιτυχία';
                const message = currentLang === 'en' ? `✅ Refresh successful!\n📁 ${data.sourceFile}\n📊 ${data.count} markers` : `✅ Ανανέωση επιτυχής!\n📁 ${data.sourceFile}\n📊 ${data.count} markers`;
                showCustomAlert(title, message);
                
                // Reset text fields after Excel refresh
fixInputsWithPopup('✅ Excel Import Επιτυχής!');   
            } else {
                fixInputsWithPopup('⚠️ Δεν έχει φορτωθεί Excel αρχείο για ανανέωση');

            }
        } else {
            console.error('Excel refresh failed');
            fixInputsWithPopup('❌ Σφάλμα κατά την ανανέωση από Excel');
        }
    } catch (error) {
        console.error('Excel refresh error:', error);
        fixInputsWithPopup('❌ Σφάλμα σύνδεσης κατά την ανανέωση');
    }
}

// Clear Excel data and reset monitoring
async function clearExcelData() {
    try {
        // Show confirmation dialog
        const confirmed = await showCustomConfirm(
            'Καθαρισμός Excel Δεδομένων',
            'Θέλετε να καθαρίσετε όλα τα Excel markers και να σταματήσετε την παρακολούθηση;',
            'Ακύρωση',
            'Καθαρισμός'
        );
        
        if (!confirmed) {
            return;
        }
        
        // Get all markers first
        const markersResponse = await fetch('/api/event-markers');
        if (!markersResponse.ok) {
            throw new Error('Failed to fetch markers');
        }
        
        const data = await markersResponse.json();
        const markers = data.markers || [];
        const excelMarkers = markers.filter(marker => 
            marker.source === 'excel' || (marker.id && marker.id.startsWith('excel-marker-'))
        );
        
        console.log(`Found ${excelMarkers.length} Excel markers to delete`);
        
        // Delete each Excel marker individually
        let deletedCount = 0;
        for (const marker of excelMarkers) {
            try {
                const deleteResponse = await fetch(`/api/event-markers/${marker.id}`, {
                    method: 'DELETE'
                });
                if (deleteResponse.ok) {
                    deletedCount++;
                }
            } catch (error) {
                console.warn(`Failed to delete marker ${marker.id}:`, error);
            }
        }
        
        console.log(`Successfully deleted ${deletedCount}/${excelMarkers.length} Excel markers`);
        
        // Stop Excel monitoring on server
        try {
            const stopResponse = await fetch('/api/markers/stop-excel-monitoring', {
                method: 'POST'
            });
            if (stopResponse.ok) {
                console.log('✅ Excel monitoring stopped');
            }
        } catch (error) {
            console.warn('Failed to stop Excel monitoring:', error);
        }
        
        // Reset UI elements
        updateCurrentFileDisplay(null, null);
        updateExcelStatus();
        
        // Reset conference title to default
        const defaultTitle = 'TimeCast® Pro Conference Timer';
        document.getElementById('title-input').value = defaultTitle;
        document.getElementById('title-preview').textContent = defaultTitle;
        document.title = "Admin - " + defaultTitle;
        
        // Reset timeline to defaults
        document.getElementById('event-start-time-settings').value = '09:00';
        document.getElementById('event-end-time-settings').value = '17:00';
        updateEventDuration();
        
        // Apply settings to server using existing functions
        try {
            // Apply title settings
            applyDisplaySettings();
            
            // Apply timeline settings
            applyTimelineSettings();
            
            console.log('✅ Reset settings sent to server');
        } catch (error) {
            console.warn('Failed to reset server settings:', error);
        }
        
        // Show success message
        await showCustomAlert(
            'Καθαρισμός Επιτυχής',
            `✅ ${deletedCount} Excel markers καθαρίστηκαν επιτυχώς.`
        );
        
        console.log('✅ Excel data cleared successfully');
        
    } catch (error) {
        console.error('❌ Clear Excel data error:', error);
        await showCustomAlert(
            'Σφάλμα Καθαρισμού',
            '❌ Αποτυχία καθαρισμού Excel δεδομένων. Προσπαθήστε ξανά.'
        );
    }
}

// Export current timeline to Excel (using existing smart system)
async function exportCurrentTimeline() {
    try {
        // Λήψη τρέχοντος τίτλου από το UI (όπως κάνει η createSampleExcel)
        const currentTitle = document.getElementById('title-input').value || 
                            document.getElementById('title-preview').textContent || 
                            'Timer';
        
        // Καλούμε το υπάρχον API που χρησιμοποιεί το excel-markers.js
        const response = await fetch('/api/markers/export-current-timeline', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                exportType: 'current-timeline',
                title: currentTitle  // Περνάμε τον τίτλο από το UI
            })
        });
        
        if (response.ok) {
            const result = await response.json();
            
            if (result.success) {
                console.log('✅ Timeline exported successfully:', result.filename);
                fixInputsWithPopup(`✅ Η χρονοσειρά εξήχθη επιτυχώς!\n📁 Αρχείο: ${result.filename}`);
            } else {
                console.error('Export failed:', result.error);
                fixInputsWithPopup('❌ Σφάλμα εξαγωγής: ' + result.error);
            }
        } else {
            console.error('Export failed:', response.status);
            fixInputsWithPopup('❌ Σφάλμα εξαγωγής χρονοσειράς');
        }
    } catch (error) {
        console.error('Export error:', error);
        fixInputsWithPopup('❌ Σφάλμα σύνδεσης κατά την εξαγωγή');
    }
}

// Create sample Excel file
async function createSampleExcel() {
    // Λήψη τρέχοντος τίτλου
    const currentTitle = document.getElementById('title-input').value || 
                        document.getElementById('title-preview').textContent || 
                        'Timer';
    
    // Clean title για preview
    const cleanTitle = currentTitle
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .slice(0, 20);
    
    const dateStr = new Date().toLocaleDateString('en-GB', {
        day: '2-digit', month: 'short', year: 'numeric'
    }).replace(/\s/g, '-').toUpperCase();
    
    const previewFilename = `Timeline-${dateStr}-${cleanTitle}.xlsx`;
    
    const confirmMessage = `📄 ΕΞΑΓΩΓΗ ΧΡΟΝΟΣΕΙΡΑΣ ΣΕ EXCEL

📁 Όνομα αρχείου: ${previewFilename}

📊 Περιεχόμενο:
${eventMarkers && eventMarkers.length > 0 ? 
  `✅ Τρέχουσα χρονοσειρά (${eventMarkers.length} markers)` : 
  '📋 Δείγματα χρονοσειράς (7 events)'}

📂 Τοποθεσία: Φάκελος εφαρμογής

Δημιουργία αρχείου;`;

    if (!confirm(confirmMessage)) {
        return;
    }
    
    try {
        console.log('📊 Creating smart sample with title:', currentTitle);
        
        const response = await fetch('/api/markers/create-smart-sample', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: currentTitle })
        });
        
        if (response.ok) {
            const result = await response.json();
            
            const successMessage = `✅ EXCEL ΑΡΧΕΙΟ ΔΗΜΙΟΥΡΓΗΘΗΚΕ!

📁 Αρχείο: ${result.filename}
📊 Markers: ${result.markersCount}
📂 Τοποθεσία: Φάκελος εφαρμογής

💡 Το αρχείο είναι έτοιμο για επεξεργασία!`;
            
            fixInputsWithPopup(successMessage);


            
        } else {
            const error = await response.json();
            fixInputsWithPopup(`❌ Σφάλμα: ${error.error}`)
        }
        
    } catch (error) {
        console.error('Smart sample creation error:', error);
        fixInputsWithPopup('❌ Σφάλμα δημιουργίας αρχείου');
    }
}
// Show Excel status με λεπτομέρειες
async function showExcelStatus() {
    try {
        const response = await fetch('/api/markers/excel-status');
        
        if (response.ok) {
            const status = await response.json();
            
            let message = '📊 ΚΑΤΑΣΤΑΣΗ EXCEL DATASOURCE\n';
            message += '════════════════════════════════\n\n';
            
            // Current file info
            if (status.currentFile) {
                message += `📁 Τρέχον αρχείο: ${status.currentFile.name}\n`;
                message += `📂 Διαδρομή: ${status.currentFile.path}\n`;
                message += `💾 Υπάρχει: ${status.currentFile.exists ? '✅ Ναι' : '❌ Όχι'}\n\n`;
            } else {
                message += `📁 Τρέχον αρχείο: ❌ Κανένα\n\n`;
            }
            
            // Timing info
            if (status.lastModified) {
                const lastMod = new Date(status.lastModified);
                message += `🕒 Τελευταία τροποποίηση: ${lastMod.toLocaleString('el-GR')}\n`;
            } else {
                message += `🕒 Τελευταία τροποποίηση: Άγνωστη\n`;
            }
            
            // Monitoring status
            message += `🔄 Παρακολούθηση: ${status.monitoringActive ? '✅ Ενεργή (κάθε 3")' : '❌ Ανενεργή'}\n\n`;
            
            // Markers info
            message += `📌 Excel Markers: ${status.excelMarkers}\n`;
            message += `📊 Συνολικά Markers: ${status.totalMarkers}\n\n`;
            
            // Instructions
            message += '💡 ΟΔΗΓΙΕΣ ΧΡΗΣΗΣ:\n';
            message += '• Πάτησε "📂 Επιλογή Excel Αρχείου" για import\n';
            message += '• Στήλη A: Ώρα (π.χ. 09:30)\n';
            message += '• Στήλη B: Τίτλος (π.χ. Διάλειμμα Καφέ)\n';
            message += '• Αποθήκευσε το αρχείο - οι αλλαγές θα φορτωθούν αυτόματα!';
            
            // Χρήση custom dialog για μεγάλα μηνύματα
const div = document.createElement('div');
div.innerHTML = `<pre style="white-space: pre-wrap;">${message}</pre>`;
div.style.cssText = 'max-height: 400px; overflow-y: auto;';
fixInputsWithPopup(div.innerHTML);
        }
    } catch (error) {
        console.error('Excel status error:', error);
        fixInputsWithPopup('❌ Σφάλμα λήψης κατάστασης Excel');

    }
}
// ============================================================
// 🖥️ ENVIRONMENT DETECTION & DUAL MODE SUPPORT
// ============================================================

// Detect if running in Electron
function isElectronEnvironment() {
    return window.navigator.userAgent.toLowerCase().includes('electron');
}


// Helper function για σύντομα source labels (για tabs)
// Helper function για σύντομα source labels (για tabs)
function getSourceShortLabel(source) {
    switch(source) {
        case 'excel': return '📗'; // Μόνο εικονίδιο
        case 'google_sheets': return '🌐'; // Μόνο εικονίδιο
        default: return '✋'; // Μόνο εικονίδιο
    }
}

// Helper function για πλήρη source labels (για edit dialog)
function getSourceLabel(source) {
    const currentLang = localStorage.getItem('preferredLanguage') || 'el';
    const translations = {
        el: {
            excel: '📗 Excel Αρχείο',
            google_sheets: '🌐 Google Sheets',
            manual: '✋ Χειροκίνητη Εισαγωγή'
        },
        en: {
            excel: '📗 Excel File',
            google_sheets: '🌐 Google Sheets',
            manual: '✋ Manual Entry'
        }
    };
    
    const t = translations[currentLang];
    return t[source] || t.manual;
}
// Enhanced file selection με dual mode
function selectExcelFile() {
    if (isElectronEnvironment()) {
        // Electron mode - use file dialog
        selectExcelFileElectron();
    } else {
        // Web mode - use file input
        selectExcelFileWeb();
    }
}

// Web mode file selection (existing)
function selectExcelFileWeb() {
    const fileInput = document.getElementById('excel-file-input');
    fileInput.click();
}

// Electron mode file selection
async function selectExcelFileElectron() {
    try {
        // Request file dialog through main process
        const result = await window.electronAPI.selectExcelFile();
        
        if (result.canceled) {
            console.log('📂 File selection canceled');
            return;
        }
        
        const filePath = result.filePaths[0];
        console.log('📂 Selected file path:', filePath);
        
        // Use path-based import
        await importExcelFromPath(filePath);
        
    } catch (error) {
        console.error('❌ Electron file selection error:', error);
        fixInputsWithPopup('❌ Σφάλμα επιλογής αρχείου στο Electron mode');
    }
}

// Import Excel από path (για Electron)
async function importExcelFromPath(filePath) {
    const confirmMessage = `📂 IMPORT EXCEL ΑΡΧΕΙΟΥ (Electron Mode)

📁 Αρχείο: ${filePath.split(/[/\\]/).pop()}
📂 Διαδρομή: ${filePath}

⚠️ Το σύστημα θα αρχίσει να παρακολουθεί αυτό το αρχείο για αλλαγές κάθε 3 δευτερόλεπτα.

Συνέχεια με το import;`;

    // Χρήση του ασφαλούς Electron dialog που επαναφέρει το focus
    // Έλεγχος environment - Electron ή Browser
let userConfirmed;
if (window.electronAPI && window.electronAPI.showConfirmDialog) {
    // Electron mode
    userConfirmed = await window.electronAPI.showConfirmDialog({
        title: 'ΠΡΟΣΟΧΗ - ΠΛΗΡΗΣ ΔΙΑΓΡΑΦΗ!',
        message: 'Αυτή η ενέργεια θα διαγράψει ΠΑΝΤΑ τα δεδομένα:\n\n• Όλα τα Event Markers\n• Όλα τα Saved Messages\n• Excel & Google Sheets monitoring\n• Stream Deck slots\n• Λογότυπα και ρυθμίσεις\n• localStorage & cache\n\nΞΕΧΝΑ ΤΑ ΠΑΝΤΑ - Start Fresh!\n\nΕίστε 100% σίγουροι;'
    });
} else {
    // Browser mode - χρήση κανονικού confirm
    userConfirmed = confirm('ΠΡΟΣΟΧΗ - ΠΛΗΡΗΣ ΔΙΑΓΡΑΦΗ!\n\nΑυτή η ενέργεια θα διαγράψει ΠΑΝΤΑ τα δεδομένα:\n\n• Όλα τα Event Markers\n• Όλα τα Saved Messages\n• Excel & Google Sheets monitoring\n• Stream Deck slots\n• Λογότυπα και ρυθμίσεις\n• localStorage & cache\n\nΞΕΧΝΑ ΤΑ ΠΑΝΤΑ - Start Fresh!\n\nΕίστε 100% σίγουροι;');
}
    
    if (!userConfirmed) {
        return;
    }
    
    try {
        console.log('📂 Starting Excel path import:', filePath);
        
        const response = await fetch('/api/markers/import-excel-path', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filePath: filePath })
        });
        
        if (response.ok) {
            const result = await response.json();
            
            console.log('✅ Excel path import successful:', result);
            
            // Update UI
            updateCurrentFileDisplay(result.filename, result.filePath);
            updateExcelStatus();
            
            const successMessage = `✅ EXCEL IMPORT ΕΠΙΤΥΧΗΣ! (Electron Mode)

📁 Αρχείο: ${result.filename}
📊 Φορτώθηκαν: ${result.markersCount} markers
📂 Παρακολούθηση: Ενεργή

Το σύστημα παρακολουθεί τώρα το αρχείο για αλλαγές!`;
            
           
    fixInputsWithPopup('✅ Excel Import Επιτυχής! (Electron Mode)');

            
        } else {
            const error = await response.json();
            console.error('❌ Excel path import failed:', error);
            fixInputsWithPopup(`❌ Σφάλμα import: ${error.error || 'Άγνωστο σφάλμα'}`);
        }
        
    } catch (error) {
        console.error('❌ Excel path import error:', error);
        fixInputsWithPopup('❌ Σφάλμα σύνδεσης κατά το import');
    }
}



// Update button text based on environment
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const importButton = document.querySelector('button[onclick="selectExcelFile()"]');
        if (importButton) {
            if (isElectronEnvironment()) {
                importButton.innerHTML = '📂 Εισαγωγή Χρονοσειράς από Excel';
            } else {
                importButton.innerHTML = '📂 Επιλογή Excel Αρχείου (Upload)';
            }
        }
    }, 1000);
});


console.log('🖥️ Environment:', isElectronEnvironment() ? 'Electron' : 'Web Browser');

async function importFromGoogleSheets() {
    // Environment detection
    if (isElectronEnvironment()) {
        // Electron mode - χρήση custom dialog
        createGoogleSheetsDialog();
        return; // Η logic συνεχίζει στο dialog callback
    } else {
        // Browser mode - χρήση prompt
        const sheetsUrl = prompt(`🌐 GOOGLE SHEETS IMPORT

ΟΔΗΓΙΕΣ:
1. Ανοίξτε το Google Sheet
2. Κλικ "Share" → "Anyone with the link can view"  
3. Αντιγράψτε το URL
4. Επικολλήστε εδώ

ΜΟΡΦΗ ΔΕΔΟΜΕΝΩΝ:
A: Time (09:30)  |  B: Title (Έναρξη)  |  C: Note (προαιρετικό)

Εισάγετε το Google Sheets URL:`);
        
        if (!sheetsUrl) return;
        
        // Καλούμε την κοινή logic
        await performGoogleSheetsImport(sheetsUrl);
    }
}

// Helper function to extract sheet name from URL
function extractSheetName(url) {
    try {
        const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
        return match ? `Sheet (${match[1].substring(0, 8)}...)` : 'Google Sheets';
    } catch {
        return 'Google Sheets';
    }
}

// Functions για Google Sheets controls
async function connectToGoogleSheets() {
    const sheetsUrl = document.getElementById('sheets-url-input').value.trim();
    
    if (!sheetsUrl) {
        fixInputsWithPopup('Παρακαλώ εισάγετε το Google Sheets URL');
        return;
    }
    
    if (!sheetsUrl.includes('docs.google.com/spreadsheets')) {
        fixInputsWithPopup('❌ Αυτό δεν είναι Google Sheets URL!\n\nΠρέπει να είναι: docs.google.com/spreadsheets/...');
        return;
    }
    
    try {
        console.log('🔗 Connecting to Google Sheets...');
        
        // Πρώτα κάνουμε connect για να ξεκινήσει το monitoring
        const connectResponse = await fetch('/api/google-sheets/connect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: sheetsUrl })
        });
        
        if (connectResponse.ok) {
            console.log('✅ Connected to Google Sheets');
            
            // Τώρα κάνουμε αμέσως import των δεδομένων
            const importResponse = await fetch('/api/google-sheets/import', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: sheetsUrl })
            });
            
            if (importResponse.ok) {
                const importResult = await importResponse.json();
                console.log('✅ Initial import completed');
                fixInputsWithPopup(`✅ Σύνδεση και φόρτωση επιτυχής!\n📊 Φορτώθηκαν ${importResult.markersCount || 0} markers`);
                
                // Update Google Sheets status display
                const statusElement = document.getElementById('google-sheets-status-display');
                if (statusElement) {
                    const fileName = importResult.spreadsheetTitle || 'Google Sheets';
                    const projectTitle = importResult.timeline?.projectTitle;
                    
                    let displayName = fileName;
                    if (projectTitle && projectTitle !== fileName && projectTitle.trim() !== '') {
                        displayName = `${fileName} (${projectTitle})`;
                    }
                    
                    statusElement.innerHTML = `✅ Συνδεδεμένο: ${displayName} - ${importResult.markersCount || 0} markers`;
                    statusElement.style.color = '#27ae60';
                }
            } else {
                console.error('❌ Initial import failed');
                fixInputsWithPopup('✅ Σύνδεση επιτυχής!\n⚠️ Αρχική φόρτωση απέτυχε - δοκιμάστε Ανανέωση');
                
                // Update Google Sheets status display
                const statusElement = document.getElementById('google-sheets-status-display');
                if (statusElement) {
                    statusElement.innerHTML = `⚠️ Συνδεδεμένο αλλά η φόρτωση απέτυχε`;
                    statusElement.style.color = '#f39c12';
                }
            }
        } else {
            console.error('❌ Connection failed');
            fixInputsWithPopup('❌ Σφάλμα σύνδεσης με Google Sheets');
        }
    } catch (error) {
        console.error('❌ Connection error:', error);
        fixInputsWithPopup('❌ Σφάλμα σύνδεσης');
    }
}

async function refreshFromGoogleSheets() {
    try {
        console.log('🔄 Refreshing from Google Sheets...');
        
        const response = await fetch('/api/google-sheets/refresh', {
            method: 'POST'
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('✅ Refreshed from Google Sheets');
            fixInputsWithPopup('✅ Ανανέωση από Google Sheets επιτυχής!');
        } else {
            console.error('❌ Refresh failed');
            fixInputsWithPopup('❌ Σφάλμα ανανέωσης από Google Sheets');
        }
    } catch (error) {
        console.error('❌ Refresh error:', error);
        fixInputsWithPopup('❌ Σφάλμα ανανέωσης');
    }
}

async function disconnectFromGoogleSheets() {
    try {
        console.log('🔌 Disconnecting from Google Sheets...');
        
        const response = await fetch('/api/google-sheets/disconnect', {
            method: 'POST'
        });
        
        if (response.ok) {
            console.log('✅ Disconnected from Google Sheets');
            fixInputsWithPopup('✅ Αποσύνδεση από Google Sheets επιτυχής!');
            
            // Clear the URL input
            document.getElementById('sheets-url-input').value = '';
            
            // Reset Google Sheets status display
            const statusElement = document.getElementById('google-sheets-status-display');
            if (statusElement) {
                statusElement.innerHTML = '❓ Κανένα Google Sheets αρχείο συνδεδεμένο';
                statusElement.style.color = '#e74c3c';
            }
        } else {
            console.error('❌ Disconnect failed');
            fixInputsWithPopup('❌ Σφάλμα αποσύνδεσης από Google Sheets');
        }
    } catch (error) {
        console.error('❌ Disconnect error:', error);
        fixInputsWithPopup('❌ Σφάλμα αποσύνδεσης');
    }
}

// Κοινή logic για import (χρησιμοποιείται από browser και Electron)
async function performGoogleSheetsImport(sheetsUrl) {
    // Έλεγχος αν είναι Google Sheets URL
    if (!sheetsUrl.includes('docs.google.com/spreadsheets')) {
        fixInputsWithPopup('❌ Αυτό δεν είναι Google Sheets URL!\n\nΠρέπει να είναι: docs.google.com/spreadsheets/...');

        return;
    }
    
    try {
        console.log('📊 Importing from Google Sheets...');
        
        // Loading indicator
        const loadingMsg = document.createElement('div');
        loadingMsg.style.cssText = `
            position: fixed; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            background: #0f9d58; color: white; 
            padding: 20px; border-radius: 10px; 
            z-index: 10000; text-align: center;
        `;
        loadingMsg.innerHTML = '🌐 Φόρτωση από Google Sheets...<br><small>Μπορεί να πάρει λίγα δευτερόλεπτα</small>';
        document.body.appendChild(loadingMsg);
        
        const response = await fetch('/api/import-google-sheets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sheetsUrl: sheetsUrl })
        });
        
        document.body.removeChild(loadingMsg);
        
        if (response.ok) {
            const result = await response.json();
            
            await showCustomAlert('Google Sheets Import', `✅ GOOGLE SHEETS ΕΙΣΗΧΘΗ ΕΠΙΤΥΧΩΣ!
📊 Markers: ${result.markersCount}
📝 Τίτλος: ${result.projectTitle}
🕐 Timeline: ${result.timeline.startTime} - ${result.timeline.endTime}

🔄 Αυτόματη παρακολούθηση ενεργή κάθε 45 δευτερόλεπτα!`);
            
            // ✅ ΣΩΣΤΗ ΚΛΗΣΗ:
            fixInputsWithPopup('✅ Google Sheets Import Επιτυχής!');
            
        } else {
            const error = await response.json();
            throw new Error(error.error);
        }
        
    } catch (error) {
        alert(`❌ ΣΦΑΛΜΑ GOOGLE SHEETS IMPORT:

${error.message}

💡 ΛΥΣΕΙΣ:
- Κάντε το Sheet public: Share → "Anyone with link can view"
- Ελέγξτε τη μορφή δεδομένων: Time | Title | Note
- Βεβαιωθείτε ότι οι ώρες είναι ΩΩ:ΛΛ (09:30)
- Χρησιμοποιήστε το Google Sheets URL (όχι shortened link)`);
    }
}
// ΑΝΤΙΚΑΤΑΣΤΗΣΗ ΤΗΣ function fixInputsWithPopup στο admin.html

async function fixInputsWithPopup(message) {
    // Χρήση custom alert αντί για native alert
    const currentLang = localStorage.getItem('preferredLanguage') || 'el';
    const title = currentLang === 'en' ? 'Notification' : 'Ειδοποίηση';
    await showCustomAlert(title, message);
    
    // ΠΡΟΣΘΗΚΗ: Force focus επαναφορά μετά από το custom dialog
    setTimeout(() => {
        // Focus επαναφορά στο τελευταίο ενεργό στοιχείο ή document body
        if (document.activeElement && document.activeElement !== document.body) {
            document.activeElement.blur();
        }
        
        // Focus στο message textarea αν υπάρχει
        const messageInput = document.getElementById('message-input');
        if (messageInput) {
            messageInput.focus();
        } else {
            document.body.focus();
        }
        
        console.log('✅ Focus restored after custom popup');
    }, 200);
}
// Wrapper function για async clearAllData
async function handleClearAllData() {
    try {
        await clearAllData();
    } catch (error) {
        console.error('Clear all data error:', error);
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';
        const title = currentLang === 'en' ? 'Error' : 'Σφάλμα';
        const message = currentLang === 'en' ? `Error during cleanup: ${error.message}` : `Σφάλμα κατά τον καθαρισμό: ${error.message}`;
        showCustomAlert(title, message);
    }
}

// LocalStorage auto-save restore functionality
async function handleRestoreAutoBackup() {
    console.log('🔄 handleRestoreAutoBackup() called - using file-based restore');

    try {
        // Get language ONCE at the beginning
        const currentLang = localStorage.getItem('preferredLanguage') || 'el';

        let autoSaveData = null;
        let dataSource = 'unknown';

        // Try to load from file first (Electron environment)
        if (window.electronAPI && window.electronAPI.loadAutoBackupFile) {
            console.log('🔍 Attempting to load from auto-save file...');
            const fileResult = await window.electronAPI.loadAutoBackupFile();

            if (fileResult.success) {
                autoSaveData = fileResult.data;
                dataSource = `file (${fileResult.timestamp})`;
                console.log('✅ Auto-save data loaded from file:', fileResult.version);
            } else {
                console.log('⚠️ File loading failed:', fileResult.error);
                // Fallback to localStorage
                const localData = localStorage.getItem('timerAutoSave');
                if (localData) {
                    autoSaveData = JSON.parse(localData);
                    dataSource = 'localStorage fallback';
                    console.log('🔄 Falling back to localStorage data');
                }
            }
        } else {
            // Browser environment - use localStorage
            const localData = localStorage.getItem('timerAutoSave');
            if (localData) {
                autoSaveData = JSON.parse(localData);
                dataSource = 'localStorage (browser)';
                console.log('🌐 Using localStorage in browser environment');
            }
        }

        if (!autoSaveData) {
            const title = currentLang === 'en' ? 'No auto-save found' : 'Δεν βρέθηκε αποθηκευμένο auto-save';
            const message = currentLang === 'en' ? 'Auto-save happens automatically every 30 seconds.' : 'Το auto-save γίνεται κάθε 30 δευτερόλεπτα αυτόματα.';

            customAlert(title, message, 'error');
            return;
        }

        console.log(`✅ Auto-save data found from: ${dataSource}`);

        // Parse and show auto-save info
        const savedSettings = autoSaveData;
        const saveTime = savedSettings.timestamp || savedSettings.autoSaveTimestamp || 'Unknown time';

        // Declare arrays outside scope for later server sync
        let messagesArray = [];
        let markersArray = [];

        // Custom confirm dialog με μετάφραση

        const confirmTitle = currentLang === 'en' ? 'Auto-Save Found' : 'Επιτυχής Auto-Save';
        const confirmMessage = currentLang === 'en'
            ? `Saved at: ${saveTime}\n\nDo you want to restore the last saved settings?\nAny unsaved changes will be lost.`
            : `Αποθηκευμένο στις: ${saveTime}\n\nΘέλετε να επαναφέρετε τις τελευταίες αποθηκευμένες ρυθμίσεις?\nΤυχόν μη αποθηκευμένες αλλαγές θα χαθούν.`;
        const confirmBtn = currentLang === 'en' ? 'Restore' : 'Επαναφορά';
        const cancelBtn = currentLang === 'en' ? 'Cancel' : 'Άκυρο';

        const confirmed = await customConfirm(confirmTitle, confirmMessage, confirmBtn, cancelBtn);
        
        if (!confirmed) {
            console.log('🚫 Auto-save restore cancelled by user');
            return;
        }
        
        console.log('✅ User confirmed restore, proceeding...');
        console.log('🔄 Starting localStorage auto-save restore...');
        
        // Restore the settings by loading them directly from the auto-save data
        console.log('📥 Loading settings from auto-save data...');
        
        // Load timer settings
        if (savedSettings.timer) {
            const hours = savedSettings.timer.hours || 0;
            const minutes = savedSettings.timer.minutes || 5;
            const seconds = savedSettings.timer.seconds || 0;
            
            // Update main timer fields
            const mainHoursField = document.getElementById('main-timer-hours');
            const mainMinutesField = document.getElementById('main-timer-minutes');
            const mainSecondsField = document.getElementById('main-timer-seconds');
            
            if (mainHoursField) mainHoursField.value = hours;
            if (mainMinutesField) mainMinutesField.value = minutes;
            if (mainSecondsField) mainSecondsField.value = seconds;
            
            // Update settings modal timer fields
            const timerHours = document.getElementById('timer-hours');
            const timerMinutes = document.getElementById('timer-minutes');
            const timerSecondsField = document.getElementById('timer-seconds');
            
            if (timerHours) timerHours.value = hours;
            if (timerMinutes) timerMinutes.value = minutes;
            if (timerSecondsField) timerSecondsField.value = seconds;
            
            console.log(`⏰ Timer restored: ${hours}:${minutes}:${seconds}`);
        }
        
        // Load display settings
        if (savedSettings.display) {
            const titleInput = document.getElementById('title-input');
            const messageInput = document.getElementById('message-input');
            
            if (titleInput && savedSettings.display.title) {
                titleInput.value = savedSettings.display.title;
            }
            if (messageInput && savedSettings.display.message) {
                messageInput.value = savedSettings.display.message;
            }
            
            console.log('🎨 Display settings restored');
        }
        
        // Load logo settings
        if (savedSettings.display && savedSettings.display.logoDataUrl) {
            logoDataUrl = savedSettings.display.logoDataUrl;
            logoSize = savedSettings.display.logoSize || 80;
            
            // Update logo preview
            const logoPreview = document.getElementById('logo-preview');
            if (logoPreview) {
                logoPreview.src = logoDataUrl;
                logoPreview.style.display = 'inline-block';
            }
            
            // Update logo positions
            if (savedSettings.display.logoPositions) {
                const positions = savedSettings.display.logoPositions;
                ['tl', 'tc', 'tr', 'bl', 'bc', 'br'].forEach(pos => {
                    const checkbox = document.getElementById(`logo-${pos}`);
                    if (checkbox && positions[pos] !== undefined) {
                        checkbox.checked = positions[pos];
                    }
                });
            }
            
            console.log('🖼️ Logo settings restored');
        }
        
        // Load background color
        if (savedSettings.display && savedSettings.display.backgroundColor) {
            const bgColorField = document.getElementById('background-color');
            if (bgColorField) {
                bgColorField.value = savedSettings.display.backgroundColor;
            }
            console.log('🎨 Background color restored');
        }
        
        // Load sound settings
        if (savedSettings.sound) {
            soundEnabled = savedSettings.sound.enabled || false;
            soundVolume = savedSettings.sound.volume || 50;
            
            const soundEnabledField = document.getElementById('sound-enabled');
            const soundVolumeField = document.getElementById('sound-volume');
            
            if (soundEnabledField) soundEnabledField.checked = soundEnabled;
            if (soundVolumeField) soundVolumeField.value = soundVolume;
            
            console.log('🔊 Sound settings restored');
        }
        
        // Load timeline settings
        if (savedSettings.timeline) {
            const timelineStartDisplay = document.getElementById('timeline-start-display');
            const timelineEndDisplay = document.getElementById('timeline-end-display');
            
            if (timelineStartDisplay && savedSettings.timeline.startTime) {
                timelineStartDisplay.textContent = savedSettings.timeline.startTime;
            }
            if (timelineEndDisplay && savedSettings.timeline.endTime) {
                timelineEndDisplay.textContent = savedSettings.timeline.endTime;
            }
            
            console.log('⏰ Timeline settings restored');
        }
        
        // Load saved messages
        if (savedSettings.savedMessages) {
            if (Array.isArray(savedSettings.savedMessages)) {
                // Old format: direct array
                messagesArray = savedSettings.savedMessages;
            } else if (savedSettings.savedMessages.messages && Array.isArray(savedSettings.savedMessages.messages)) {
                // New format: object with messages property
                messagesArray = savedSettings.savedMessages.messages;
            }
            
            if (messagesArray.length > 0) {
                savedMessages = [...messagesArray];
                console.log(`💬 ${messagesArray.length} saved messages restored`);
                // Trigger UI refresh - saved messages will be shown via server request
                // loadSavedMessages(); // Function doesn't exist, server will handle UI update
            } else {
                console.log(`💬 0 saved messages restored`);
            }
        }
        
        // Load event markers
        if (savedSettings.eventMarkers) {
            if (Array.isArray(savedSettings.eventMarkers)) {
                // Old format: direct array
                markersArray = savedSettings.eventMarkers;
            } else if (savedSettings.eventMarkers.markers && Array.isArray(savedSettings.eventMarkers.markers)) {
                // New format: object with markers property
                markersArray = savedSettings.eventMarkers.markers;
            }
            
            if (markersArray.length > 0) {
                eventMarkers = [...markersArray];
                console.log(`📍 ${markersArray.length} event markers restored`);
                // Trigger UI update to show markers on timeline
                const markersContainer = document.getElementById('event-markers-list');
                if (markersContainer) {
                    updateEventMarkersDisplay();
                }
                // loadEventMarkers(); // Function doesn't exist, server will handle UI update
            } else {
                console.log(`📍 0 event markers restored`);
            }
        }
        
        // Load vMix settings
        if (savedSettings.vmix) {
            const vmixHostField = document.getElementById('vmix-host');
            const vmixPortField = document.getElementById('vmix-port');
            const vmixEnabledField = document.getElementById('vmix-enabled');
            const vmixSecondaryField = document.getElementById('vmix-secondary-timer-enabled');
            
            if (vmixHostField && savedSettings.vmix.host) vmixHostField.value = savedSettings.vmix.host;
            if (vmixPortField && savedSettings.vmix.port) vmixPortField.value = savedSettings.vmix.port;
            if (vmixEnabledField) vmixEnabledField.checked = savedSettings.vmix.enabled || false;
            if (vmixSecondaryField) vmixSecondaryField.checked = savedSettings.vmix.secondaryTimerEnabled || false;
            
            console.log('📺 vMix settings restored');
        }
        
        // Restore Google Sheets URL (informational only)
        if (savedSettings.googleSheets && savedSettings.googleSheets.lastUrl) {
            localStorage.setItem('lastGoogleSheetsUrl', savedSettings.googleSheets.lastUrl);
            console.log('📊 Google Sheets URL restored');
        }
        
        // Restore Excel info (informational only)
        if (savedSettings.excel) {
            if (savedSettings.excel.lastFile) {
                localStorage.setItem('lastExcelFile', savedSettings.excel.lastFile);
            }
            if (savedSettings.excel.lastImported) {
                localStorage.setItem('lastExcelImported', savedSettings.excel.lastImported);
            }
            console.log('📋 Excel info restored');
        }
        
        // Load other settings
        if (savedSettings.warningThreshold) {
            const warningField = document.getElementById('warning-threshold');
            if (warningField) warningField.value = savedSettings.warningThreshold;
        }
        
        // 🚀 PRO: Restore advanced display settings
        if (savedSettings.display) {
            if (savedSettings.display.timerFontFamily) {
                const fontFamilyField = document.getElementById('timer-font-family');
                if (fontFamilyField) fontFamilyField.value = savedSettings.display.timerFontFamily;
            }
            if (savedSettings.display.currentMessage) {
                const messageInputField = document.getElementById('message-input');
                if (messageInputField) messageInputField.value = savedSettings.display.currentMessage;
            }
            if (savedSettings.display.messageVisible !== undefined) {
                window.messageVisible = savedSettings.display.messageVisible;
            }
        }
        
        // 🚀 PRO: Restore advanced vMix settings
        if (savedSettings.vmix) {
            if (savedSettings.vmix.manualTimerInput) {
                const manualInputField = document.getElementById('vmix-timer-export-input');
                if (manualInputField) manualInputField.value = savedSettings.vmix.manualTimerInput;
            }
            if (savedSettings.vmix.tallyEnabled !== undefined) {
                window.vmixTallyEnabled = savedSettings.vmix.tallyEnabled;
            }
            if (savedSettings.vmix.connectionStatus !== undefined) {
                window.vmixConnected = savedSettings.vmix.connectionStatus;
            }
        }
        
        // 🚀 PRO: Restore advanced state
        if (savedSettings.advanced) {
            if (savedSettings.advanced.clockMode !== undefined) {
                window.clockMode = savedSettings.advanced.clockMode;
                const clockModeCheckbox = document.getElementById('clock-mode-checkbox');
                if (clockModeCheckbox) clockModeCheckbox.checked = savedSettings.advanced.clockMode;
            }
            if (savedSettings.advanced.currentPC) {
                localStorage.setItem('currentPCName', savedSettings.advanced.currentPC);
            }
            
            // 🔥 SESSION CONTINUITY: Restore exact timer state (KEEP timeLeft for pause/resume, DON'T override main fields)
            if (savedSettings.advanced.timeLeft !== undefined) {
                window.timeLeft = savedSettings.advanced.timeLeft;
                console.log(`⏰ Session continuity: Timer timeLeft restored to ${savedSettings.advanced.timeLeft}s`);
                console.log(`📝 Main timer fields remain as saved in timer settings (${savedSettings.timer?.hours}:${savedSettings.timer?.minutes}:${savedSettings.timer?.seconds})`);
            }
            if (savedSettings.advanced.originalTime !== undefined) {
                window.originalTime = savedSettings.advanced.originalTime;
            }
            if (savedSettings.advanced.timerRunning !== undefined) {
                window.timerRunning = savedSettings.advanced.timerRunning;
                console.log(`⏸️ Session continuity: Timer running state: ${savedSettings.advanced.timerRunning}`);
            }
            
            if (savedSettings.advanced.noSleepEnabled !== undefined) {
                window.adminNoSleepEnabled = savedSettings.advanced.noSleepEnabled;
            }
        }
        
        // 🚀 PRO: Restore UI state
        if (savedSettings.ui) {
            if (savedSettings.ui.settingsTabActive) {
                // Switch to the saved active tab
                const savedTab = savedSettings.ui.settingsTabActive;
                setTimeout(() => switchSettingsTab(savedTab), 100);
            }
            if (savedSettings.ui.eventStartTime) {
                const startTimeField = document.getElementById('event-start-time-settings');
                if (startTimeField) startTimeField.value = savedSettings.ui.eventStartTime;
            }
            if (savedSettings.ui.eventEndTime) {
                const endTimeField = document.getElementById('event-end-time-settings');
                if (endTimeField) endTimeField.value = savedSettings.ui.eventEndTime;
            }
            if (savedSettings.ui.soundVolumeValue) {
                const soundVolumeField = document.getElementById('sound-volume');
                if (soundVolumeField) soundVolumeField.value = savedSettings.ui.soundVolumeValue;
            }
            
            // 🔥 SESSION CONTINUITY: Restore current message text field
            if (savedSettings.ui.messageInputValue) {
                const messageInputField = document.getElementById('message-input');
                if (messageInputField) {
                    messageInputField.value = savedSettings.ui.messageInputValue;
                    console.log(`📝 Session continuity: Message field restored: "${savedSettings.ui.messageInputValue}"`);
                }
            }
        }

        // 🚀 PRO: Restore Yeelight settings
        if (savedSettings.yeelight && window.yeelightManager) {
            console.log('💡 Restoring Yeelight settings...');

            // Restore brightness
            if (savedSettings.yeelight.brightness !== undefined) {
                window.yeelightManager.brightness = savedSettings.yeelight.brightness;
                const brightnessSlider = document.getElementById('yeelight-brightness-slider');
                const brightnessValue = document.getElementById('yeelight-brightness-value');
                if (brightnessSlider) brightnessSlider.value = savedSettings.yeelight.brightness;
                if (brightnessValue) brightnessValue.textContent = `${savedSettings.yeelight.brightness}%`;
                console.log(`🔆 Brightness restored to ${savedSettings.yeelight.brightness}%`);
            }

            // Restore enabled state
            if (savedSettings.yeelight.enabled !== undefined) {
                window.yeelightManager.isEnabled = savedSettings.yeelight.enabled;
                console.log(`🔌 Yeelight enabled state: ${savedSettings.yeelight.enabled}`);
            }

            // Restore connected bulbs (for reference, will be updated by discovery)
            if (savedSettings.yeelight.connectedBulbs && Array.isArray(savedSettings.yeelight.connectedBulbs)) {
                // Store for comparison after discovery
                window.yeelightManager.lastRestoredBulbs = savedSettings.yeelight.connectedBulbs;
                console.log(`💡 ${savedSettings.yeelight.connectedBulbs.length} bulbs from last session stored for reference`);
            }

            // Restore selected bulbs (will be applied after discovery)
            if (savedSettings.yeelight.selectedBulbs && Array.isArray(savedSettings.yeelight.selectedBulbs)) {
                window.yeelightManager.pendingSelectedBulbs = savedSettings.yeelight.selectedBulbs;
                console.log(`🎯 ${savedSettings.yeelight.selectedBulbs.length} bulb selections pending discovery`);
            }

            // Trigger discovery to reconnect and apply selections
            setTimeout(async () => {
                try {
                    await window.yeelightManager.discoverBulbs();

                    // Apply pending selections after discovery με force re-selection
                    if (window.yeelightManager.pendingSelectedBulbs) {
                        const bulbIps = window.yeelightManager.pendingSelectedBulbs.map(bulb => bulb.ip).filter(ip => ip);
                        await window.yeelightManager.forceReSelectBulbs(bulbIps);
                        console.log(`✅ Force re-selected ${bulbIps.length} bulbs after restore`);
                        delete window.yeelightManager.pendingSelectedBulbs;
                    }

                    // Update UI
                    if (typeof yeelightUpdateBulbTable === 'function') {
                        yeelightUpdateBulbTable();
                    }
                } catch (error) {
                    console.warn('⚠️ Yeelight restore discovery failed:', error.message);
                }
            }, 2000); // 2-second delay για να ολοκληρωθεί η restore process

            console.log('💡 Yeelight settings restore initiated');
        } else if (savedSettings.yeelight) {
            console.log('⚠️ Yeelight settings found but yeelightManager not available');
        }

        console.log('✅ PRO COMPLETE restore: Timer, Display, Logo, Sound, Timeline, Messages, Markers, vMix, Advanced, UI State, Yeelight');
        
        // 🔄 CRITICAL: Sync all restored data with server
        console.log('🔄 Syncing restored data with server...');
        
        // Sync timer settings  
        if (savedSettings.timer || savedSettings.advanced) {
            // ALWAYS use timer fields for the base time, use timeLeft for session continuity
            const hours = parseInt(savedSettings.timer?.hours || 0);
            const minutes = parseInt(savedSettings.timer?.minutes || 5);  // FIXED: Use 5 as default, not 15
            const seconds = parseInt(savedSettings.timer?.seconds || 0);
            const totalTime = (hours * 3600) + (minutes * 60) + seconds;
            
            // 🔥 SESSION CONTINUITY: Use timeLeft for current position, but keep timer fields as base
            const actualTimeLeft = savedSettings.advanced?.timeLeft !== undefined ? 
                savedSettings.advanced.timeLeft : totalTime;
            
            socket.emit('timerUpdate', {
                hours: hours,
                minutes: minutes,
                seconds: seconds,
                totalTime: totalTime,
                originalTime: savedSettings.advanced?.originalTime || totalTime,
                timeLeft: actualTimeLeft,  // This will be different from totalTime for session continuity
                timerRunning: savedSettings.advanced?.timerRunning || false
            });
            console.log(`⏰ Timer synced with server - Base: ${hours}:${minutes}:${seconds} (${totalTime}s), Current: ${actualTimeLeft}s`);
            
            // 🔥 CRITICAL: Update admin preview immediately με restored timer
            const timerPreview = document.getElementById('timer-preview');
            if (timerPreview) {
                const displayHours = Math.floor(actualTimeLeft / 3600);
                const displayMinutes = Math.floor((actualTimeLeft % 3600) / 60);
                const displaySeconds = actualTimeLeft % 60;
                
                const formattedTime = displayHours > 0 ? 
                    `${displayHours.toString().padStart(2, '0')}:${displayMinutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}` :
                    `${displayMinutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}`;
                
                timerPreview.textContent = formattedTime;
                console.log(`🎯 Admin preview timer updated to: ${formattedTime} (from ${actualTimeLeft}s)`);
            }
        }
        
        // Sync display settings  
        if (savedSettings.display && savedSettings.display.title) {
            socket.emit('titleSync', { title: savedSettings.display.title });
            console.log('📝 Title synced with server');
        }
        
        // 🔥 SESSION CONTINUITY: Sync current message
        if (savedSettings.ui && savedSettings.ui.messageInputValue) {
            socket.emit('messageUpdate', { 
                message: savedSettings.ui.messageInputValue,
                visible: savedSettings.display?.messageVisible || false
            });
            console.log(`📝 Session continuity: Current message synced: "${savedSettings.ui.messageInputValue}"`);
        }
        
        // Sync timeline settings
        if (savedSettings.timeline) {
            socket.emit('timelineUpdate', {
                startTime: savedSettings.timeline.startTime,
                endTime: savedSettings.timeline.endTime
            });
            console.log('📅 Timeline synced with server');
        }
        
        // Sync background color
        if (savedSettings.display && savedSettings.display.backgroundColor) {
            socket.emit('backgroundUpdate', { 
                backgroundColor: savedSettings.display.backgroundColor 
            });
            console.log('🎨 Background synced with server');
        }
        
        // Sync vMix settings
        if (savedSettings.vmix) {
            applyVmixConnection();  // Send vMix config to server
            console.log('📺 vMix synced with server');
        }
        
        console.log('✅ All restored data synced with server');
        
        // 🧹 CRITICAL: Clear existing server data before restore to prevent duplicates
        console.log('🧹 Clearing existing server data before restore...');
        
        // Clear existing messages
        try {
            const existingMessagesResponse = await fetch('/api/saved-messages');
            const existingMessagesData = await existingMessagesResponse.json();
            
            if (existingMessagesData.messages && existingMessagesData.messages.length > 0) {
                console.log(`🧹 Clearing ${existingMessagesData.messages.length} existing messages...`);
                for (const message of existingMessagesData.messages) {
                    await fetch(`/api/saved-messages/${message.id}`, { method: 'DELETE' });
                }
                console.log('✅ Existing messages cleared');
            } else {
                console.log('📭 No existing messages to clear');
            }
        } catch (error) {
            console.error('❌ Error clearing existing messages:', error);
        }
        
        // Clear existing markers
        try {
            const existingMarkersResponse = await fetch('/api/event-markers');
            const existingMarkersData = await existingMarkersResponse.json();
            
            if (existingMarkersData.markers && existingMarkersData.markers.length > 0) {
                console.log(`🧹 Clearing ${existingMarkersData.markers.length} existing markers...`);
                for (const marker of existingMarkersData.markers) {
                    await fetch(`/api/event-markers/${marker.id}`, { method: 'DELETE' });
                }
                console.log('✅ Existing markers cleared');
            } else {
                console.log('📍 No existing markers to clear');
            }
        } catch (error) {
            console.error('❌ Error clearing existing markers:', error);
        }
        
        // 🔄 NOW: Send restored messages and markers to server (clean slate)
        if (messagesArray && messagesArray.length > 0) {
            console.log('🔄 Sending restored messages to server...');
            for (const message of messagesArray) {
                try {
                    await fetch('/api/saved-messages/add', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: message.content
                        })
                    });
                } catch (error) {
                    console.error('❌ Failed to send message to server:', error);
                }
            }
            console.log(`✅ Sent ${messagesArray.length} messages to server`);
        }
        
        if (markersArray && markersArray.length > 0) {
            console.log('🔄 Sending restored markers to server...');
            for (const marker of markersArray) {
                try {
                    await fetch('/api/event-markers/add', {
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            time: marker.time,
                            title: marker.title,
                            note: marker.note || '',
                            type: marker.type || null
                        })
                    });
                } catch (error) {
                    console.error('❌ Failed to send marker to server:', error);
                }
            }
            console.log(`✅ Sent ${markersArray.length} markers to server`);
        }
        
        // 🔥 CRITICAL: Apply all restored settings to UI/Preview
        console.log('🎨 Applying all restored settings to UI preview...');
        
        // 🎯 FIRST: Update admin preview directly (before applying to server)
        if (savedSettings.display) {
            // Update title preview directly
            if (savedSettings.display.title) {
                const titlePreview = document.getElementById('title-preview');
                if (titlePreview) {
                    titlePreview.textContent = savedSettings.display.title;
                    if (savedSettings.display.titleFontSize) {
                        titlePreview.style.fontSize = savedSettings.display.titleFontSize + 'px';
                        window.titleFontSize = savedSettings.display.titleFontSize; // Update global variable
                    }
                }
                console.log('📝 Admin title preview updated');
            }
            
            // Update background color preview directly - CORRECT SELECTOR
            if (savedSettings.display.backgroundColor) {
                const previewScreen = document.getElementById('preview-screen');
                if (previewScreen) {
                    previewScreen.style.backgroundColor = savedSettings.display.backgroundColor;
                }
                console.log('🎨 Admin background preview updated (preview-screen)');
            }
            
            // Update timer font family preview directly - CORRECT SELECTOR  
            if (savedSettings.display.timerFontFamily) {
                const timerPreview = document.getElementById('timer-preview');
                if (timerPreview) {
                    timerPreview.style.fontFamily = savedSettings.display.timerFontFamily;
                }
                console.log('🔤 Admin font preview updated (timer-preview)');
            }
            
            // Update global logo variables
            if (savedSettings.display.logoDataUrl) {
                window.logoDataUrl = savedSettings.display.logoDataUrl;
            }
            if (savedSettings.display.logoSize) {
                window.logoSize = savedSettings.display.logoSize;
            }
        }
        
        // Apply display settings (title, background, logo, etc.) - sends to server
        applyDisplaySettings();
        
        // Apply sound settings
        applySoundSettings();
        
        // Apply timeline settings if timeline fields are restored
        if (savedSettings.ui && (savedSettings.ui.eventStartTime || savedSettings.ui.eventEndTime)) {
            applyTimelineSettings();
        }
        
        // Apply vMix settings
        if (savedSettings.vmix) {
            applyVmixSettings();
        }
        
        // Update timer display with restored values
        updateTimerDisplay();
        
        // Update preview logos
        updatePreviewLogos();
        
        console.log('✅ All restored settings applied to UI preview');

        // Success notification (currentLang already declared at top of function)
        const successTitle = currentLang === 'en' ? 'Auto-Save Restore Completed!' : 'Επαναφορά Auto-Save ολοκληρώθηκε!';
        const successMessage = currentLang === 'en'
            ? `Saved at: ${saveTime}\n\nAll settings have been restored and synced with the server.`
            : `Αποθηκευμένο στις: ${saveTime}\n\nΌλες οι ρυθμίσεις επαναφέρθηκαν και συγχρονίστηκαν με τον server.`;

        customAlert(successTitle, successMessage, 'success');
        
        console.log('✅ Auto-save restore completed successfully');
        
        // 🔥 CRITICAL: Event-driven save με delay μετά το restore για να διατηρηθούν τα restored values
        setTimeout(async () => {
            console.log('🔄 Post-restore save: Ensuring restored values are preserved...');
            await performSilentAutoSave();
            console.log('✅ Post-restore save: Restored values now saved to JSON');
        }, 1000); // 1 δευτερόλεπτο delay για DOM update

        // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" μετά το restore (μετά το save)
        setTimeout(() => {
            const messageInput = document.getElementById('message-input');
            const messagePreview = document.getElementById('message-preview');
            if (messageInput && messagePreview) {
                const currentMsg = messageInput.value.trim();
                const savedLang = localStorage.getItem('preferredLanguage') || 'el';
                const expectedMsg = savedLang === 'en' ? 'TIME UP' : 'ΤΕΛΟΣ ΧΡΟΝΟΥ';

                if ((currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') && currentMsg !== expectedMsg) {
                    messageInput.value = expectedMsg;
                    messagePreview.textContent = expectedMsg;
                    console.log(`🔄 [Post-Restore] Fixed message from "${currentMsg}" to "${expectedMsg}" based on language: ${savedLang}`);

                    // Broadcast το διορθωμένο μήνυμα
                    if (socket && socket.connected) {
                        socket.emit('updateMessage', {
                            message: expectedMsg,
                            visible: true
                        });
                        console.log(`📡 Broadcasted corrected message: ${expectedMsg}`);
                    }
                }
            }
        }, 1500); // 1.5 sec - ΜΕΤΑ το post-restore save

        // Close settings modal
        closeSettings();
        
    } catch (error) {
        console.error('❌ Auto-save restore error:', error);
        // Use currentLang from outer scope
        const errorMessage = currentLang === 'en'
            ? `❌ Error during auto-save restore:\n\n${error.message}\n\nPlease try again or contact support.`
            : `❌ Σφάλμα κατά την επαναφορά auto-save:\n\n${error.message}\n\nΠαρακαλώ δοκιμάστε ξανά ή επικοινωνήστε με υποστήριξη.`;

        alert(errorMessage);
    }
}




// Custom Confirm Dialog (δεν κολλάει τα inputs)
function customConfirm(title, message, confirmText = 'OK', cancelText = 'Ακύρωση') {
    return new Promise((resolve) => {
        // Δημιουργία overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
            align-items: center; justify-content: center;
        `;
        
        // Δημιουργία dialog
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: #2c3e50; padding: 30px; border-radius: 10px;
            max-width: 400px; width: 90%; text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `;
        
        dialog.innerHTML = `
            <h3 style="margin: 0 0 15px 0; color: #ff8c00;">${title}</h3>
            <p style="margin: 0 0 25px 0; color: white; line-height: 1.4;">${message}</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="confirm-cancel" style="
                    padding: 10px 20px; border: none; 
                    background: #28a745; color: white; border-radius: 5px; cursor: pointer;
                ">${cancelText}</button>
                <button id="confirm-ok" style="
                    padding: 10px 20px; border: none; 
                    background: #dc3545; color: white; border-radius: 5px; cursor: pointer;
                ">${confirmText}</button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // Event handlers
        const cleanup = () => document.body.removeChild(overlay);
        
        dialog.querySelector('#confirm-ok').onclick = () => {
            cleanup();
            resolve(true);
        };
        
        dialog.querySelector('#confirm-cancel').onclick = () => {
            cleanup();
            resolve(false);
        };
        
        // ESC key
        const handleKeyPress = (e) => {
            if (e.key === 'Escape') {
                cleanup();
                resolve(false);
                document.removeEventListener('keydown', handleKeyPress);
            }
        };
        document.addEventListener('keydown', handleKeyPress);
        
        // Focus στο OK button
        dialog.querySelector('#confirm-ok').focus();
    });
}

// 🔥 CRITICAL: Custom Alert για αποφυγή text field freeze
function customAlert(title, message, type = 'info') {
    // Δημιουργία overlay
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
        align-items: center; justify-content: center;
    `;
    
    // Χρώματα ανάλογα με τον τύπο
    const colors = {
        success: { bg: '#28a745', icon: '✅' },
        error: { bg: '#dc3545', icon: '❌' },
        warning: { bg: '#ffc107', icon: '⚠️' },
        info: { bg: '#17a2b8', icon: 'ℹ️' }
    };
    
    const config = colors[type] || colors.info;
    
    // Δημιουργία dialog
    const dialog = document.createElement('div');
    dialog.style.cssText = `
        background: #2c3e50; padding: 30px; border-radius: 10px;
        max-width: 600px; width: 90%; text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    `;
    
    dialog.innerHTML = `
        <h3 style="margin: 0 0 15px 0; color: ${config.bg};">${config.icon} ${title}</h3>
        <p style="margin: 0 0 25px 0; color: white; line-height: 1.4; white-space: pre-line;">${message}</p>
        <button id="alert-ok" style="
            padding: 10px 25px; border: none; 
            background: ${config.bg}; color: white; border-radius: 5px; cursor: pointer;
            font-size: 16px; font-weight: bold;
        ">OK</button>
    `;
    
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
    
    // Event handlers
    const cleanup = () => document.body.removeChild(overlay);
    
    dialog.querySelector('#alert-ok').onclick = cleanup;
    
    // ESC key support
    const handleKeyPress = (e) => {
        if (e.key === 'Escape') {
            cleanup();
            document.removeEventListener('keydown', handleKeyPress);
        }
    };
    document.addEventListener('keydown', handleKeyPress);
    
    // Focus στο OK button
    dialog.querySelector('#alert-ok').focus();
}

// Override το window.alert
//window.alert = customAlert;

// Clock Mode checkbox handler
document.getElementById('clock-mode-toggle').addEventListener('change', function() {
    const clockMode = this.checked;
    console.log('🕐 Clock mode enabled:', clockMode);
    
    // Update local state immediately for preview
    timerState.clockMode = clockMode;
    
    // Update preview display immediately
    updateTimerDisplay();
    
    // Στείλε ενημέρωση στον server
    socket.emit('clockModeUpdate', {
        clockMode: clockMode
    });
});

// vMix Video Timer checkbox handler
document.getElementById('vmix-enabled').addEventListener('change', function() {
    const isEnabled = this.checked;
    console.log('📹 vMix Video Timer enabled:', isEnabled);
    
    // Στείλε ενημέρωση στον server
    socket.emit('vmixSettingsUpdate', {
        enabled: isEnabled
    });
    
    // Άμεση ενημέρωση του preview στο admin
    const secondaryTimerPreview = document.getElementById('secondary-timer-preview');
    if (secondaryTimerPreview) {
        secondaryTimerPreview.style.display = isEnabled ? 'block' : 'none';
    }
});

// vMix Timer Export Input dropdown change handler  
document.getElementById('vmix-timer-export-input').addEventListener('change', function() {
    const selectedInput = this.value;
    console.log('🎯 vMix Timer Export Input selection changed:', selectedInput || 'Auto-detect');
    console.log('🔧 Triggering vMix connection update to apply manual timer input setting...');
    
    // Apply settings immediately when dropdown changes (restart monitoring)
    applyVmixConnection();
});

// Handle visibility change για sleep mode protection
document.addEventListener('visibilitychange', () => {
    if (!document.hidden && !socket.connected) {
        // Κλείσιμο παλιάς σύνδεσης αν υπάρχει
        if (socket) {
            socket.disconnect();
            socket.removeAllListeners();
        }
        connectToServer();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    stopPeriodicVmixCheck();
});

// ============== VMIX TALLY STATUS FUNCTIONS ==============

let vmixTallyActive = false;
let vmixCheckInterval = null;

// Setup socket listeners for vMix tally
function setupVmixTallyListeners() {
    console.log('🔧 [CLIENT] Setting up vMix tally socket listeners...');
    
    // Listen for tally state updates
    socket.on('tallyStateUpdate', (tallyState) => {
        console.log('📡 [CLIENT] Received tallyStateUpdate event:', tallyState);
        
        // Always process tallyStateUpdate (don't ignore when vmixTallyActive is false)
        // because this might be an offline notification
        
        // Stop periodic checking since we received an update (vMix is working)
        stopPeriodicVmixCheck();
        
        updateVmixTallyStatus(tallyState);
    });

    // Listen for vMix connection status
    socket.on('vmixConnectionStatus', (status) => {
        // Note: Button reference removed - vMix status now shown in LCD strip module

        if (!status.connected) {
            vmixTallyActive = false;
        } else {
            // Restart tally monitoring
            setTimeout(() => {
                initVmixTally();
            }, 500);
        }
    });
    
    // Listen for tally monitoring restart (when vMix IP changes)
    socket.on('restartTallyMonitoring', () => {
        console.log('🔄 [CLIENT] Received restart tally monitoring signal');
        
        // Stop current tally monitoring
        if (vmixTallyActive) {
            console.log('🛑 [CLIENT] Stopping current tally monitoring...');
            socket.emit('stopTallyMonitoring');
            vmixTallyActive = false;
        }
        
        // Wait a moment then restart with new connection
        setTimeout(() => {
            console.log('🚀 [CLIENT] Restarting tally monitoring with new vMix connection...');
            initVmixTally();
        }, 1000);
    });
    
    console.log('✅ [CLIENT] vMix tally socket listeners setup complete');
}

// Auto-start vMix tally monitoring on page load
function initVmixTally() {
    console.log('🚨 [CLIENT] Initializing vMix tally monitoring...');
    console.log('🔗 [CLIENT] Socket connected:', socket && socket.connected);
    
    if (!socket || !socket.connected) {
        console.log('❌ [CLIENT] Socket not connected, cannot start tally monitoring');
        // Note: Button reference removed - vMix status now shown in LCD strip module
        return;
    }
    
    // Prevent multiple initializations
    if (vmixTallyActive) {
        console.log('⚠️ [CLIENT] vMix tally already active, skipping initialization');
        return;
    }
    
    // Use auto-detection instead of hardcoded input key
    console.log('📤 [CLIENT] Emitting setTimerInputKeys: [] (auto-detect)');
    socket.emit('setTimerInputKeys', []); // Empty array = auto-detect by title
    
    // Start tally monitoring automatically
    console.log('📤 [CLIENT] Emitting startTallyMonitoring');
    socket.emit('startTallyMonitoring');
    
    vmixTallyActive = true;
    console.log('✅ [CLIENT] vMix tally auto-started, vmixTallyActive =', vmixTallyActive);
    
    // Set timeout to detect if we don't receive any tally updates (vMix offline)
    setTimeout(() => {
        // Note: Button reference removed - vMix status checking now handled by LCD strip module
        console.log('⚠️ [CLIENT] Monitoring for tally updates...');
        // Start periodic checking for vMix availability
        startPeriodicVmixCheck();
    }, 3000); // Wait 3 seconds for initial tally response
}

// Update the new tally status button
function updateVmixTallyStatus(tallyState) {
    // Note: vMix tally status button removed - functionality now handled by LCD strip module
    // This function kept to avoid breaking existing socket event handlers
}

// Periodic vMix connection checking
function startPeriodicVmixCheck() {
    if (vmixCheckInterval) {
        clearInterval(vmixCheckInterval);
    }
    
    console.log('🔄 [CLIENT] Starting periodic vMix checking every 10 seconds...');
    
    vmixCheckInterval = setInterval(() => {
        // Note: Button reference removed - vMix status checking now handled by LCD strip module
        if (socket && socket.connected) {
            // Try to restart tally monitoring (this will attempt reconnection)
            socket.emit('setTimerInputKeys', []); // Auto-detect
            socket.emit('startTallyMonitoring');
        }
    }, 10000); // Check every 10 seconds
}

function stopPeriodicVmixCheck() {
    if (vmixCheckInterval) {
        console.log('⏹️ [CLIENT] Stopping periodic vMix checking');
        clearInterval(vmixCheckInterval);
        vmixCheckInterval = null;
    }
}


   </script>
  
    <script>
        // 🎯 Easter Egg: Single Click on TimeCast Logo
        let easterEggActive = false;

        document.getElementById('timecast-logo').addEventListener('click', function() {
            console.log('🎯 Easter Egg Toggle!');
            toggleEasterEgg();
        });

        function toggleEasterEgg() {
            const logo = document.getElementById('timecast-logo');
            const waves = document.getElementById('admin-waves');
            
            easterEggActive = !easterEggActive;
            
            if (easterEggActive) {
                // Activate spinning, waves and glow
                logo.classList.add('timecast-spinning');
                logo.classList.add('timecast-glowing');
                waves.style.display = 'block';
                waves.classList.add('admin-waves-active');
                
                console.log('🌊 TimeCast Easter Egg: ACTIVATED (infinite loop - click to stop)');
            } else {
                // Deactivate spinning, waves and glow
                logo.classList.remove('timecast-spinning');
                logo.classList.remove('timecast-glowing');
                waves.style.display = 'none';
                waves.classList.remove('admin-waves-active');
                
                console.log('⏹️ TimeCast Easter Egg: DEACTIVATED');
            }
        }
    </script>

    <script>
        // 🌐 Translation function για static HTML elements
        function updateStaticTranslations() {
            const currentLang = localStorage.getItem('preferredLanguage') || 'el';
            const translations = {
                el: {
                    messageLabel: 'Μήνυμα:',
                    timerSettings: 'Ρυθμίσεις Χρονομέτρου:',
                    hours: 'ΩΡ',
                    minutes: 'ΛΕΠ',
                    seconds: 'ΔΕΥ',
                    warningLabel: 'Προειδοποίηση (δευτ.):',
                    applyBtn: 'Εφαρμογή',
                    connectedDevices: '📱 Συνδεδεμένες Συσκευές',
                    devicesOnline: 'συσκευές online',
                    currentEvent: ' ΤΡΕΧΟΝ ΓΕΓΟΝΟΣ:',
                    nextEvent: ' ΕΠΟΜΕΝΟ ΓΕΓΟΝΟΣ:',
                    afterNext: ' ΚΑΙ ΜΕΤΑ:',
                    waitingStart: 'Αναμονή εκκίνησης...',
                    noNext: 'Δεν υπάρχει επόμενο',
                    noAfterNext: 'Δεν υπάρχει μεθεπόμενο'
                },
                en: {
                    messageLabel: 'Message:',
                    timerSettings: 'Timer Settings:',
                    hours: 'HRS',
                    minutes: 'MIN',
                    seconds: 'SEC',
                    warningLabel: 'Warning (sec):',
                    applyBtn: 'Apply',
                    connectedDevices: '📱 Connected Devices',
                    devicesOnline: 'devices online',
                    currentEvent: ' CURRENT EVENT:',
                    nextEvent: ' NEXT EVENT:',
                    afterNext: ' AFTER NEXT:',
                    waitingStart: 'Waiting to start...',
                    noNext: 'No next event',
                    noAfterNext: 'No event after'
                }
            };

            const t = translations[currentLang];
            
            // Update all elements με data-translate attribute
            document.querySelectorAll('[data-translate]').forEach(element => {
                const key = element.getAttribute('data-translate');
                if (t[key]) {
                    element.textContent = t[key];
                }
            });
        }

        // Function για re-render όλων των event displays
        function refreshEventDisplays() {
            // Re-render saved messages list
            if (typeof renderSavedMessages === 'function') {
                renderSavedMessages();
            }
            
            // Re-update current events
            const currentEvents = window.currentEvents || [];
            if (currentEvents.length > 0) {
                updateCurrentEvent(currentEvents[0]);
                updateNextEvent(currentEvents[1]);
                updateAfterNextEvent(currentEvents[2]);
            } else {
                // Reset to default empty states
                updateCurrentEvent(null);
                updateNextEvent(null);
                updateAfterNextEvent(null);
            }
        }

        // Call translation function on page load
        document.addEventListener('DOMContentLoaded', updateStaticTranslations);
        
        // Update translations όταν αλλάζει η γλώσσα
        document.addEventListener('languageChanged', updateStaticTranslations);
        
        // Backup: Update translations όταν το language dropdown αλλάζει
        const languageSelect = document.getElementById('language-selector');
        if (languageSelect) {
            languageSelect.addEventListener('change', () => {
                setTimeout(updateStaticTranslations, 100); // Small delay για το localStorage update
            });
        }
        
        // === COMPANION MODULE FUNCTIONS ===
        
        // Load companion module info when settings open
        function loadCompanionModuleInfo() {
            fetch('/api/companion/module-info')
                .then(response => response.json())
                .then(data => {
                    const infoDiv = document.getElementById('companion-module-info');
                    if (data.filename) {
                        infoDiv.innerHTML = `📦 <strong>${data.filename}</strong> (${data.size}, v${data.version})`;
                        infoDiv.removeAttribute('data-i18n'); // Remove i18n since we show dynamic data
                    } else {
                        infoDiv.textContent = i18next.t('admin:companion.loadError', 'Module δεν βρέθηκε');
                    }
                })
                .catch(error => {
                    console.error('Error loading companion module info:', error);
                    const infoDiv = document.getElementById('companion-module-info');
                    infoDiv.textContent = i18next.t('admin:companion.loadError', 'Σφάλμα φόρτωσης');
                    infoDiv.removeAttribute('data-i18n');
                });
        }
        
        // Download companion module
        function downloadCompanionModule() {
            const link = document.createElement('a');
            link.href = '/api/companion/download-module';
            link.download = 'timecast-pro-1.0.0.tgz';
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Show companion installation instructions
        function showCompanionInstructions() {
            // Get language from selector (most reliable)
            const languageSelector = document.getElementById('language-selector');
            const currentLang = languageSelector ? languageSelector.value : 'el';
            
            console.log('🔍 Language from selector:', currentLang);
            
            if (currentLang === 'en') {
                const instructions = `
                    <strong>📖 COMPANION MODULE INSTALLATION GUIDE</strong><br><br>
                    <strong>1.</strong> Download Module (.tgz)<br>
                    <strong>2.</strong> Open Bitfocus Companion<br>
                    <strong>3.</strong> Go to "Modules" tab → "Install from file"<br>
                    <strong>4.</strong> Select the .tgz file<br>
                    <strong>5.</strong> Automatic installation<br>
                    <strong>6.</strong> Add buttons from "TimeCast Pro"<br><br>
                    💡 <strong>Tip:</strong> Make sure TimeCast Pro runs on the same IP as Companion.
                `;
                
                customAlert('🎮 Companion Module Installation', instructions, 'info');
            } else {
                const instructions = `
                    <strong>📖 ΟΔΗΓΙΕΣ ΕΓΚΑΤΑΣΤΑΣΗΣ COMPANION MODULE</strong><br><br>
                    <strong>1.</strong> Κατέβασμα Module (.tgz)<br>
                    <strong>2.</strong> Άνοιγμα Bitfocus Companion<br>
                    <strong>3.</strong> Tab "Modules" → "Install from file"<br>
                    <strong>4.</strong> Επιλογή αρχείου .tgz<br>
                    <strong>5.</strong> Αυτόματη εγκατάσταση<br>
                    <strong>6.</strong> Προσθήκη buttons "TimeCast Pro"<br><br>
                    💡 <strong>Tip:</strong> Βεβαιωθείτε ότι το TimeCast Pro τρέχει στην ίδια IP με το Companion.
                `;
                
                customAlert('🎮 Εγκατάσταση Companion Module', instructions, 'info');
            }
        }
        
        // Load companion module info when modal opens
        const originalOpenSettings = window.openSettings;
        if (originalOpenSettings) {
            window.openSettings = function() {
                originalOpenSettings();
                setTimeout(loadCompanionModuleInfo, 100);
                setTimeout(loadLicenseManagement, 200); // Load license info too
                setTimeout(fetchServerInfo, 50); // Update vMix Timer API URL
            };
        }
        
        // === LICENSE MANAGEMENT FUNCTIONS ===
        
        let licenseManagementData = {
            machineId: null,
            licenseStatus: null
        };
        
        // Offline grace period countdown timer
        let offlineGraceCountdownInterval = null;

        // Network connectivity monitoring
        let isCurrentlyOffline = false;

        // Monitor network connectivity changes
        function initNetworkConnectivityMonitoring() {
            // Listen for online/offline events
            window.addEventListener('online', handleNetworkOnline);
            window.addEventListener('offline', handleNetworkOffline);

            // Initial check
            if (!navigator.onLine) {
                isCurrentlyOffline = true;
            }
        }

        // Handle network coming back online
        async function handleNetworkOnline() {
            console.log('🌐 Network connectivity restored - checking license status...');

            if (isCurrentlyOffline) {
                isCurrentlyOffline = false;

                // Wait a moment for network to stabilize
                setTimeout(async () => {
                    try {
                        // Force a fresh license validation with robust retry logic
                        await refreshLicenseStatus();
                        console.log('✅ License status refreshed after network restoration');
                    } catch (error) {
                        console.error('❌ Failed to refresh license after network restoration:', error);
                    }
                }, 2000); // 2 second delay for network stabilization
            }
        }

        // Handle network going offline
        function handleNetworkOffline() {
            console.log('📱 Network connectivity lost');
            isCurrentlyOffline = true;
        }

        // Load license management information
        async function loadLicenseManagement() {
            console.log('🔑 Loading license management information...');

            try {
                // Load machine info
                await loadMachineInfo();

                // Load license status
                await refreshLicenseStatus();

                // Enable license key input validation
                setupLicenseKeyInput();

                // Initialize network connectivity monitoring
                initNetworkConnectivityMonitoring();

            } catch (error) {
                console.error('❌ Failed to load license management:', error);
                showLicenseError('Failed to load license information');
            }
        }
        
        // Load machine information
        async function loadMachineInfo() {
            try {
                console.log('🖥️ Loading machine information...');
                
                // Check if electronAPI is available (should work in main admin.html)
                if (window.electronAPI && window.electronAPI.getMachineInfo) {
                    const machineInfo = await window.electronAPI.getMachineInfo();
                    console.log('✅ Got machine info:', machineInfo);
                    
                    document.getElementById('license-computer-name').textContent = machineInfo.hostname;
                    document.getElementById('license-platform-info').textContent = `${machineInfo.platform} (${machineInfo.arch})`;
                    document.getElementById('license-memory-info').textContent = machineInfo.totalMemory;
                    document.getElementById('license-machine-id').textContent = machineInfo.machineId;
                    document.getElementById('license-machine-id').style.color = '#27ae60'; // Green για success
                    
                    licenseManagementData.machineId = machineInfo.machineId;
                    
                } else {
                    console.warn('⚠️ electronAPI not available - using server fallback');
                    
                    // Fallback to server-generated machine info (if we implement it)
                    const fallbackId = 'TC-SERVER-' + Date.now().toString(36).toUpperCase().substring(0, 8);
                    
                    document.getElementById('license-computer-name').textContent = 'Server Mode';
                    document.getElementById('license-platform-info').textContent = 'Unknown Platform';  
                    document.getElementById('license-memory-info').textContent = 'Unknown';
                    document.getElementById('license-machine-id').textContent = fallbackId;
                    document.getElementById('license-machine-id').style.color = '#f39c12'; // Orange για fallback
                    
                    licenseManagementData.machineId = fallbackId;
                }
                
            } catch (error) {
                console.error('❌ Failed to load machine info:', error);
                showLicenseError('Failed to load machine information');
            }
        }
        
        // Setup license key input validation
        function setupLicenseKeyInput() {
            const licenseInput = document.getElementById('license-key-input');
            const activateBtn = document.getElementById('activate-license-btn');
            
            licenseInput.addEventListener('input', function(e) {
                const value = e.target.value.trim().toUpperCase();
                
                // Auto-format license key
                let formattedValue = value.replace(/[^A-Z0-9]/g, '');
                
                // Add dashes automatically (TC-2025-XXXXXXXX pattern)
                if (formattedValue.length > 2 && formattedValue.length <= 7) {
                    formattedValue = formattedValue.substring(0, 2) + '-' + formattedValue.substring(2);
                } else if (formattedValue.length > 7) {
                    formattedValue = formattedValue.substring(0, 2) + '-' + formattedValue.substring(2, 6) + '-' + formattedValue.substring(6);
                }
                
                e.target.value = formattedValue;
                
                // Enable activate button if valid format
                const isValid = formattedValue.match(/^TC-\d{4}-[A-Z0-9]{4,}$/);
                activateBtn.disabled = !isValid;
                activateBtn.style.opacity = isValid ? '1' : '0.5';
            });
        }
        
        // Activate license
        async function activateLicense() {
            const licenseInput = document.getElementById('license-key-input');
            const licenseKey = licenseInput.value.trim();
            const loading = document.getElementById('license-loading');
            const activateBtn = document.getElementById('activate-license-btn');
            
            if (!licenseKey || !licenseManagementData.machineId) {
                showLicenseError('License key or machine ID missing');
                return;
            }
            
            try {
                console.log('🚀 Activating license:', licenseKey);
                
                // Show loading
                loading.style.display = 'inline';
                activateBtn.disabled = true;
                
                // Call license activation
                if (window.electronAPI && window.electronAPI.activateLicense) {
                    const result = await window.electronAPI.activateLicense(licenseKey, licenseManagementData.machineId);
                    
                    if (result.success) {
                        showLicenseSuccess(`✅ License activated successfully!<br>${result.message || ''}`);
                        licenseInput.value = ''; // Clear input
                        await refreshLicenseStatus(); // Refresh status
                    } else {
                        showLicenseError(`❌ License activation failed: ${result.error}`);
                    }
                } else {
                    showLicenseError('License activation not available (electronAPI missing)');
                }
                
            } catch (error) {
                console.error('❌ License activation error:', error);
                showLicenseError(`License activation error: ${error.message}`);
            } finally {
                loading.style.display = 'none';
                activateBtn.disabled = false;
            }
        }
        
        // Refresh license status
        async function refreshLicenseStatus() {
            console.log('🔄 Refreshing license status...');

            try {
                if (window.electronAPI && window.electronAPI.validateCurrentLicense) {
                    console.log('🔄 Checking license status (online + offline fallback)...');

                    // First try online validation to get the most current status
                    const licenseStatus = await window.electronAPI.validateCurrentLicense();

                    // Enhance status with additional metadata for UI decisions
                    if (licenseStatus.cached && licenseStatus.graceDaysRemaining !== undefined) {
                        console.log('🕒 App entered OFFLINE grace period mode');
                        licenseStatus.offlineGraceTriggered = true;
                    }

                    // Add explicit online/offline flag for UI logic
                    if (!licenseStatus.hasOwnProperty('online')) {
                        licenseStatus.online = !licenseStatus.cached;
                    }

                    console.log('📋 License status details:', {
                        valid: licenseStatus.valid,
                        online: licenseStatus.online,
                        cached: licenseStatus.cached,
                        current_machine_active: licenseStatus.license?.current_machine_active
                    });

                    displayLicenseStatus(licenseStatus);
                } else {
                    displayLicenseStatus({ valid: false, error: 'License validation not available' });
                }
            } catch (error) {
                console.error('❌ License status refresh error:', error);

                // Try offline cache when online validation fails
                try {
                    if (window.electronAPI && window.electronAPI.validateCurrentLicense) {
                        console.log('📱 Online failed, trying offline cache...');
                        const offlineStatus = await window.electronAPI.validateCurrentLicense();
                        displayLicenseStatus(offlineStatus);
                    } else {
                        displayLicenseStatus({ valid: false, error: 'No internet connection and offline validation not available' });
                    }
                } catch (offlineError) {
                    console.error('❌ Offline validation also failed:', offlineError);
                    displayLicenseStatus({ valid: false, error: 'No internet connection and no offline cache available' });
                }
            }
        }
        
        // Start offline grace period countdown
        function startOfflineGraceCountdown() {
            // Clear any existing countdown
            if (offlineGraceCountdownInterval) {
                clearInterval(offlineGraceCountdownInterval);
            }

            console.log('⏰ Starting offline grace period countdown...');

            offlineGraceCountdownInterval = setInterval(async () => {
                try {
                    // Refresh license status to get updated countdown
                    if (window.electronAPI && window.electronAPI.validateCurrentLicense) {
                        const licenseStatus = await window.electronAPI.validateCurrentLicense();

                        // Only update if still in offline grace mode
                        if (licenseStatus.cached && licenseStatus.graceDaysRemaining !== undefined) {
                            updateOfflineGraceDisplay(licenseStatus);
                        } else {
                            // No longer in grace mode - stop countdown
                            clearInterval(offlineGraceCountdownInterval);
                            offlineGraceCountdownInterval = null;
                        }
                    }
                } catch (error) {
                    console.error('❌ Offline grace countdown error:', error);
                }
            }, 1000); // Update every second
        }

        // Stop offline grace period countdown
        function stopOfflineGraceCountdown() {
            if (offlineGraceCountdownInterval) {
                clearInterval(offlineGraceCountdownInterval);
                offlineGraceCountdownInterval = null;
                console.log('⏹️ Stopped offline grace period countdown');
            }
        }

        // Update just the countdown part without full refresh
        function updateOfflineGraceDisplay(status) {
            if (status.graceTimeFormatted) {
                const timeElement = document.querySelector('#license-status-content [data-grace-time]');
                if (timeElement) {
                    timeElement.textContent = status.graceTimeFormatted;
                }
            }
        }

        // Display license status
        function displayLicenseStatus(status) {
            const statusContent = document.getElementById('license-status-content');
            const machineStatusElement = document.getElementById('machine-activation-status');

            // Stop any existing countdown
            stopOfflineGraceCountdown();

            if (status.valid) {
                // Determine status display based on online/offline state
                let statusDisplay = '✅ Valid License';
                let statusColor = '#27ae60';

                if (status.cached && status.graceDaysRemaining !== undefined) {
                    statusDisplay = '🚨 OFFLINE GRACE PERIOD';
                    statusColor = '#e67e22'; // Brighter orange for attention
                }

                statusContent.innerHTML = `
                    <div style="color: ${statusColor}; margin-bottom: 8px;">
                        <strong>${statusDisplay}</strong>
                    </div>
                    <div style="color: #bdc3c7; font-size: 0.7rem;">
                        Key: ${status.license?.key || 'Unknown'}<br>
                        ${status.license?.email ? `Email: ${status.license.email}<br>` : status.license?.customer ? `Owner: ${status.license.customer}<br>` : ''}
                        ${status.cached && status.graceDaysRemaining !== undefined ?
                            `<span style="color: #e67e22; font-weight: bold;">⚠️ No internet connection - App entered offline mode</span><br>` :
                            `Status: ${status.cached ? 'Offline mode' : 'Online verified'}<br>`
                        }
                        ${status.license?.expires_at ? `Expires: ${new Date(status.license.expires_at).toLocaleDateString('el-GR')}` : ''}
                        ${status.graceTimeFormatted ?
                            `<br><span style="color: #e67e22; font-weight: bold; font-size: 0.85rem;">⏱️ Time remaining: <span data-grace-time>${status.graceTimeFormatted}</span></span>` :
                            status.graceDaysRemaining !== undefined ?
                            `<br><span style="color: #e67e22; font-weight: bold;">⏰ Grace time remaining: ${status.graceDaysRemaining.toFixed(1)} days</span>` : ''
                        }
                        ${status.cached && status.graceDaysRemaining !== undefined ?
                            `<br><span style="color: #95a5a6; font-size: 0.65rem; font-style: italic;">Connect to internet to restore full functionality</span>` : ''
                        }
                    </div>
                `;
                
                // Update machine activation status and deactivate button visibility
                const deactivateBtn = document.getElementById('deactivate-machine-btn');

                // Enhanced machine status check - prioritize online validation over cached data
                let machineActive = false;

                if (status.online && status.license?.current_machine_active) {
                    // Online validation confirmed machine is active
                    machineActive = true;
                } else if (status.cached && !status.online) {
                    // Offline mode - use cached data but mark as uncertain
                    machineActive = status.license?.current_machine_active;
                } else if (status.online && status.license && status.license.current_machine_active === false) {
                    // Online validation confirmed machine is NOT active (remote deactivation)
                    machineActive = false;
                } else if (!status.license) {
                    // No license data at all
                    machineActive = false;
                }

                if (machineActive) {
                    const statusText = status.cached ? '✅ Machine Activated (Offline)' : '✅ Machine Activated';
                    machineStatusElement.innerHTML = `<span style="color: #27ae60;">${statusText}</span>`;
                    if (deactivateBtn) deactivateBtn.style.display = 'inline-block';
                } else {
                    const statusText = status.online ? '❌ Machine Deactivated' : '⚠️ Machine Status Unknown (Offline)';
                    const statusColor = status.online ? '#e74c3c' : '#f39c12';
                    machineStatusElement.innerHTML = `<span style="color: ${statusColor};">${statusText}</span>`;
                    if (deactivateBtn) deactivateBtn.style.display = machineActive ? 'inline-block' : 'none';
                }

                // Start countdown if in offline grace period
                if (status.cached && status.graceDaysRemaining !== undefined && status.graceTimeFormatted) {
                    console.log('🕒 Starting offline grace period live countdown');
                    startOfflineGraceCountdown();
                }
            } else {
                statusContent.innerHTML = `
                    <div style="color: #e74c3c; margin-bottom: 8px;">
                        <strong>❌ No Valid License</strong>
                    </div>
                    <div style="color: #95a5a6; font-size: 0.7rem;">
                        ${status.error || 'License not activated or expired'}
                    </div>
                `;
                
                // No valid license means not activated
                machineStatusElement.innerHTML = '<span style="color: #95a5a6;">⚪ Not Activated</span>';
                const deactivateBtn = document.getElementById('deactivate-machine-btn');
                if (deactivateBtn) deactivateBtn.style.display = 'none';
            }
        }
        
        // Show license success message
        function showLicenseSuccess(message) {
            // Use existing customAlert function
            if (typeof customAlert === 'function') {
                customAlert('License Activation', message, 'success');
            } else {
                alert(message.replace(/<br>/g, '\n').replace(/<[^>]*>/g, ''));
            }
        }
        
        // Show license error message
        function showLicenseError(message) {
            // Use existing customAlert function
            if (typeof customAlert === 'function') {
                customAlert('License Error', message, 'error');
            } else {
                alert(message);
            }
        }
        
        // Check for remote deactivation signals from customer portal
        async function checkForDeactivationSignal() {
            try {
                // Get current license key and machine ID
                const licenseKey = document.getElementById('license-key-input')?.value;
                if (!licenseKey || licenseKey.trim() === '' || licenseKey === 'TC-2025-XXXXXXXX') return;
                
                if (!window.electronAPI?.getMachineInfo) return;
                
                const machineInfo = await window.electronAPI.getMachineInfo();
                if (!machineInfo?.machineId) return;
                
                // Check licensing server for deactivation signal
                const response = await fetch('https://timecast.eu/licensing/api.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'validate',
                        license_key: licenseKey,
                        machine_id: machineInfo.machineId
                    })
                });
                
                const result = await response.json();
                
                // If license is no longer valid for this machine, show deactivation notice
                if (!result.valid || !result.license?.current_machine_active) {
                    console.log('🚫 Machine has been deactivated remotely');
                    
                    // Update machine status immediately
                    const machineStatusElement = document.getElementById('machine-activation-status');
                    if (machineStatusElement) {
                        machineStatusElement.innerHTML = '<span style="color: #e74c3c;">❌ Machine Deactivated</span>';
                    }
                    
                    // Show notification to user
                    if (typeof customAlert === 'function') {
                        customAlert(
                            'Machine Deactivated', 
                            'This machine has been deactivated remotely from the customer portal. TimeCast Pro will continue running but license validation may be affected.',
                            'warning'
                        );
                    }
                    
                    // Refresh license status to update UI
                    await refreshLicenseStatus();
                }
                
            } catch (error) {
                // Silent fail for network issues - this is normal when offline
                console.log('⚠️ Deactivation check failed (normal if offline):', error.message);
            }
        }
        
        // Local machine deactivation function
        async function deactivateThisMachine() {
            // Confirm with user first
            if (typeof customConfirm === 'function') {
                const confirmed = await customConfirm(
                    'Deactivate Machine',
                    'Είστε σίγουρος ότι θέλετε να απενεργοποιήσετε το TimeCast Pro από αυτό το machine;\n\nΑυτή η ενέργεια θα:\n• Απενεργοποιήσει το license από αυτόν τον υπολογιστή\n• Επιτρέψει τη χρήση του license σε άλλο machine\n• Διατηρήσει όλες τις ρυθμίσεις στην εφαρμογή'
                );
                if (!confirmed) return;
            } else {
                if (!confirm('Είστε σίγουρος ότι θέλετε να απενεργοποιήσετε το TimeCast Pro από αυτό το machine?\n\nΑυτή η ενέργεια θα απενεργοποιήσει το license από αυτόν τον υπολογιστή.')) {
                    return;
                }
            }
            
            try {
                console.log('🔓 Starting local machine deactivation...');
                
                // Show loading
                const deactivateBtn = document.getElementById('deactivate-machine-btn');
                if (deactivateBtn) {
                    deactivateBtn.textContent = '🔄 Deactivating...';
                    deactivateBtn.disabled = true;
                }
                
                // Get the current license key - try multiple sources
                let licenseKey = null;
                console.log('🔓 Starting license key detection...');
                
                // Method 1: Try global license data
                console.log('🔍 Method 1 - Checking global license data...');
                if (window.currentLicenseData && window.currentLicenseData.licenseKey) {
                    licenseKey = window.currentLicenseData.licenseKey;
                    console.log('🔑 Got license key from global data:', licenseKey);
                } else {
                    console.log('❌ Global license data not available');
                }
                
                // Method 2: Try localStorage 
                if (!licenseKey) {
                    console.log('🔍 Method 2 - Checking localStorage...');
                    try {
                        const storedLicense = localStorage.getItem('timecast_license_key');
                        console.log('📦 localStorage value:', storedLicense);
                        if (storedLicense && storedLicense !== 'TC-2025-XXXXXXXX') {
                            licenseKey = storedLicense;
                            console.log('🔑 Got license key from localStorage:', licenseKey);
                        } else {
                            console.log('❌ localStorage license key invalid or empty');
                        }
                    } catch (error) {
                        console.log('❌ Could not access localStorage:', error);
                    }
                }
                
                // Method 3: Try input field
                if (!licenseKey) {
                    console.log('🔍 Method 3 - Checking input field...');
                    const inputKey = document.getElementById('license-key-input')?.value;
                    console.log('📝 Input field value:', inputKey);
                    if (inputKey && inputKey.trim() !== '' && inputKey !== 'TC-2025-XXXXXXXX') {
                        licenseKey = inputKey;
                        console.log('🔑 Got license key from input field:', licenseKey);
                    } else {
                        console.log('❌ Input field license key invalid or empty');
                    }
                }
                
                // Method 4: Ask the main process for current license
                if (!licenseKey) {
                    console.log('🔍 Method 4 - Checking validation API...');
                    try {
                        if (window.electronAPI && window.electronAPI.validateCurrentLicense) {
                            console.log('📡 Calling validateCurrentLicense...');
                            const validation = await window.electronAPI.validateCurrentLicense();
                            console.log('📋 Validation response:', validation);
                            if (validation && validation.valid) {
                                // Try to extract license key from validation response
                                licenseKey = validation.licenseKey || 
                                           validation.license_key || 
                                           validation.key ||
                                           (validation.license && validation.license.key);
                                if (licenseKey) {
                                    console.log('🔑 Got license key from validation:', licenseKey);
                                } else {
                                    console.log('❌ Validation response has no license key field');
                                    console.log('❌ Full validation response:', JSON.stringify(validation, null, 2));
                                }
                            } else {
                                console.log('❌ Validation response invalid or not valid');
                            }
                        } else {
                            console.log('❌ validateCurrentLicense API not available');
                        }
                    } catch (error) {
                        console.log('❌ Could not get license from validation:', error);
                    }
                }
                
                console.log('🔍 Final license key result:', licenseKey);
                
                if (!licenseKey) {
                    throw new Error('No valid license key found. The application appears to be activated but the license key cannot be retrieved.');
                }
                
                // Call the main process to deactivate the machine
                if (window.electronAPI && window.electronAPI.deactivateMachine) {
                    console.log('🔓 Deactivating license:', licenseKey);
                    const result = await window.electronAPI.deactivateMachine(licenseKey);
                    
                    if (result.success) {
                        console.log('✅ Machine deactivated successfully');
                        
                        // Show success message
                        if (typeof customAlert === 'function') {
                            customAlert(
                                'Machine Deactivated',
                                '✅ Το machine απενεργοποιήθηκε επιτυχώς!\n\nΜπορείτε τώρα να χρησιμοποιήσετε το license σε άλλον υπολογιστή. Για να ενεργοποιήσετε ξανά σε αυτό το machine, εισάγετε το license key.',
                                'success'
                            );
                        } else {
                            alert('✅ Machine deactivated successfully!\n\nΜπορείτε τώρα να χρησιμοποιήσετε το license σε άλλον υπολογιστή.');
                        }
                        
                        // Clear license input field to prevent confusion
                        const licenseInput = document.getElementById('license-key-input');
                        if (licenseInput) {
                            licenseInput.value = '';
                            console.log('🧹 Cleared license input field after deactivation');
                        }

                        // Refresh license status to update UI
                        await refreshLicenseStatus();
                        
                    } else {
                        throw new Error(result.error || 'Deactivation failed');
                    }
                } else {
                    throw new Error('Machine deactivation not available in this version');
                }
                
            } catch (error) {
                console.error('❌ Local deactivation error:', error);
                
                // Show error message
                if (typeof customAlert === 'function') {
                    customAlert(
                        'Deactivation Failed',
                        '❌ Σφάλμα απενεργοποίησης:\n' + error.message,
                        'error'
                    );
                } else {
                    alert('❌ Deactivation failed:\n' + error.message);
                }
                
            } finally {
                // Restore button
                const deactivateBtn = document.getElementById('deactivate-machine-btn');
                if (deactivateBtn) {
                    deactivateBtn.textContent = '🔓 Deactivate Machine';
                    deactivateBtn.disabled = false;
                }
            }
        }
        
        // Start periodic deactivation monitoring
        function startDeactivationCheck() {
            // Check after 10 seconds on startup
            setTimeout(checkForDeactivationSignal, 10000);
            
            // Then check every 2 minutes for deactivation signals
            setInterval(checkForDeactivationSignal, 2 * 60 * 1000);
            
            console.log('🔍 Started periodic deactivation monitoring (every 2 minutes)');
        }
        
        // Auto-initialize deactivation monitoring when license management loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startDeactivationCheck);
        } else {
            startDeactivationCheck();
        }

        // ===== GLOSSY BUTTONS PREVIEW-MAIN-CONTENT MONITOR =====
        function initGlossyButtonsMonitor() {
            const previewMainContent = document.querySelector('.preview-main-content');
            const glossyContainer = document.querySelector('.glossy-controls-container');
            
            if (!previewMainContent || !glossyContainer) {
                console.warn('⚠️ Preview content or glossy container not found');
                return;
            }

            // Base dimensions for scaling calculation
            const basePreviewWidth = 600; // max-width of preview-main-content
            const baseButtonWidth = 57;   // original button width
            const baseButtonHeight = 45;  // original button height
            const baseSmallHeight = 32;   // original small button height
            const baseFontSize = 23;      // original font size
            const baseSmallFontSize = 18; // original small font size

            function updateButtonScaling() {
                // Get actual computed width of preview-main-content
                const currentPreviewWidth = previewMainContent.getBoundingClientRect().width;
                
                // Calculate scaling ratio based on preview-main-content
                const scalingRatio = currentPreviewWidth / basePreviewWidth;
                
                // Apply boundaries (never go below 0.7 or above 1.1)
                const boundedRatio = Math.max(0.7, Math.min(1.1, scalingRatio));
                
                // Calculate new dimensions
                const newButtonWidth = Math.round(baseButtonWidth * boundedRatio);
                const newButtonHeight = Math.round(baseButtonHeight * boundedRatio);
                const newSmallHeight = Math.round(baseSmallHeight * boundedRatio);
                const newFontSize = Math.round(baseFontSize * boundedRatio);
                const newSmallFontSize = Math.round(baseSmallFontSize * boundedRatio);
                
                // Apply to all glossy buttons
                const allButtons = glossyContainer.querySelectorAll('.glossy-btn');
                allButtons.forEach(button => {
                    if (button.classList.contains('glossy-btn-small')) {
                        button.style.width = `${newButtonWidth}px`;
                        button.style.height = `${newSmallHeight}px`;
                        button.style.fontSize = `${newSmallFontSize}px`;
                        // Flexbox centering (already set in CSS but ensure it's applied)
                        button.style.display = 'flex';
                        button.style.alignItems = 'center';
                        button.style.justifyContent = 'center';
                        button.style.textAlign = 'center';
                    } else {
                        button.style.width = `${newButtonWidth}px`;
                        button.style.height = `${newButtonHeight}px`;
                        button.style.fontSize = `${newFontSize}px`;
                        // Flexbox centering (already set in CSS but ensure it's applied)
                        button.style.display = 'flex';
                        button.style.alignItems = 'center';
                        button.style.justifyContent = 'center';
                        button.style.textAlign = 'center';
                    }
                });

                console.log(`🎯 Buttons scaled: Preview=${currentPreviewWidth}px, Ratio=${boundedRatio.toFixed(3)}, ButtonWidth=${newButtonWidth}px`);
            }

            // Initial scaling
            updateButtonScaling();

            // Monitor window resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(updateButtonScaling, 50); // Debounce
            });

            // Monitor DOM changes (για dynamic content changes)
            const resizeObserver = new ResizeObserver(() => {
                updateButtonScaling();
            });
            resizeObserver.observe(previewMainContent);

            console.log('🎯 Glossy buttons monitor initialized - following preview-main-content scaling');
        }

        // Initialize monitor when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGlossyButtonsMonitor);
        } else {
            initGlossyButtonsMonitor();
        }
    </script>

    <!-- i18next Browser Support για Remote Admin -->
    <script src="https://cdn.jsdelivr.net/npm/i18next@23.12.2/i18next.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/i18next-http-backend@2.5.2/i18nextHttpBackend.min.js"></script>

    <script>
    // Browser-based i18next initialization για remote admin.html
    async function initBrowserI18next() {
        try {
            console.log('🌐 [Browser] Initializing i18next for remote admin...');

            // Load saved language preference
            const savedLang = localStorage.getItem('preferredLanguage') || 'el';
            console.log('📋 [Browser] Saved language preference:', savedLang);

            // Initialize i18next με HTTP backend
            await i18next
                .use(i18nextHttpBackend)
                .init({
                    lng: savedLang,
                    fallbackLng: 'el',
                    supportedLngs: ['el', 'en'],
                    ns: ['admin'],
                    defaultNS: 'admin',
                    backend: {
                        loadPath: '/locales/{{lng}}/{{ns}}.json'
                    },
                    debug: false
                });

            console.log('✅ [Browser] i18next initialized - Language:', i18next.language);

            // Update UI with translations
            updateBrowserTranslations();

            // Update language selector
            const langSelector = document.getElementById('language-selector');
            if (langSelector) {
                langSelector.value = i18next.language;
            }

            // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" message μετά το restore
            setTimeout(() => {
                const messageInput = document.getElementById('message-input');
                const messagePreview = document.getElementById('message-preview');
                if (messageInput && messagePreview) {
                    const currentMsg = messageInput.value.trim();
                    if (currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') {
                        const correctEndTimeMsg = getEndTimeMessage();
                        if (currentMsg !== correctEndTimeMsg) {
                            messageInput.value = correctEndTimeMsg;
                            messagePreview.textContent = correctEndTimeMsg;
                            console.log(`🔄 [Browser-Restore] Updated end time message from "${currentMsg}" to "${correctEndTimeMsg}"`);

                            // Broadcast το διορθωμένο μήνυμα
                            if (socket && socket.connected) {
                                socket.emit('updateMessage', {
                                    message: correctEndTimeMsg,
                                    visible: true
                                });
                            }
                        }
                    }
                }
            }, 500); // Small delay to ensure DOM is ready

            return true;

        } catch (error) {
            console.error('❌ [Browser] i18next initialization failed:', error);
            return false;
        }
    }

    // Update all UI elements με browser i18next
    function updateBrowserTranslations() {
        if (typeof i18next === 'undefined' || !i18next.isInitialized) {
            console.log('⚠️ [Browser] i18next not ready for translations');
            return;
        }

        console.log('🔄 [Browser] Updating UI translations...');

        // Update all data-i18n elements
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            const translation = i18next.t(key);

            if (translation !== key) {
                element.textContent = translation;
            }
        });

        // Update placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
            const key = element.getAttribute('data-i18n-placeholder');
            const translation = i18next.t(key);

            if (translation !== key) {
                element.placeholder = translation;
            }
        });

        console.log('✅ [Browser] UI translations updated');
    }

    // NOTE: Socket.IO listener για 'languageChange' is already defined earlier in the file (line ~5578)
    // The unified listener works for both Electron and Browser modes

    // Override onLanguageChange function για browser mode
    const originalOnLanguageChange = window.onLanguageChange;
    window.onLanguageChange = async function() {
        const selector = document.getElementById('language-selector');
        const selectedLang = selector.value;

        console.log(`🌐 Language dropdown changed to: ${selectedLang}`);

        // Check if we're in browser mode (no electronAPI)
        if (typeof window.electronAPI === 'undefined') {
            console.log('🌐 [Browser Mode] Changing language via i18next...');

            if (typeof i18next !== 'undefined' && i18next.isInitialized) {
                await i18next.changeLanguage(selectedLang);
                console.log('✅ [Browser] Language changed to:', selectedLang);

                // Update UI
                updateBrowserTranslations();
                updateStaticTranslations();
                refreshEventDisplays();

                // ΚΡΙΣΙΜΟ: Ενημέρωση "ΤΕΛΟΣ ΧΡΟΝΟΥ / TIME UP" message αν εμφανίζεται
                const messageInput = document.getElementById('message-input');
                const messagePreview = document.getElementById('message-preview');
                if (messageInput && messagePreview) {
                    const currentMsg = messageInput.value.trim();
                    // Έλεγχος αν το τρέχον μήνυμα είναι "ΤΕΛΟΣ ΧΡΟΝΟΥ" ή "TIME UP"
                    if (currentMsg === 'ΤΕΛΟΣ ΧΡΟΝΟΥ' || currentMsg === 'TIME UP') {
                        const newEndTimeMsg = getEndTimeMessage();
                        messageInput.value = newEndTimeMsg;
                        messagePreview.textContent = newEndTimeMsg;
                        console.log(`🔄 [Browser] Updated end time message to: ${newEndTimeMsg}`);

                        // Broadcast το νέο μήνυμα
                        if (socket && socket.connected) {
                            socket.emit('updateMessage', {
                                message: newEndTimeMsg,
                                visible: true
                            });
                        }
                    }
                }

                // Save preference
                localStorage.setItem('preferredLanguage', selectedLang);

                // Broadcast to other clients
                if (socket && socket.connected) {
                    socket.emit('languageChange', { language: selectedLang });
                    console.log('📡 [Browser] Language change broadcast to other clients');
                }
            }
        } else {
            // Call original function για Electron mode
            originalOnLanguageChange.call(this);
        }
    };

    // Initialize browser i18next when DOM loads (only if electronAPI not available)
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            if (typeof window.electronAPI === 'undefined') {
                console.log('🌐 [Browser Mode Detected] Initializing browser i18next...');
                initBrowserI18next();
            } else {
                console.log('⚡ [Electron Mode Detected] Using electronAPI i18next');
            }
        }, 1500); // Delay to ensure socket connection is ready
    });
    </script>
</body>
</html>